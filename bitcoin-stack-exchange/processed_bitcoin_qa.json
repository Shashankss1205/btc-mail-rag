[
  {
    "question": "What is a good way to concisely explain Bitcoin?Often I'm asked to explain Bitcoin to someone and occasionally I come up with something stellar that really nails it, but most times it's a rambling incoherent mess. What I would like to see is a short and simple explanation of what Bitcoin is that is suitable for someone non-technical to understand.",
    "answers": [
      "Bitcoin is a new kind of money. It's the first decentralized electronic currency not controlled by a single organization or government. It's an open source project, and it is used by more than 100,000 people. All over the world people are trading hundreds of thousands of dollars worth of bitcoin every day with no middle man and no credit card companies. It's a startup currency which has never happened before. Bitcoin is the first digital currency that is completely distributed. The network is made up of users like yourself so no bank or payment processor is required between you and whoever you're trading with. This decentralization is the basis for Bitcoin's security and freedom. Email let us send letters for free, anywhere in the world. Skype lets us make phone and video calls for free, anywhere in the world. Now there's bitcoin. Bitcoin lets you send money to anyone online, anywhere in the world for less than a cent per transaction! Bitcoin is a community run system not controlled by any bank or government. There's no wallstreet banker getting rich by standing between you and the people you want to send and receive money from. Bitcoin is more efficient than all competing currencies. This will drive its adoption in the same way computers were adopted, in that computers made people more efficient in competing in the marketplace. A currency has value by it being widely used. Bitcoin is a startup currency with a deflationary bootstrapping economy. Its use spreads by providing the speculator incentive. Bitcoin is going to be the biggest opportunity for innovation that the world has seen since the industrial revolution. An idea whose time has come.",
      "Adapted from the New to Bitcoin? Start here! post on the bitcointalk forums that has received over 250,000 views: Introduction to Bitcoin Forget most things you've heard. People discover Bitcoin in a variety of ways, but usually pick up some sort of misconception like \"Bitcoin gives free money to people with computers\" or \"in order to use Bitcoin I have to use a program that wastes electricity for nothing\" along the way. Here is a good summary to help you understand Bitcoin in general, by focusing on what Bitcoin is and what problem it solves . These two things are not typically well explained on most websites, and it is difficult to appreciate just how effective a technology Bitcoin is until they are understood. What Bitcoin is: An agreement amongst a community of people to use 21 million secure mathematical tokens--\"bitcoins\"--as money, like traditional African and Asian societies used the money cowry . Unlike the money cowry: there will never be more bitcoins they are impossible to counterfeit they can be divided into as small of pieces as you want and they can be transferred instantly across great distances via a digital connection such as the internet. This is accomplished by the use of powerful cryptography many times stronger than that used by banks. Instead of simply being \"sent\" coins have to be cryptographically signed over from one entity to another, essentially putting a lock and key on each token so that bitcoins can be securely backed up in multiple places, and so that copying doesn't increase the amount you own. Because bitcoins are given their value by the community, they don't need to be accepted by anyone else or backed by any authority to succeed. They are like a local currency except much, much more effective and local to the whole world. As an example of how effective the community is at \"backing\" the bitcoin: on April 4th 2011 30,000 bitcoins were abruptly sold on the largest Bitcoin exchange, consuming nearly all \"buy\" offers on the order book and dropping the price by nearly 1/3. But within a couple of days, the price on the exchange had fully rebounded and bitcoins were again trading at good volumes, with large \"buy\" offers slowly replacing the ones consumed by the trades. The ability of such a small economy (there were only 5 million out of the total 21 million bitcoins circulating then, or about 3.75 million USD worth at then-current exchange rates ) to absorb such a large sell-off without crashing shows that bitcoins were already working beautifully. What problem Bitcoin solves: Mathematically, the specific implementation of the bitcoin protocol solves the problem of \"how to do all of the above without trusting anyone \". If that sounds amazing, it should! Normally a local currency has to trust all kinds of people for it to be able to work. So does a national currency. And in both cases, that trust is often abused. But with Bitcoin, there's no one person who can abuse the system. Nobody can print more money, nobody can re-use the coins simply by making a copy, and nobody can use anyone else's coins without having direct access to their keys. People who break its mathematical \"rules\" simply end up creating a whole different system incompatible with the first. As long as these rules are followed by someone , the only way Bitcoin can fail is for everyone to stop using it. This marvelous quality of not having to trust anyone is achieved in two ways. First, through the use of cutting-edge cryptography. Cryptography ensures that only the owner of the bitcoins has the authority to spend them. The cryptography used in Bitcoin is so strong that all the world's online banking would be compromised before Bitcoin would be, and it can even be upgraded if that were to start to happen. It's like if each banknote in your pocket had a 100-digit combination lock on it that couldn't be removed without destroying the bill itself. Bitcoin is that secure. But the second way of securing the system, called the blockchain , is where the real magic happens. The blockchain is a single, authoritative record of confirmed transactions which is stored on the peer to peer bitcoin network. Even with top-notch digital encryption, if there was no central registry to show that certain bitcoins had already been \"paid\" to someone else, you could sign over the same coins to multiple people in what's called a double-spend attack , like writing cheques for more money than you have in your account. Normally this is prevented by a central authority, the bank, who keeps track of all the cheques you write and makes sure they don't exceed the amount of money you have. Even so, most people won't accept a cheque from you unless they really trust you, and the bank has to spend a lot of money physically protecting those central records, whether they are kept in a physical or digital form. Not to mention, sometimes a bank employee can abuse their position of trust. And, in traditional banking, the bank itself doesn't have to follow the rules you do--it can lend out more money than it actually has . The blockchain fixes all these problems by creating a single master registry of the already-cryptographically-secured bitcoin transfers, verifying them and locking them down in a highly competitive market called mining . In return for this critical role, the Bitcoin community rewards miners with a set amount of bitcoins per block, taken from the original limited quantity on a pre-agreed schedule . As that original amount gradually runs out, this reward will be replaced by fees paid to prioritise one transaction over another--again in a highly competitive market to ensure the lowest possible cost. The transactions are verified and locked in by the computational work of mining in a very special way so that no one else can change the official record of transactions without doing more computational work than the cumulative work of all miners across the whole network . In conclusion: All this mathematical technology may be a bit of a mouthful, but what it means in practice is that Bitcoin works just like cash . Bitcoin transactions are intentionally irreversible --unlike credit cards or PayPal where chargebacks can invalidate a payment that has already been made. And there are no middlemen . Transactions are completed directly between the sender and the receiver via the peer to peer network. Because of Bitcoin's intricate design, the network remains secure no matter where or how you process bitcoin transactions . Which is incredible--no one else has ever tried to create a system that worked this way! All previous monetary systems have relied on trusting somebody , whether it was the king, town hall, the federal reserve, or banks. Bitcoin doesn't. It's guaranteed instead by the laws of mathematics, and that's why it has everyone from technologists to economists very excited ."
    ]
  },
  {
    "question": "What exactly is Mining?I have heard that mining is for people with ready hardware and blah blah blah... But what exactly is it? Does it operate like real mining? I mean, people talk about it like you are physically mining.",
    "answers": [
      "David Schwartz's answer is entirely accurate, but all that \"bitspeak\" might be a little intimidating to the average user. Let me try and put it into more plain language: The way Bitcoin works is that instead of having one central authority who secures and controls the money supply (like most governments do for their national currencies), this work is spread out all across the network. Most of the heavy lifting for Bitcoin is done by \"miners\". Miners collect the transactions on the network (like \"Alice pays Karim 10 bitcoins\" and \"Liam pays Sofia 8.3 bitcoins\") into large bundles called blocks . These blocks are strung together into one continuous, authoritative record called the block chain , which doesn't permit any conflicting transactions. This is necessary because without it people would be able to sign the same bitcoins over to two different recipients , like writing cheques for more money than you have in your account. The block chain lets you know for sure exactly which transactions count and can be trusted (so no bad cheques!). The way Bitcoin makes sure there is only one block chain is by making blocks really hard to produce. So instead of just being able to make blocks at will, miners have to compute a cryptographic hash of the block that meets certain criteria. Bitcoiners refer to this process as \"hashing\" . The only way to find a cryptographic hash that's \"good enough to count\" is to try computing a whole bunch of them until you get lucky and find one that works. This is the \"lottery\" that David Schwartz refers to, because miners who successfully create a block are rewarded some bitcoins according to a preset schedule . The difficulty of the criteria for the hash is continually adjusted based on how frequently blocks are appearing, so more competition equals more work needed to find a block . Modern dedicated mining hardware (e.g. ASIC miners) can try trillions of hashes per second, so to be competitive in this race to find hashes miners need specialised hardware, otherwise they will tend to spend more on electricity than they make in the \"lottery\". In addition to the hash criteria, a block needs to contain only valid, non-conflicting transactions. So the other main task for miners is to carefully validate all the transactions that go into their blocks , otherwise they won't get any reward for their work! Because of all this work, when a Bitcoin client signs on to the network it can trust the block chain that was most difficult to produce (since this is evidently the one that was being worked on by the most miners). If there was a \"fake\" blockchain competing with the real ones (say, where someone pretends that they didn't actually give Sofia those 8.4 bitcoins and they still have them), the fraudster would have to do as much work as the whole rest of the network to make their block chain look as trustworthy. So essentially, the intense work that goes into finding blocks through hashing secures the network against fraud . There is also, of course, some nifty code that figures out how to choose between conflicting transactions; and what to do if two people find valid blocks at the same time. One last thing: why is it called mining? In the original analogy, people who performed this essential work were compared to gold miners digging the gold out of the ground so that everyone could use it. But in reality, Bitcoin \"miners\" are just running computer programs on very specialised hardware that automates the process of securing the network. To sum up, this software Collects transactions from the network Validates them, and doesn't allow conflicting ones Puts them into large bundles called blocks Computes cryptographic hashes over and over until if finds one \"good enough to count\" Then submits the block to the network, adding it to the block chain and earning a reward in return . That's mining in a nutshell!",
      "mining is doing the work of finding nonce so that sha256(sha256(data+nonce)) < difficulty where nonce is an integer number the miner chooses freely (this choosing of the nonce and checking if the condition ( < difficulty ) is met comprises the work data is a hash over the contents of the block (transactions) and the previous block's hash sha256() is the SHA-256 cryptographic hashing function ( wikpedia SHA-2 article ) difficulty is a value that is adjusted consensually by the nodes of the bitcoin network to adjust for change in network computation power in order to have one block every 10 minutes found by the network The resulting nonce is the proof of work : since it's impossible to find nonce without essentially trying different nonces and calculating the two hash functions, having found a nonce that satisfies the condition is proof this work of searching and calculating has in fact been done. This is the central idea behind Bitcoin to solve the double spending problem: due to the inclusion of the previous block's hash in data (this links the blocks to form a chain) and the fact that the honest nodes of the network always do their work on the longest chain of blocks, a double spending attack involves calculating (and later publishing) a forked block chain in secret that is longer than the \"honest chain\" (containing the transaction that should be undone). Due to the work required to do this, this race can only be won if the attacker has greater computation power than the rest of the network together. Since using such computation power to honestly mine is likely more profitable than pulling a double-spend, the incentive for doing a double-spend attack is low."
    ]
  },
  {
    "question": "How do Bitcoin clients find each other?What protocols or algorithms are Bitcoin clients using in order to find their peers? I learnt that BitTorrent clients may rely on central computers called trackers. Do Bitcoin clients need any kind of central servers or nodes in order to operate?",
    "answers": [
      "Bitcoin clients use several methods to locate other clients. The primary method is a list of nodes from a previous connection to the network. The works very well for everything but your first connection or a connection after a very long period of disconnection. For the case where you have no previous known IPs or they aren't usable, the primary fallback method is by DNS seeds. Several host names (such as dnsseed.bluematt.me ) are maintained that resolve to a list of IP addresses known to be running nodes. Should that fail, the client has a list of IP addresses believed to point to stable nodes hard-coded into it. One method that used to be used, but that has since been abandoned, was having the clients locate each other using an IRC server. That worked similar to a BitTorrent tracker. Once you are connected to the network, you will begin to receive lists of IP addresses and ports of known clients.",
      "There's a couple of methods the client can use . However, unlike David's very good answer, I'll talk about them in chronological order: The number one way that clients learn about other clients is by connecting to another client and issuing the 'getaddr' command. The standard client has always had that ability. However, there's a problem with this - how do you learn about client #1? IRC seeding. This is something that's been in since the first version too. It was simple to implement, but ultimately didn't scale. The first version connected to freenode. Then, bitcoin nodes started getting k-lined . Later versions connected to lfnet. Then, lfnet went down, and IRC support was removed entirely. DNS was around by this point, so that was fine. IP addresses of well known nodes. This has been in the client since June 2010. Still in the Bitcoin client, though the exact IP addresses change every so often. DNS seeding. This has been in the client since March 2011. This is easier to scale, because DNS is already built to handle tens of thousands of connections."
    ]
  },
  {
    "question": "What are \"bitcoin days destroyed\"?The concept of bitcoin days destroyed has been proposed as a measure of bitcoin volume. However, I don't think the bitcoin wiki really explains the idea very well. What is the purpose or advantage of knowing this statistical value?",
    "answers": [
      "The idea of \"bitcoin days destroyed\" came about because it was realised that total transaction volume per day might be an inappropriate measure of the level of economic activity in Bitcoin. After all, someone could be sending the same money back and forth between their own addresses repeatedly. If you sent the same 50 btc back and forth 20 times, it would look like 1000 btc worth of activity, while in fact it represents almost nothing in terms of real transaction volume. With \"bitcoin days destroyed\", the idea is instead to give more weight to coins which haven't been spent in a while . To do this, you multiply the amount of each transaction by the number of days since those coins were last spent. So, 1 bitcoin that hasn't been spent in 100 days (1 bitcoin * 100 days) counts as much as 100 bitcoins that were just spent yesterday (100 bitcoins * 1 day). Because you can think of these \"bitcoin days\" as building up over time until a transaction actually occurs, the actual measure is called \"bitcoin days destroyed \". This is believed to give a better indication of how much real economic activity is occurring on the bitcoin network . So how well does it work? Well, it's still not perfect, because the other day I moved some coins out of a wallet they've been in for several months without spending them or giving them away. And some genuine businesses have very rapid turnover in bitcoins, so they're not being measured well by this method. But it does do a good job of filtering out the \"noise\" of bitcoins that are just \"bouncing around\" without really going anywhere. The graph of overall bitcoin days destroyed is believed to show that the genuine level of activity in the Bitcoin economy is continually increasing --it's not just one person experimenting by rapidly sending the same coins back and forth, flooding the network with meaningless chatter. Looks pretty good, hey? Image from the Bitcoin wiki . The above graph is in percentage of bitcoin days destroyed and a little out of date--for a regularly updated version in bitcoin days destroyed check out Bitcoin Days Destroyed - Active Chart instead!",
      "I personally prefer to think of bitcoin days destroyed as a measurement of \"hoarding\", not as a measure of economic activity. Cumulative: http://pi.uk.com/bitcoin/charts/bitcoin-days-destroyed-cumulative?timespan=180days&showDataPoints=false&daysAverageString=1 Steep parts of the chart represent a high number of bitcoin days destroyed which as nealmcb states could be early adopters cashing out or moving coins between wallets. It does not necessarily not represent increasing transaction volume. None cumulative: http://pi.uk.com/bitcoin/charts/bitcoin-days-destroyed?timespan=180days&showDataPoints=false&daysAverageString=1 Peaks represent a large volume of old coins being transferred. You can see there is some correlation between the number of transactions"
    ]
  },
  {
    "question": "Why is my transaction not getting confirmed and what can I do about it?I sent a transaction without (or with an exceptionally small) transaction fee using extremely small or unconfirmed inputs while the stars were not standing right. For whatever reason, I have been waiting forever for my transaction to confirm. Why is it taking so long for my transaction to confirm? What can I do to speed-up the transaction’s confirmation? This is a canonical question serving as a lightning rod for the flood of \"unconfirmed transaction\" questions we are experiencing lately. Please provide a detailed and broad answer to serve a wide range of these questions.",
    "answers": [
      "How Bitcoin Mining Works Bitcoin transactions are mined (processed) by Miners, and Miners want to benefit from their work. By mining transactions with higher fees, they make more money. Some miners can decide to mine all transactions no matter the fee but they still must compete with every other financially motivated miner. Why is it taking so long for my transaction to confirm? If you have sent a transaction without (or with an exceptionally small) transaction fee expect it to be ignored for an unknown amount of time until a miner decides to process it and solves the block; this could be several days to several weeks, possibly never. Your wallet and any Bitcoin node will show it as unconfirmed, your transaction is stuck in limbo. Block sizes are limited, which means that only a limited number of transactions can be processed in a certain timeframe. In the beginning of bitcoin, there was lots of free space in each block because there were not many transactions. However, now that Bitcoin is quite popular there are more transactions than can be processed into the current block. This is why transaction fees have increased, and as long as someone is still willing to pay more they will keep increasing. What can I do to speed-up the transaction’s confirmation? Nothing. The next best thing is to cancel and resend the transaction. Make a note of the individual bitcoin address(es) that the unconfirmed transaction was sent from. Run Bitcoin Core with the -zapwallettxes option (or wait a few days until your wallet stops broadcasting the transaction and it falls out of the global transaction mempool). (Issue with mempool.dat resolved by #10330 in 0.15.0). Send all your bitcoins from the addresses recorded in step 1 to a new address with the recommended or higher than recommended fee . Make original transaction again using the recommended fee. What to watch out for Sites that claim to \"speed up your unconfirmed bitcoin transaction\". From personal experience, these sites are either scams or just don't work. DOUBLE PAYMENTS. If the addresses used in the original transaction have sufficient bitcoin in them to cover the transaction, it can always be completed at a later date. To avoid this, follow step 3 to empty the associated addresses and do not reuse them. What is the recommended fee? Transaction fees vary by the size of your transaction, and not all transactions are the same size. The fee for same sized transactions also depends on how busy the bitcoin network is at the moment. An estimate (at the time of original post) was between 11-20 satoshi/byte (0.00011-0.00020BTC/kB) but now can be much higher. Most wallets have a feature which dynamically calculates the rate based on network congestion. See https://bitcoinfees.earn.com/ for a live chart of suggested transaction fees",
      "Yes, there is a way to save a borked transmission. A restart of the wallet and some patience typically fixes the issue. How to stop/reverse a Bitcoin transaction without confirmations: Run bitcoind and with -zapwallettxes . This makes the wallet \"forget\" any unconfirmed transactions, thus enabling you to reuse their inputs. Create a new transaction to make your payment and add an appropriate fee this time. The unconfirmed transaction is still valid and may still be floating around in the network, so be sure to spend its inputs to yourself, or the transaction may be confirmed at a later time and you'll end up double-paying. The simplest way is to send all your bitcoins to yourself. Don't forget an appropriate fee. ;)"
    ]
  },
  {
    "question": "What are bitcoin miners really solving?As with mining, what are the bitcoin miners really solving? I read they are solving hashes, but what does that really mean. Can we see what they are solving? Can someone give an example of what a bitcoin mining machine sees to solve?",
    "answers": [
      "Here is an extremely simplified sketch of the problem, but it should give a pretty good idea of what the problem is. The data: This is the hash of the lastest block (shortened to 30 characters): 00000000000001adf44c7d69767585 These are the hashes of a few valid transactions waiting for inclusion (shortened). 5572eca4dd4 db7d0c0b845 And this the hash of one special transaction that you just crafted, which gives 25BTC (the current reward) to yourself: 916d849af76 Building the next block: Now, let's use a gross approximation of what a new block might look like (the real one uses binary format). It contains the hash of the previous block and the hashes of those 3 transactions: 00000000000001adf44c7d69767585--5572eca4dd4-db7d0c0b845-916d849af76-- Now let's do mining by hand! Our goal is to complete this block with a nonce (a piece of garbage) such that the hash of the new block starts with 13 zeros (considering the previous hash, it seems that 13 zeroes is the current difficulty!). Mining (trying to finalize this block): Let's try with nonce=1, and compute the hash of the block (I'm using the md5 hash algorithm, but Bitcoin uses double sha256): > echo \"00000000000001adf44c7d69767585--5572eca4dd4-db7d0c0b845-916d849af76--1\" | md5sum 8b9b994dcf57f8f90194d82e234b72ac No luck, the hash does not start with a 0… Let's try with nonce=2 > echo \"00000000000001adf44c7d69767585--5572eca4dd4-db7d0c0b845-916d849af76--2\" | md5sum 5b7ce5bcc07a2822f227fcae7792fd90 No luck… … If we pursue until nonce=16, we get our first leading zero. > echo \"00000000000001adf44c7d69767585--5572eca4dd4-db7d0c0b845-916d849af76--16\" | md5sum 03b80c7a34b060b33dd8fbbece79cee3 For nonce=208, we get two leading zeroes! > echo \"00000000000001adf44c7d69767585--5572eca4dd4-db7d0c0b845-916d849af76--208\" | md5sum 0055e55df5758517c9bed0981b52ce4a Continue like this… If you finally find a hash that has 13 leading zeroes… you're a winner! Other miners will now build upon your block, you've just got 25BTC. But you'll have to be fast! Back to step 1… If someone manages to build a block before you do, you'll have to start again from the beginning with the new block's hash (the one of the winner).",
      "The following is a description of the global, statistical gamble which is played every 10 or so minutes. The interval of the game is controlled by the difficulty which says how many \"hashes\" are needed per interval. In other words, the difficulty and target define the \"odds of the house\" against your chance of getting a winning SHA hash. The nonce is the \"scratch off\" area. Each hash consumes electricity, and emits heat, which requires additional cooling. This is what is done with each hash: Step 1 At a high level, the miner software takes a list of active transactions, and then groups them together in something called a \"block\". Or more accurately stated: The miner software coverts all the transactions into a summary view called a \"merkle root\", and hashes it, which is representative of the transactions. Step 2 Then mining software converts this to into a binary format called a Block Header , which also references the previous blocks (also called a chain). Field Purpose Updated when... Size (Bytes) Version Block version number You upgrade the software and 4 it specifies a new version hashPrevBlock 256-bit hash of the previous A new block comes in 32 block header hashMerkleRoot 256-bit hash based on all A transaction is accepted 32 the transactions in the block Time Current timestamp as seconds Every few seconds 4 since 1970-01-01T00:00 UTC Bits Current target in compact format The difficulty is adjusted 4 Nonce 32-bit number (starts at 0) A hash is tried (increments) 4 Step 3: The miner hardware changes a small portion of this block called a \"nonce\". Step 4: The block header is hashed and compared to the Target as if it were simply a large number like 10,000,000 > 7,000,000 (the real numbers are much bigger, and in hex). The target is compressed and stored in each block in a field called bits. An expanded target looks like this: Target 0000000000000083ef00000000000000000000000000000000000000000000000 And the goal is to make sure the SHA256 hash of the block is less than this value. In the example below \" 83ee \" is smaller than \" 83ef \" To simplify this concept, you can ballpark the target by counting the leading zeros (as the other answer here explains). Here is an example: Here is a sample block with transactions you can view on BlockChain.info. Look in the upper right hand corner of the webpage for this hash: Hash 0000000000000083ee9371ddff055eed7f02348e4eda36c741a2fc62c85bc5cf That previous hash was from today and has 14 leading zeroes. Let's compare that to what was needed 3 years ago with block 100 which has 8 leading zeros. Hash 00000000a8ed5e960dccdf309f2ee2132badcc9247755c32a4b7081422d51899 Summary So at the end of the day, all a miner does is: Take a block header as input Change the Nonce Test if the Block Header hash is less than the Target. If it is, you win. Go to step 2 (or go to step 1 if someone else won the block) Want to see what Bitcoin-QT does when it finds a block?... I posted it here. . The information in this post will help you understand what happened."
    ]
  },
  {
    "question": "What is a 'Satoshi'?I am aware that Satoshi Nakamoto is the author of the paper that originated Bitcoin and the creator of the original bitcoin client. However, I often hear the term Satoshi as if it was a monetary unit. What is a Satoshi ?",
    "answers": [
      "A Satoshi is the smallest fraction of a Bitcoin that can currently be sent: 0.00000001 BTC, that is, a hundredth of a millionth BTC. In the future, however, the protocol may be updated to allow further subdivisions, should they be needed. Further examples of units 1 BTC = 1,000 mBTC (millibitcoin) 1 BTC = 1,000,000 μBTC (microbitcoin) 1 BTC = 100,000,000 Satoshis 1 mBTC = 100,000 Satoshis 1 μBTC (microbitcoin) = 100 Satoshis",
      "1 mBTC = 0.001 BTC 1 mBTC = 100,000 Satoshis 1 uBTC = 0.000001 BTC 1 μBTC = 100 Satoshis 1 Satoshi = 0.00000001 BTC 100 Satoshis = 0.000001 BTC 1,000 Satoshis = 0.00001 BTC 10,000 Satoshis = 0.0001 BTC 1 BTC = 100,000,000 Satoshis 1 BTC = 1,000,000 μBTC 1 BTC = 1000 mBTC"
    ]
  },
  {
    "question": "What can an attacker with 51% of hash power do?Suppose organization X has 51% of the hash power for a period of 1 week. In this week, what exactly can and can't X do?",
    "answers": [
      "Actually, it's very easy to do damage to the network once you have 51%; just build your own chain faster than the network, and broadcast it whenever you like. If you send some of your coins to a new address in your own chain, all the transactions issued in the live network by spending those same coins will be reversed at the moment the longer chain is broadcast. Right from the bitcoin wiki (probably proof-read by many pairs of eyes) : An attacker that controls more than 50% of the network's computing power can, for the time that he is in control, exclude and modify the ordering of transactions. This allows him to: Reverse transactions that he sends while he's in control Prevent some or all transactions from gaining any confirmations Prevent some or all other generators from getting any generations The attacker can't: Reverse other people's transactions Prevent transactions from being sent at all (they'll show as 0/unconfirmed) Change the number of coins generated per block Create coins out of thin air Send coins that never belonged to him It's much more difficult to change historical blocks, and it becomes exponentially more difficult the further back you go. As above, changing historical blocks only allows you to exclude and change the ordering of transactions. It's impossible to change blocks created before the last checkpoint. Since this attack doesn't permit all that much power over the network, it is expected that no one will attempt it. A profit-seeking person will always gain more by just following the rules, and even someone trying to destroy the system will probably find other attacks more attractive. However, if this attack is successfully executed, it will be difficult or impossible to \"untangle\" the mess created — any changes the attacker makes might become permanent.",
      "In theory, this attacker owns enough computing power that they could execute a \"double spend\" attack. They could spend coins in one place, allow the coins to enter the block chain as normal until the required confirmations are met, then fire up their 51% of the miners to craft a fraudulent fork of the block chain in which those coins were never spent, allowing them to re-spend the coins. This could theoretically be repeated for as long as the attacker maintained control of 51% or more of the hashrate. Realistically, 51% is only the point at which this becomes possible not the point at which it becomes likely or easy . An attacker would probably need something like 65% to actually execute such an attack."
    ]
  },
  {
    "question": "Is it possible to brute force bitcoin address creation in order to steal money?Bitcoin users frequently generate new addresses for each transaction they make, which greatly increases the number of bitcoin addresses being used to receive money. Would it be possible (and profitable) for someone to find collisions in the bitcoin address space in order to steal money?",
    "answers": [
      "It is possible to brute force some Bitcoin addresses, because some people generate their private keys in an insecure manner. Any (non-zero) 32 bytes can be a private key. So running sha256 over a passphrase gives an apparently random, but brute force-able private key. Take sha256(\"sausage\") for instance: $ echo -n 'sausage' | sha256sum 30caae2fcb7c34ecadfddc45e0a27e9103bd7cfc87730d7818cc096b1266a683 - Load up bitaddress and paste that private key into the 'wallet details' tab to get the corresponding Bitcoin address, then look it up on blockexplorer : $ GET http://blockexplorer.com/q/getreceivedbyaddress/1TnnhMEgic5g4ttrCQyDopwqTs4hheuNZ; echo 0.01000000 and you'll see that the address held one bitcent for about 2 days in February 2012. See also: \"fuckyou\", which held 2.5 bitcents for 12 festive days at the turn of last year. So in practice it's possible to brute force bitcoin address creation, but only for poorly chosen passphrases. These were probably just people playing around with the idea of \"storing bitcoins in their head\" which is why they are for such small amounts, and why they weren't left funded for long. No address balances were harmed in the making of this answer.",
      "It may be \"theoretically\" possible, but in reality it's unlikely to be achieved - As in counting the number of atoms in an office building unlikely. Bitcoin addresses are actually the 256-bit SHA hash of an ECDSA public key, so any vulnerabilities in those algorithms would constitute a vulnerability in bitcoin itself. Realistically, however, breaking this level of encryption requires a huge amount of processing power. Coincidentally it requires precisely the same kind of processing power that bitcoin mining requires and in almost every scenario it would be massively more profitable to mine than to hack. Edit: It's actually RIPEMD-160(SHA-256(public key)) as opposed to just SHA-256(public key) as I originally mentioned, so it's a 160-bit hash of a 256-bit hash of a public key. While the target keyspace (160 bits) is smaller thanks to this final step, it's also an additional computation that a would-be hacker must make. While the additional computational complexity doesn't even come close to canceling out the removal of 96 bits of keyspace, it should be noted that finding a collision in a 160-bit keyspace is still incredibly difficult and time consuming. More importantly, it is more difficult and time consuming than actually mining the same number of coins would be, thus making it highly unlikely anyone would even attempt such an attack - even if the equipment to make such an attack plausible in a meaningfully small span of time existed."
    ]
  },
  {
    "question": "How much will transaction fees eventually be?Some people keep evangelizing that Bitcoin transaction fees are much lower than in PayPal or with credit cards. However, once nearly all 21 million bitcoins have been mined, the network will still have to be secured. But \"miners\" can then no longer be rewarded by newly minted bitcoins. They will have to be rewarded by transaction fees. I read that the market will find the equilibrium how much these transaction fees will be. Are there any estimates or more concrete calculations about that? Is it even possible to foresee, as the \"degree of network security\" is a rather nebulous incentive for most (casual) users? Will they thus be enforced by the software? Will these fees better be absolute or relative to the amount of a single transfer?",
    "answers": [
      "I read that the market will find the equilibrium how much these transaction fees will be. It will not. This is perhaps the biggest flaw in Bitcoin at the moment: once mining rewards end there is no direct linkage between the amount of hashpower needed to secure the network and the incentive to mine. True, there is a limit on the blocksize, so if the transaction volume in a block window (approximately 10 minutes) exceeds the block size you can expect a miniature \"auction\" where transactions fight for space in the block by bidding up the minimum transaction fee needed to get in. However this isn't really a closed-loop adjustment: the maximum blocksize is an arbitrarily chosen number, and there's no reason to believe the maximum blocksize is small enough to ensure that transaction fees are high enough to incent enough miners to mine to keep the system secure . Unlike the difficulty and the USD/BTC exchange rate it does not respond to market activity. It also has the negative side effect of capping the worldwide Bitcoin transaction throughput since other parts of the protocol rely on the assumption that blocks are created -- in the long run -- no more than once every ten minutes. Compare this to the current situation with mining rewards: the more valuable a bitcoin is the more incentive there is for somebody to try to overwhelm the \"good guys\" by gaining 50%+1 hashpower. However, the more valuable a bitcoin is the more miners will mine! It isn't perfect, but the important point is that the demand for security increases the incentive to mine . Note that although the difficulty will go up, that simply ensures that the reward granted every ten minutes is an approximately constant number of BTC -- the number of terahashes/sec fighting over that amount of BTC is free to respond to changes in their changing value (as measured in terms of all other goods in the world, including other currencies). As the mining reward is reduced this \"direct coupling\" between the network's need for security and the incentive to mine becomes progressively more diluted. I worry a lot about what will happen to Bitcoin once we decouple those two forces. I think the developers ought to at least come up with a story on how this will be solved so people can start testing it.",
      "There are a lot of unknowns because the network is so young and transaction volume is so low. Currently the block reward is worth about $13.1 million annually. If fees stabilized at 0.1% of transaction volume (compare that to 3%+ for cc/debit/paypal) it would require a transaction volume of ~ $13 billion for fees to someday generate the same global revenue as current block rewards. To put that into perspective, credit & Debit cards have an annual transaction volume of ~ $2.5 trillion. Paypal has ~ $80 billion in transactions per year so this level of transaction volume is certainly possible. The larger issue is that under current protocol rules fees will never stabilize at 0.1% (or any other meaningful percentage) of transaction volume. The reason is that currently there is no disincentive for a miner to exclude any paying transaction unless the block is already full of higher paying transactions. A transaction can become a paying transaction by merely including 1 satoshi with every transaction which even on a 1 BTC transaction is only 0.0000001% not 0.1%. For larger transactions it becomes infinitesimally small. There is no method to create granularity because fees can be arbitrarily small and miners should logically not exclude a paying transaction. The current transaction fee system is simply not viable once block rewards (subsidies) are removed. One way to look at it is the current network costs about $13 million per year to run or roughly $20 per block per TerraHash (TH). That cost is paid via subisides but that isn't a viable long term strategy. Someday it will need to be paid for with fees. If the amount of fees collected are higher than the network will be larger/stronger. If the amount collected is smaller then the network will be smaller/weaker. Remember Moore's law doesn't make the network stronger. As miner's hardware becomes more efficient so does attacker's hardware. The network needs to generate sufficient fees to remain strong not just increase nominal hashing power due to efficiency gains. The current transaction fee system doesn't achieve that goal. It will need to be changed."
    ]
  },
  {
    "question": "How do you obtain bitcoins?This is a question many people ask when they're introduced to Bitcoin. Bitcoin sounds interesting, but if I want to use this system I will need to get some coins, otherwise, there's no way I can spend them! How can I start?",
    "answers": [
      "Exchanges These are platforms that match buyers with sellers. They allow you to deposit fiat currency (like USD, EUR, etc.) and use it to buy Bitcoin. There are both centralized platforms and decentralized exchanges (often referred to as DEXs). Brokerage Services Unlike exchanges, where you're trading with other users, brokerage services sell you Bitcoin directly. This method might be more user-friendly for those new to Bitcoin. Peer-to-Peer (P2P) Platforms Here, you'll buy directly from another person. These platforms may offer escrow services to ensure safety and trustworthiness in transactions. Bitcoin ATMs These physical machines can be found in many cities and allow for the purchase (and sometimes sale) of Bitcoin. The process typically involves inserting cash and receiving Bitcoin in return. Mining In the early days, Bitcoin mining was accessible to many, but it's now more industrialized. If interested, consider the concept of joining a mining pool. Accept Bitcoin Offering goods or services in exchange for Bitcoin is a direct way to acquire it. As the ecosystem grows, more merchants are accepting Bitcoin. Earning Platforms There are platforms and websites where you can earn Bitcoin as rewards for tasks, shopping, or other services. Always research any platform you consider. Lending or Staking If you already own Bitcoin, there are mechanisms to earn more by lending or staking your holdings, depending on the platform's offerings. Final Thoughts Always do your research and prioritize security. The world of cryptocurrency is dynamic, so staying updated and cautious is key. I've updated this answer from my original to remove links to specific platforms. I don't want to recommend specific platforms that may not be the best option for you, or even exist in the future. However, you may find these resources helpful: Bitcoin.org - The official Bitcoin website often has information about exchanges and other services. The Bitcoin Wiki - This is a community-run resource that has a lot of information about Bitcoin, including exchanges and other services.",
      "Basically there are five main ways of getting bitcoins: Mining Buying Offering goods and services for Bitcoin Obtaining for free through micro payment Asking a friend who already has them to give a tiny fraction for free Let's start with mining: first of all I have to warn that currently there is almost impossible to mine by your own. You need to have a dedicated hardware (you can see hashrate comparison here) which is really costly. Even with this dedicated software it is really a small chance (current total hashrate is > 850 Thash/s) that you will create a block. So most probably you have to mine as a part of the pool . There are quite a lot of mining pools available, but mostly you would like to join some big pool to have a high percentage of guaranteed small payoff. Pools hashrate distribution you can find here . I by myself have tried to mine on two different mining pools : BTC Guild and bitMinter . Just my own opinion, that it is easier to start with bitminter, because they provide you with easy to use software for mining and detailed instruction. One last word of warning: most probably if you will start mining right now with your GPU, you will spend more money on electricity than you will gain from mining. But if you are going to do this just for curiosity, it might give you some micro part of a bitcoin. The second option is to buy bitcoins As with mining, you have plenty of options as well. The only problem is that right now you are dealing with your own real money. So you have to be careful what to select. At some period of time there were a lot of fake bitcoins selling sites, so if I were you, I would rather go with bullet proof places: coinbase.com changelly.com It is also possible to find local trading partners through services such as localbitcoins.com or at Bitcoin meetups. Offering goods and services for Bitcoin If you already have a shop or are planning to start selling something in the near future, it is pretty easy to accept Bitcoin as payment, in fact easier than to accept Credit Cards for example. If you are worried about Bitcoin's volatility, there are different payment processors, which will convert your Bitcoin payments into your national fiat currency for a fee, usually lower than Credit Card Companies. – You can opt to keep a percentage in Bitcoin. Obtaining for free through micro payment Not surprisingly, but there is a lot of web-sites, where you can get bitcoins for free. Do not be overexcited by this - you can not make a fortune out of this :-). Most probably they will give you 0.000001 bitcoin for free. On most of such websites you have to watch some stuff or to other useless things. So you are exchanging your time for micro payment. In my own question on bitcoin beta, there is a list of many of such places . If you know any other place - feel free to add it. And the last thing is to ask a friend. Try to ask your high tech friend. There is a high chance that he already knows about bitcoin and may be have a couple of coins. He might give you a small micropayment just to try. But do not try to abuse this: there is no point of asking people in places like this to give you 0.00001 bitcoin."
    ]
  },
  {
    "question": "Why is 6 the number of confirms that is considered secure?Why is 6 is the number of confirmations that is considered secure? I haven't found any mathematical explanation or otherwise that explains why it is 6 and not 5 or 7. Is there a historical reason for 6? Is there a specific way to calculate it so 6 is just a number that was chosen?",
    "answers": [
      "I believe this is addressed in page 8 of Satoshi's Bitcoin paper when showing the probability of an attacker catching up. The wiki states: \"Only 6 blocks or 1 hour is enough to make reversal computationally impractical.\" The key word is \"impractical\". The important sentence in Satoshi's paper is: \"Assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution \". So, it is not that someone couldn't create the worlds first and own a $50 million ASIC farm, so as to have the ability to overtake the blockchain from a fork six blocks prior but that doing so would be a.) a massive undertaking, b.) obvious to all and c.) terrifically unprofitable to the attacker.",
      "Many people misquote Satoshi paper and assume 6 is some hard value. Satoshi's paper outlines the number of confirmations necessary to be 99.9% sure (less than 1 in 1000 chance of success) that an attacker couldn't build a longer chain to reverse the transaction. http://bitcoin.org/bitcoin.pdf P < 0.001 q=0.10 z=5 q=0.15 z=8 q=0.20 z=11 q=0.25 z=15 q=0.30 z=24 q=0.35 z=41 q=0.40 z=89 q=0.45 z=340 p is the chance of attacker eventually getting longer chain and reversing a transaction (0.1% in this case). q is the % of the hashing power the attacker controls. z is the number of blocks to put the risk of a reversal below p (0.1%). So you can see if the attacker has a small % of the hashing power 6 blocks is sufficient. Remember 10% of the network at the time of writing is ~100GH/s. However if the attacker had greater % of hashing power it would take increasingly longer to be sure a transaction can't be reversed. If the attacker had significantly more hashpower say 25% of the network it would require 15 confirmation to be sure (99.9% probability) that an attacker can't reverse it. If the attacker has q of >50% (\"the 51% attack\") then given unlimited time the attacker will inevitably end up with the longest chain. On edit: to clarify the \"unlimited time\" the chain with the higher hashrate will inevitably end up the longest however probability still comes into play. We can not say with 100% certainty how long it will take at best we can provide a confidence interval. If the attacker is just barely faster than the good miners (51% vs 49%) then it can take a very long time for an attacker to overcome a deficit of 6 blocks. The more the attacker dominates (i.e. 70% vs 30%) the quicker the shorter the 95% confidence interval is reached."
    ]
  },
  {
    "question": "How much Bitcoin will I mine right now with hardware X?Say I have a given piece of hardware (CPU/GPU). Where can I find out how much Bitcoin will I mine per day?",
    "answers": [
      "Go to http://bitminter.com/test and click the \"test start\" button. If you have Java installed the miner should launch. Click \"engine start\" on your GPU(s) to start mining and the GUI will show how many bitcoins per day you will make (on average). Note that you are actively mining in a pool without getting paid. This test page launches a version of the miner which is only meant to be used for a short time for testing. Update for 2015 : CPU and GPU mining are both long dead. When you buy ASIC mining hardware you will know its hashrate before you buy. Don't buy if you don't. Google \"bitcoin mining calculator\", input your hashrate, and it will tell you how much you can earn right now, on average. Note that the difficulty will change in the future so your earnings will not stay the same. Also note that with most pools actual earnings vary with luck. Finally, avoid the typical newbie mistake of confusing TH/s and GH/s. 1 TH/s = 1000 GH/s.",
      "There is a list here that is kept relatively up to date with the possible hashrate of various CPUs and GPUs https://en.bitcoin.it/wiki/Mining_hardware_comparison Once you know the number of hashes you can generate, you can use an online mining calculator and calculate the numbers of bitcoins you can mine per day (on average) and the current price of those bitcoins in other currencies. http://tpbitcalc.appspot.com/ It is worth pointing out that when most people talk about \"mining\" bitcoins these days, they are talking about pooled mining. Depending on the fees of your pool you can make anywhere from 2%-10% less than expected. If you mine by yourself, the bitcoin you are expected to make has a high degree of variance. https://en.bitcoin.it/wiki/Pooled_mining"
    ]
  },
  {
    "question": "Is there a way to set up proof-of-work systems so they would be even more useful?One of the arguments made against Bitcoin's design choices is that it wastes resources authenticating transactions. In particular, finding small hashes is completely useless for the world. Are there approaches (or other crypto-currencies) that use proof-of-work by working on some useful difficult problem? There are plenty of projects like SETI@home or Folding@home that distribute difficult but potentially useful calculations among different users, is there a way to use such useful calculations for building a proof-of-work system in a crypto-currency, or is there a fundamental reason (economic or computational) that a proof-of-work must involve useless work?",
    "answers": [
      "I think the premise of the question is not correct. The work is not useless, it secures the transactions. The public hash chain ensures that Bitcoins can only be spent once. The mechanism piles computations on top of legitimate transactions so that the recipient knows that an attacker would need at least as much computing ability to \"undo\" the transaction. There is currently no known way to make the work more useful. The problem is that the primary purpose of securing transactions imposes a number of requirements on the work done: The work must be much, much easier to verify than to do. So it pretty much has to consist of searching for something rare, doing billions of searches to test if an input has a particular characteristic. That way the verification simply requires confirming that the input you found has that characteristic. The work must in fact secure the transactions and not be severable from them. If I see that you sent me 10 Bitcoins and then billions of computations are piled on top of that, it must not be possible to remove that transaction and then pile those same computations on top of a conflicting transaction. So you can't use the result of an arbitrary chunk of work to prove work on the Bitcoin chain. It's hard to imagine any additional useful work that could be accomplished while still meeting these requirements.",
      "Primecoin is the first: A new type of proof-of-work based on searching for prime numbers is introduced in peer-to-peer cryptocurrency designs. Three types of prime chains known as Cunningham chain of first kind, Cunningham chain of second kind and bi-twin chain are qualified as proof-of-work. Prime chain is linked to block hash to preserve the security property of Nakamoto’s Bitcoin, while a continuous difficulty evaluation scheme is designed to allow prime chain to act as adjustable-difficulty proof-of-work in a Bitcoin like cryptocurrency. Check http://ppcoin.org/primecoin One can question the use of knowing Cunningham chains of primes but it's arguably more useful than finding hashes with sequences of zeroes. And often with math the practical use is only found later. (There's even prize money involved: \"$250,000 to the first individual or group who discovers a prime number with at least 1,000,000,000 decimal digits\", from the EFF, no less, https://www.eff.org/awards/coop ) Here's an in-depth article about this question: Ask Ars: Why spend time and money finding new prime numbers? Most of all, now that there's one mathematically useful coin more will probably follow. Curecoin is another very interesting approach, with merged mining. 45% of new coins for SHA miners, for blockchain security, 45% for protein folding GPU/CPU power. 10% goes to development."
    ]
  },
  {
    "question": "How does merged mining work?How does the implementation of merged mining affect the global hash rate of alt chains? Does one solution fit all? Does one solution fit some? Does the rate of \"solutions that will fit\" decrease the more forks that it is tested against? An explanation of how merged mining actually works would be excellent.",
    "answers": [
      "Merged mining allows a miner to mine for more than one block chain at the same time. The benefit is that every hash the miner does contributes to the total hash rate of both (all) currencies, and as a result they are all more secure. Starting with a high-level explanation: The miner (or mining controller in the case of pooled mining) actually builds a block for both hash chains in such a way that the same hash calculation secures both blocks. Work units based on this block are then assigned to miners. If a miner solves a block (at the difficulty level of either or both block chains) the block is re-assembled with the completed proof of work and submitted to the correct block chain (or both blocks are separately reassembled and each submitted to the corresponding network if it met both of their difficulty requirements). The only confusing detail is how the same hash can secure both block chains. I'll use the example of Bitcoin and Namecoin, where Namecoin supports merged mining and Bitcoin doesn't: First, the miner must assemble a transaction set for both block chains. He then assembles the final Namecoin block and hashes it. He then creates a transaction containing this hash that is valid in the Bitcoin chain and inserts it in the Bitcoin transaction set at the tip of the tree. He then assembles the final Bitcoin header with this transaction in it and sends out the work units. If a miner solves the hash at the Bitcoin difficulty level, the Bitcoin block is assembled and sent to the Bitcoin network. The Namecoin hash does nothing and the Bitcoin network ignores it. If a miner solves the hash at the Namecoin difficulty level, the Namecoin block is assembled. It includes the Namecoin transaction set, the Namecoin block header, the Bitcoin block header, and the hash of the rest of the transactions in the Bitcoin block. This entire \"mess\" is then submitted to the Namecoin system. The Namecoin system, supporting merged mining, accepts this as proof of work because it contains work that must have been done after the block header and Namecoin transaction set was built. (Because you can't build the Bitcoin transaction set containing that hash, and therefore the Bitcoin header that secures it, without that information. So it proves the work was done.) Note that a miner can solve both chains simultaneously, and they will if they solve at the higher difficulty. One block can \"win\" in the public chain and not the other. They are fully independent -- only the mining is merged. Three key points to remember: The Bitcoin chain doesn't get junked up with Namecoin stuff due to merged mining. At most, one tiny hash is inserted in the transaction tree. The two hash chains remain fully independent. The \"Bitcoin stuff\" that goes in the Namecoin tree is basically ignored and only used to validate the proof of work. (It will bloat the Namecoin chain a bit as it means some blocks will have an extra header and an extra hash.) Lastly, no special support is needed from Bitcoin. The benefit for Namecoin is obvious. A lot of Bitcoin miners will probably do merged mining, since it costs them basically nothing and gives them a greater return than mining Bitcoins alone. As a result, their block generation timing will be more predictable and their transactions more secure against a 51% attack.",
      "Basically the idea is that you assemble a Namecoin block and hash it, and then insert that hash into a Bitcoin block. Now when you solve the Bitcoin block at a difficulty level greater to or equal to the Namecoin difficulty level, it will be proof that that amount of work has been done for the Namecoin block. The Namecoin protocol has been altered to accept a Bitcoin block (solved at or above the Namecoin difficulty level) containing a hash of a Namecoin block as proof of work for the Namecoin block. The Bitcoin block will only be acceptable to the Bitcoin network if it is at the difficulty of the Bitcoin network. The Bitcoin block chain gets a single extra hash when a merged mining block is accepted, and the Namecoin block chain gets a little bit more (because it includes the Bitcoin block) when a merged mining block is accepted. However, because of the Merkle Tree, the entire Bitcoin block doesn’t need to be included in the Namecoin tree, just the top level hashes (so the extra bloat to the Namecoin chain is not a big problem). Since you make more money mining both Namecoins and Bitcoins miners will eventually all do merged mining, and the difficulty level for all block chains will eventually be the same. Furthermore, the economic incentive to mine will be the combined economic incentive of all networks, making all networks more secure. Of course this allows competing networks (with different inflation rates) to quickly become secure. This subjects Bitcoin to more competition. Ultimately the value of Bitcoin is a reflection of the need for Bitcoins to make exchanges. The more people using Bitcoin to make purchases, the more demand there is for Bitcoins, and the higher the price of Bitcoins goes. (Speculation also raises the price, but long term speculation is essentially a bet that the transactional demand for Bitcoin will increase in the future.) The higher the price, the higher the incentive to mine. At any given time there is a certain amount of demand for a Bitcoin like currency to make transactions. That need doesn’t increase with more competition. That means that the transactional demand for Bitcoin is really the same as the transactional demand for all substantially similar forms of payment. As more currencies are competing to fill the same demand they actually reduce the demand for the other currencies as they become more widely used. This means that ultimately, to the extent that currencies are interchangeable to end users, merged mining does not increase the overall security of the networks. The demand for currencies drives the price (and thus the value of the reward). Increased demand for any given currency results in decreased demand for others, lowering the incentive to mine for the other currencies. The total incentive is a function of total demand for all Bitcoin like currencies. Except now competing currencies can market themselves as “as secure as Bitcoin but with lower transaction fees.” In other words there is a race to the bottom among competing currencies to offer the lowest transaction fees, because lowering the transaction fee doesn’t hurt the security of the network in comparison to the other merged mining networks. Users, following their own self interest, will adopt the currency with the lowest transaction fees as long as it has the same security of the competitors. This will increase the price of the currency with the lowest transaction fee (because demand for the currency is higher), and decrease the price of the currencies with higher transactions fees (because demand for those currencies is dropping as it is being filled by demand for the competing currency). Because the currencies with the higher transaction fees were the ones generating the incentive to mine, overall incentive to mine will diminish. As long as a currency’s mining is merged with the freeloading currency, it will be powerless to increase incentives by imposing mandatory transaction fees. The result will be a decrease in mining incentive, a decrease in mining, and ultimately all networks that allow merged mining will become insecure."
    ]
  },
  {
    "question": "Why was 21 million picked as the number of bitcoins to be created?Why did Satoshi pick 21 million as the number of bitcoins to be created? What is the significance of that number?",
    "answers": [
      "Here's a mathematical explanation: Calculate the number of blocks per 4 year cycle: 6 blocks per hour * 24 hours per day * 365 days per year * 4 years per cycle = 210,240 ~= 210,000 Sum all the block reward sizes: 50 + 25 + 12.5 + 6.25 + 3.125 + ... = 100 Multiply the two: 210,000 * 100 = 21 million. Economically, because the currency is effectively infinitely divisible, then the precise amount doesn't matter, as long as the limit remains fixed.",
      "Wikipedia (Gold) : A total of 174,100 tonnes of gold have been mined in human history, according to GFMS as of 2012. This is roughly equivalent to 5.6 billion troy ounces or, in terms of volume, about 9261 m3, or a cube 21.0 m on a side. Bitcoin is often compared to gold, the total number of bitcoins matches the total amount of gold mined in human history which can be imagined as a cube 21 m on a side. As it is not entirely so important how many Bitcoins will exactly be mined. Satoshi could have easily chosen almost any number. He could just adjust block reward halving (210 000 blocks), reward sizes (50, 25, 12.5 ...), etc. to match some particular number. Gold is considered a standard for currency and was used as such for thousands of years until recently it was abandoned in 1971 . And that could be the reason why Satoshi maybe wanted Bitcoin to resemble gold at least in this unimportant property. EDIT Satoshi Nakamoto himself compared Bitcoin to gold. Satoshi Nakamoto @ bitcointalk.org: As a thought experiment, imagine there was a base metal as scarce as gold but with the following properties: boring grey in colour not a good conductor of electricity not particularly strong, but not ductile or easily malleable either not useful for any practical or ornamental purpose and one special, magical property: can be transported over a communications channel"
    ]
  },
  {
    "question": "How can I buy Bitcoin via a Credit Card or Paypal?I want to buy some bitcoins. Ideally, I would like to buy them on the MtGox exchange (because the consensus seems to be that this is the most reputable exchange), however I have found the system for transferring USD to MtGox to be very disappointing. I would have liked to be able to add funds with PayPal or directly with a credit card, however both of these are not possible. My question has two parts: Is there an easy way to use a credit card to add USD funds to my MtGox account. Liberty Reserve, Dwolla, and Paxum seem to be the financial institutions of choice for MtGox and the rest of the exchanges. Is any of these simple to fund using a credit card, or are they all basically PayPal analogues (which Paxum seems to be) that require a large amount of setup? If it is not possible for MtGox, is there another, hopefully reputable, exchange that I can use PayPal or a Credit Card to buy bitcoins with?",
    "answers": [
      "I noticed this question was posted a long time ago and perhaps things have changed so I took the liberty to dig in again and also aggregate most of the answers given here and here’s what I found: It’s indeed impossible to buy Bitcoins with Paypal DIRECTLY even today and it's mainly because of Paypal’s TOS (Section 3.7 here ) and the issues of chargeback. Having said that there are still a few ways you can buy Bitcoin with Paypal a. Use VirWox to buy SLL with Paypal and then transfer that SLL to BTC (has high comission, transaction can take between 1 hour to 2 days). The full process is explained here . b. You can use Local Bitcoins and perhaps find someone in your area to sell you Bitcoins with cash or even someone not in your area to sell you Bitcoins with Paypal or a credit card. c. If you’re only into trading Bitcoins for their volitility and not actaully keep them you can use platforms such as AvaTrade or Plus500 to trade CFDs. However CFDs are for more experience traders and your capital is at risk so take that into account. d. If you have a Paypal Debit card you can actually connect it to your Circle account and use the funds on your card to get BTC. This is relevant to US residents only. Same thing goes for credit cards. Because of chargeback issues there’s no direct way to buy Bitcoins with them. Currently some options for credit cards are CoinMama , Circle or Cubits .",
      "I did some more digging on bitcoin.it and answered my own question. According to the FAQ and the list of payment methods , the reason that Paypal and Credit Cards are not accepted is to prevent fraud (by doing a fraudulent charge-back). For this reason, none of the exchanges accept these as forms of payment. In short, you cannot (directly) use these to buy bitcoins at exchanges. Edit: I did have some luck buying some Bitcoins using Paypal using #bitcoin-otc . It takes a bit of setup and it's a bit more expensive, and you can't buy in significant quantities but it's possible you can find someone willing to sell to unrated users (liked I did)."
    ]
  },
  {
    "question": "Does hoarding really hurt Bitcoin?Some people believe that hoarding hurts the Bitcoin economy . But are they really right? As long as corresponding goods vendors and services will be here to stay and reinforce people's faith in Bitcoin, hoarded bitcoins simply do not take part in daily business and do not hurt anyone. Quite the contrary, they will decrease the supply of bitcoins in active circulation, thus increase the demand for bitcoins, and thus raise their over-all value, right? Update: This question also comes with a premise or insight that Bitcoin \"power users\" have savings and spendings wallets or similar setups, and that those two forms of wallets will not tend to \"compete\" with each other so much. The bitcoins in the spendings wallets will rather compete with the fiat money that respective users will use to buy for goods and services. The bitcoins in the savings wallets will rather compete with more traditional forms of assets and investments.",
    "answers": [
      "TL;DR : No. The argument is basically that hoarding will make Bitcoins so valuable that nobody will be willing to offer people enough to part with them. Does that pass the giggle test? Another way of stating the argument is this, \"If gold is $2,000/oz today but people think it will be $5,000/oz next year, nobody will trade any gold today.\" Again, think about it. Does that pass the giggle test either? Hoarding increases the value of Bitcoins, increasing the profits from mining. This encourages more people to mine, increasing the total hashing power and thus the security of the system. It also makes holding Bitcoins more profitable. This helps to encourage people to accept them in trade because they are less worried about them decreasing in value while they are holding them. Using Bitcoins as a currency inevitably means people sometimes have to hold them and having them drop in value while you hold them is a risk. Hoarding reduces this risk. But it also makes it harder to price things in Bitcoins because the value will tend to change more. Merchants don't like to change their prices twice a day. Contrary to claims, it should not affect the trading volume or the willingness of people to use Bitcoins to pay for things. The argument that increasing value means people would prefer to hold Bitcoins rather than spend them is specious. While it will make people want to have Bitcoins more, it will also make people want to convince others to give them Bitcoins more so they can have them. Think about it, do people prefer to pay for goods in dollars or garbage? By the reasoning of this argument, they should prefer to pay for goods in garbage, since they'd rather hold their dollars and get rid of their garbage. But, of course, people don't like paying in garbage because nobody wants garbage. If you can pay with the currency others want, you can get a better deal. So you actually prefer to spend the currencies sellers most want . If Bitcoins are valuable because inflation doesn't deprive them of value, then a merchant would rather get my Bitcoins than my dollars, so he'll accept fewer of them. This will cancel out the effect of me preferring to pay in dollars rather than Bitcoins. So it should be a wash. Or, put another way, whatever the present and future prospects, there should always be some equivalence between dollars and Bitcoins that people roughly agree on. So whether I pay X dollars or Y bitcoins, where X and Y are in this ratio, will purely depend on whether I prefer the characteristics of dollars or Bitcoins for the transaction. A consequence of this is that hoarding won't negatively affect the trading volume either because that's only dependent on people's use of Bitcoins to buy and sell things. If hoarding makes Bitcoins worth twice as much, only half as many will be used to buy and sell things and the volume (the total value traded) will be the same. I don't believe it's lost opportunity either. It's not like people who want to trade Bitcoins can't get them because they're all being hoarded. (Nor will it ever be likely to be an issue, since that would just raise the price and thus fewer would be needed. Bitcoins have effectively unlimited divisibility.) So why do so many people think currency hoarding is bad? Because it usually is, and empiric studies even show that it is. But the logic of why currency hoarding is bad doesn't apply to Bitcoins, especially when it's a minority currency. Bitcoins are different enough from physical fiat currencies that empirical studies don't apply unless the suspected mechanisms for the observed effects are believed to apply to Bitcoins too. For example, if a penny were enough money to buy a car, how useful would dollars be?",
      "Bitcoin is really a little strange because it doesn't know if it is a currency or a commodity. And this is why this question has many answers and is a popular item of discussion. If Bitcoin were just a commodity, the thing to do is to hoard it. There are lots of commodities that are almost totally hoarded. For example: emeralds or works of art. Now if Bitcoin is just a currency, then hoarding is a problem. Economists, when they talk about money supply, also talk about the velocity of money, which is a measure of hoarding. The amount of money times how fast it is moving is a measure of total money being used. (Of course, with computers, money moves faster now than it ever has.) So to answer your question, hoarding helps somewhat and hurts somewhat. Which one overpowers the other, nobody can say. The net effect will be shown to us all over time."
    ]
  },
  {
    "question": "Why don't people buy at one exchange and sell at another?Bitcoinity.org shows that for the past 30 days, bitstamp's price is high at 101.00, low at 77.00, and current price is 98.04 . On contrast, mtgox's price for the past 30 days is high at 115.00, low at 86.20, and current price is 110.50 . In other words, someone or anyone can just buy from bitstamp and sell to mtgox to make profit. What's stopping people from doing so? What's the catch? It can't be that people aren't aware that they could do it right?",
    "answers": [
      "Many people already do this with bitcoin. In finance, this is called arbitrage trading, or simply arbitrage, sometimes even abbreviated arb. The reason for the price differences are fees for transferring between the bitcoin exchanges (you have to transfer both, bitcoins and fiat currency for a complete cycle) and fees for trading bitcoins against fiat currencies. Because of the arbitrage traders, who make profits as long as the price difference is big enough, the prices on different exchanges quickly adjust to be right at the border between where the fees eat up the earning and where you make profits. There is an excellent page, http://bitcoin-analytics.com , which can tell you where there currently are arbitrage oppurtunities. Simply go to the website and click on \"Arbitrage\".",
      "I've writen software to arbitrage on some US exchanges. I couldn't arbitrage without software because: It was hard to account for all fees to understand if an opportunity is profitable. It took a couple of minutes to evaluate opportunities (query an exchange's order book, query another exchange's order book, do an evaluation, execute a sell, execute a buy) and by that point the evaluation may be invalid. Here are the factors that make it hard for me to arbitrage with software: Small (fractions of a percent) profit margins. As pointed out earlier everyone in the loop is taking fees. Small (seconds to minutes) profitable time windows Slow (2-8 days) cycle times to move USD back into position for sale Large Capital requirements - since the margins are so small for arbitrage to be worth it on an annual basis takes a lot of assets. For example I might make a few cents or dollars on a $1K sale and purchase of Bitcoin. Risk - with large capital requirements comes risk of loss. What if a trade becomes unprofitable before the arbitrage completes? What if Bitcoin tanks? I am interested in non-US exchanges since the spreads are bigger but I expect it will increase some of the issues above, especially fiat cycle time since my base is USD"
    ]
  },
  {
    "question": "How to redeem a basic Tx?Given a raw, standard Tx ( wiki ): 01000000 01 26c07ece0bce7cda0ccd14d99e205f118cde27e83dd75da7b141fe487b5528fb 00000000 8b 48304502202b7e37831273d74c8b5b1956c23e79acd660635a8d1063d413c50b218eb6bc8a022100a10a3a7b5aaa0f07827207daf81f718f51eeac96695cf1ef9f2020f21a0de02f01410452684bce6797a0a50d028e9632be0c2a7e5031b710972c2a3285520fb29fcd4ecfb5fc2bf86a1e7578e4f8a305eeb341d1c6fc0173e5837e2d3c7b178aade078 ffffffff 02 b06c191e01000000 19 76a9143564a74f9ddb4372301c49154605573d7d1a88fe88ac 00e1f50500000000 19 76a914010966776006953d5567439e5e39f86a0d273bee88ac 00000000 and a private key: 18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725 How does one construct a new transaction to redeem the coin from the second output? I've been trying to figure this out for a long while using etotheipi's diagram , but can't seem to grasp how a proper transaction is to be created. A step-by-step guide would be welcome.",
    "answers": [
      "In this answer, I will go through the steps necessary to redeem the second output of the transaction listed above. The answer will be limited to redeeming an output of the particular type present in this transaction (an output which requires providing a new transaction signed with a private key whose corresponding public key hashes to the hash in the script of the output in question), as this answer is already fairly long, even without taking into account other output types. Short summary: We begin by constructing a new transaction, with a scriptSig containing the scriptPubKey of the output we want to redeem. The scriptPubKey of this transaction will contain a script that pays to a hash of a public key (Bitcoin address). We perform a double-SHA256 hash on this transaction with the four-byte hash code type SIGHASH_ALL appended to the end. We sign this hash with the private key supplied above. The scriptSig of this new transaction is then replaced with a script that first pushes the DER-encoded signature, plus the one-byte hash code type SIGHASH_ALL, to the stack, followed by the DER-encoded private key's corresponding public key. Step-by-step description: We start creating a new raw transaction which we hash and sign. Add four-byte version field: 01000000 One-byte varint specifying the number of inputs: 01 32-byte hash of the transaction from which we want to redeem an output: eccf7e3034189b851985d871f91384b8ee357cd47c3024736e5676eb2debb3f2 Four-byte field denoting the output index we want to redeem from the transaction with the above hash (output number 2 = output index 1): 01000000 Now comes the scriptSig. For the purpose of signing the transaction, this is temporarily filled with the scriptPubKey of the output we want to redeem. First we write a one-byte varint which denotes the length of the scriptSig (0x19 = 25 bytes): 19 Then we write the temporary scriptSig which, again, is the scriptPubKey of the output we want to redeem: 76a914010966776006953d5567439e5e39f86a0d273bee88ac Then we write a four-byte field denoting the sequence. This is currently always set to 0xffffffff: ffffffff Next comes a one-byte varint containing the number of outputs in our new transaction. We will set this to 1 in this example: 01 We then write an 8-byte field (64 bit integer) containing the amount we want to redeem from the specified output. I will set this to the total amount available in the output minus a fee of 0.001 BTC (0.999 BTC, or 99900000 Satoshis): 605af40500000000 Then we start writing our transaction's output. We start with a one-byte varint denoting the length of the output script (0x19 or 25 bytes): 19 Then the actual output script: 76a914097072524438d003d23a2f23edb65aae1bb3e46988ac Then we write the four-byte \"lock time\" field: 00000000 And at last, we write a four-byte \"hash code type\" (1 in our case): 01000000 We now have the following raw transaction data: 01000000 01 eccf7e3034189b851985d871f91384b8ee357cd47c3024736e5676eb2debb3f2 01000000 19 76a914010966776006953d5567439e5e39f86a0d273bee88ac ffffffff 01 605af40500000000 19 76a914097072524438d003d23a2f23edb65aae1bb3e46988ac 00000000 01000000 (signing stage) Now we double-SHA256 hash this entire structure, which yields the hash 9302bda273a887cb40c13e02a50b4071a31fd3aae3ae04021b0b843dd61ad18e We then create a public/private key pair out of the provided private key. We sign the hash from step 14 with the private key, which yields the following DER-encoded signature (this signature will be different in your case): 30460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc06 To this signature we append the one-byte hash code type: 01 . The public key is: 0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6 We construct the final scriptSig by concatenating: One-byte script OPCODE containing the length of the DER-encoded signature plus 1 (the length of the one-byte hash code type) The actual DER-encoded signature plus the one-byte hash code type One-byte script OPCODE containing the length of the public key The actual public key We then replace the one-byte, varint length-field from step 5 with the length of the data from step 16. The length is 140 bytes, or 0x8C bytes: 8c And we replace the temporary scriptSig from Step 6 with the data structure constructed in step 16. This becomes: 4930460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc0601410450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6 We finish off by removing the four-byte hash code type we added in step 13, and we end up with the following stream of bytes, which is the final transaction: 01000000 01 eccf7e3034189b851985d871f91384b8ee357cd47c3024736e5676eb2debb3f2 01000000 8c 4930460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc0601410450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6 ffffffff 01 605af40500000000 19 76a914097072524438d003d23a2f23edb65aae1bb3e46988ac 00000000 Python example code: I have created an example Python script which does all the above. It is intentionally as verbose as possible, and heavily commented, with as few functions as possible, in order to resemble the step-by-step guide above. The number of code lines can easily be reduced to one half, but I choose to post it in this verbose format as I judge that it's the easiest to follow (ie. no 'jumping' backwards and forwards through functions). The script contains 76 non-empty, non-comment lines. The script depends on bitcointools (for serializing and deserializing transactions, and base58 encoding/decoding) and ecdsa_ssl.py from my fork of joric's brutus repository (for constructing public/private EC key pairs and ECDSA signing). The easiest way to get the script to run is to clone bitcointools into a folder, and put ecdsa_ssl.py from the above URL in the same folder along with this script, and executing the script from there. You will want to replace the address in the SEND_TO_ADDRESS variable in this script with the address you want the coins sent to, unless you're feeling generous :). #bitcointools from deserialize import parse_Transaction, opcodes from BCDataStream import BCDataStream from base58 import bc_address_to_hash_160, b58decode, public_key_to_bc_address, hash_160_to_bc_address import ecdsa_ssl import Crypto.Hash.SHA256 as sha256 import Crypto.Random #transaction, from which we want to redeem an output HEX_TRANSACTION=\"010000000126c07ece0bce7cda0ccd14d99e205f118cde27e83dd75da7b141fe487b5528fb000000008b48304502202b7e37831273d74c8b5b1956c23e79acd660635a8d1063d413c50b218eb6bc8a022100a10a3a7b5aaa0f07827207daf81f718f51eeac96695cf1ef9f2020f21a0de02f01410452684bce6797a0a50d028e9632be0c2a7e5031b710972c2a3285520fb29fcd4ecfb5fc2bf86a1e7578e4f8a305eeb341d1c6fc0173e5837e2d3c7b178aade078ffffffff02b06c191e010000001976a9143564a74f9ddb4372301c49154605573d7d1a88fe88ac00e1f505000000001976a914010966776006953d5567439e5e39f86a0d273bee88ac00000000\" #output to redeem. must exist in HEX_TRANSACTION OUTPUT_INDEX=1 #address we want to send the redeemed coins to. #REPLACE WITH YOUR OWN ADDRESS, unless you're feeling generous SEND_TO_ADDRESS=\"1L4xtXCdJNiYnyqE6UsB8KSJvqEuXjz6aK\" #fee we want to pay (in BTC) TX_FEE=0.001 #constant that defines the number of Satoshis per BTC COIN=100000000 #constant used to determine which part of the transaction is hashed. SIGHASH_ALL=1 #private key whose public key hashes to the hash contained in scriptPubKey of output number *OUTPUT_INDEX* in the transaction described in HEX_TRANSACTION PRIVATE_KEY=0x18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725 def dsha256(data): return sha256.new(sha256.new(data).digest()).digest() tx_data=HEX_TRANSACTION.decode('hex_codec') tx_hash=dsha256(tx_data) #here we use bitcointools to parse a transaction. this gives easy access to the various fields of the transaction from which we want to redeem an output stream = BCDataStream() stream.write(tx_data) tx_info = parse_Transaction(stream) if len(tx_info['txOut']) < (OUTPUT_INDEX+1): raise RuntimeError, \"there are only %d output(s) in the transaction you're trying to redeem from. you want to redeem output index %d\" % (len(tx_info['txOut']), OUTPUT_INDEX) #this dictionary is used to store the values of the various transaction fields # this is useful because we need to construct one transaction to hash and sign # and another that will be the final transaction tx_fields = {} ##here we start creating the transaction that we hash and sign sign_tx = BCDataStream() ##first we write the version number, which is 1 tx_fields['version'] = 1 sign_tx.write_int32(tx_fields['version']) ##then we write the number of transaction inputs, which is one tx_fields['num_txin'] = 1 sign_tx.write_compact_size(tx_fields['num_txin']) ##then we write the actual transaction data #'prevout_hash' tx_fields['prevout_hash'] = tx_hash sign_tx.write(tx_fields['prevout_hash']) #hash of the the transaction from which we want to redeem an output #'prevout_n' tx_fields['output_index'] = OUTPUT_INDEX sign_tx.write_uint32(tx_fields['output_index']) #which output of the transaction with tx id 'prevout_hash' do we want to redeem? ##next comes the part of the transaction input. here we place the script of the *output* that we want to redeem tx_fields['scriptSigHash'] = tx_info['txOut'][OUTPUT_INDEX]['scriptPubKey'] #first write the size sign_tx.write_compact_size(len(tx_fields['scriptSigHash'])) #then the data sign_tx.write(tx_fields['scriptSigHash']) #'sequence' tx_fields['sequence'] = 0xffffffff sign_tx.write_uint32(tx_fields['sequence']) ##then we write the number of transaction outputs. we'll just use a single output in this example tx_fields['num_txout'] = 1 sign_tx.write_compact_size(tx_fields['num_txout']) ##then we write the actual transaction output data #we'll redeem everything from the original output minus TX_FEE tx_fields['value'] = tx_info['txOut'][OUTPUT_INDEX]['value']-(TX_FEE*COIN) sign_tx.write_int64(tx_fields['value']) ##this is where our scriptPubKey goes (a script that pays out to an address) #we want the following script: #\"OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG\" address_hash = bc_address_to_hash_160(SEND_TO_ADDRESS) #chr(20) is the length of the address_hash (20 bytes or 160 bits) scriptPubKey = chr(opcodes.OP_DUP) + chr(opcodes.OP_HASH160) + \\ chr(20) + address_hash + chr(opcodes.OP_EQUALVERIFY) + chr(opcodes.OP_CHECKSIG) #first write the length of this lump of data tx_fields['scriptPubKey'] = scriptPubKey sign_tx.write_compact_size(len(tx_fields['scriptPubKey'])) #then the data sign_tx.write(tx_fields['scriptPubKey']) #write locktime (0) tx_fields['locktime'] = 0 sign_tx.write_uint32(tx_fields['locktime']) #and hash code type (1) tx_fields['hash_type'] = SIGHASH_ALL sign_tx.write_int32(tx_fields['hash_type']) #then we obtain the hash of the signature-less transaction (the hash that we sign using our private key) hash_scriptless = dsha256(sign_tx.input) ##now we begin with the ECDSA stuff. ## we create a private key from the provided private key data, and sign hash_scriptless with it ## we also check that the private key's corresponding public key can actually redeem the specified output k = ecdsa_ssl.KEY() k.generate(('%064x' % PRIVATE_KEY).decode('hex')) #here we retrieve the public key data generated from the supplied private key pubkey_data = k.get_pubkey() #then we create a signature over the hash of the signature-less transaction sig_data=k.sign(hash_scriptless) #a one byte \"hash type\" is appended to the end of the signature (https://en.bitcoin.it/wiki/OP_CHECKSIG) sig_data = sig_data + chr(SIGHASH_ALL) #let's check that the provided privat key can actually redeem the output in question if (bc_address_to_hash_160(public_key_to_bc_address(pubkey_data)) != tx_info['txOut'][OUTPUT_INDEX]['scriptPubKey'][3:-2]): bytes = b58decode(SEND_TO_ADDRESS, 25) raise RuntimeError, \"The supplied private key cannot be used to redeem output index %d\\nYou need to supply the private key for address %s\" % \\ (OUTPUT_INDEX, hash_160_to_bc_address(tx_info['txOut'][OUTPUT_INDEX]['scriptPubKey'][3:-2], bytes[0])) ##now we begin creating the final transaction. this is a duplicate of the signature-less transaction, ## with the scriptSig filled out with a script that pushes the signature plus one-byte hash code type, and public key from above, to the stack final_tx = BCDataStream() final_tx.write_int32(tx_fields['version']) final_tx.write_compact_size(tx_fields['num_txin']) final_tx.write(tx_fields['prevout_hash']) final_tx.write_uint32(tx_fields['output_index']) ##now we need to write the actual scriptSig. ## this consists of the DER-encoded values r and s from the signature, a one-byte hash code type, and the public key in uncompressed format ## we also need to prepend the length of these two data pieces (encoded as a single byte ## containing the length), before each data piece. this length is a script opcode that tells the ## Bitcoin script interpreter to push the x following bytes onto the stack scriptSig = chr(len(sig_data)) + sig_data + chr(len(pubkey_data)) + pubkey_data #first write the length of this data final_tx.write_compact_size(len(scriptSig)) #then the data final_tx.write(scriptSig) ##and then we simply write the same data after the scriptSig that is in the signature-less transaction, # leaving out the four-byte hash code type (as this is encoded in the single byte following the signature data) final_tx.write_uint32(tx_fields['sequence']) final_tx.write_compact_size(tx_fields['num_txout']) final_tx.write_int64(tx_fields['value']) final_tx.write_compact_size(len(tx_fields['scriptPubKey'])) final_tx.write(tx_fields['scriptPubKey']) final_tx.write_uint32(tx_fields['locktime']) #prints out the final transaction in hex format (can be used as an argument to bitcoind's sendrawtransaction) print final_tx.input.encode('hex')",
      "This gist , partially based on the answer by Runeks, shows how to transfer 0.01 bitcoins in Ruby. It fetches information from the previous transaction from Blockchain.info, so you just need to feed it your private key and address (the latter being redundant but useful for the demonstration). I added a lot of comments to explain the steps involved."
    ]
  },
  {
    "question": "What does the curve used in Bitcoin, secp256k1, look like?I'm reading up on ECC curves and on many of them I see an illustration that looks like this What does the comparable curve in Bitcoin look like, or are all curves generally the same?",
    "answers": [
      "I'm afraid you won't like the answer. These curves - including the secp256k1 curve, y 2 = x 3 + 7 - 'look' nice when evaluated in typical fields (like the real numbers), but secp256k1 is defined over the finite field Z 2 256 -2 32 -977 , which means the X and Y coordinates are 256-bit integers modulo a large number. Curves using such coordinates do not have any concept of continuous lines. I've tried to plot this curve over a similar but much smaller field, Z 2 8 +1 . Coordinates extend from -128 to 128. Note that even though it may not make sense geometrically anymore, it still has all properties you need. A line (which means, a group of points with equation ay + bx + c = 0 ) that 'intersects' 2 points of the curve, will intersect a third. Tangent again has no geometric interpretation anymore, but you can still symbolically compute a derivative of the equation in a given point, which will have the property of intersecting the curve in a second point. To show you what you'd get if this were over the real numbers, here is a plot of the same curve equation for that case. Once with coordinates -128 through 128, once with -8 through 8.",
      "you can check the Bitcoin doc https://en.bitcoin.it/wiki/Secp256k1 , there you will find some technical details about the secp256k1 used in bitcoin. Below an illustration of the secp256k1's elliptic curve y2 = x3 + 7 over the real numbers (plot using www.desmos.com/calculator/ialhd71we3 ) in the context of a finite field Zp, which greatly changes the ECC appearance but not its underlying equation or special properties. the picture below represents the same equation in a finite field F17 (the x and y values are integers between 0 and 17). and here over F59 : You will find an online opensource tool here https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/modk-add.html which will help you to plot the graphe and to make addition or scalar multiplication on a EC. E.g plot over F97 with P+Q. another good article to read about ECDSA in Bitcoin is https://github.com/bellaj/Bitcoin_Ethereum_docs/blob/6bffb47afae6a2a70903a26d215484cf8ff03859/ecdsa_bitcoin.pdf secp256k1 was almost never used before Bitcoin became popular, but it is now gaining in popularity due to its several nice properties. Most commonly-used curves have a random structure, but secp256k1 was constructed in a special non-random way which allows for especially efficient computation. As a result, it is often more than 30% faster than other curves if the implementation is sufficiently optimized. Also, unlike the popular NIST curves, secp256k1's constants were selected in a predictable way, which significantly reduces the possibility that the curve's creator inserted any sort of backdoor into the curve."
    ]
  },
  {
    "question": "Can I download the whole block chain from somewhere?Every time I turn on the Bitcoin client it takes days to catch up with the block chain. Are there alternatives to getting it trickling through the peer-to-peer network? Can I just download it somewhere? Wouldn't this be ideal for distribution via BitTorrent? If so, how do I import it into the Bitcoin client? My client would still be validating this data (can it?), and it is all signed and proof-of-worked, so there is no real security problem here, is there?",
    "answers": [
      "Note by Murch: This download link is broken and it seems unlikely to me that anyone still provides this service. Network and synchronization code have been immensely improved over the years so that the initial block download via the network is usually acceptably fast. You can download the blockchain nightlies handled by tcatm (one of the Bitcoin core developers and the operator of bitcoincharts.com). Unpack and copy&replace blkindex.dat , blk0001.dat files into C:\\Users\\\"username\"\\AppData\\Roaming\\Bitcoin for Windows 7, and run bitcoind with the -rescan option . Then it will take only a couple minutes to download up to latest block. Be aware that manually copied blocks won't get verified.",
      "This was an issue with versions of the client prior to 0.3.24 -- once the vast majority of the network switches over, the block chain downloads should proceed as fast as your CPU and network connection can handle. There are places you can download the block chain, but the client doesn't provide a way to accept the block chain in any form other than from the network. If you're starting from nothing, it will generally take about 10 hours to process the whole block chain. Most of it isn't transfer time, it's CPU time validating all the hashes and signatures."
    ]
  },
  {
    "question": "If someone wanted to pretend to be Satoshi by posting a fake signature to defraud people how could they?If a random fraudster wanted to post a bunch of mysterious ECDSA signatures that the public would believe came from Bitcoin's creator, in order to disrupt the Bitcoin market, extract money from people, or otherwise convince people to listen to them. How could they do that?",
    "answers": [
      "Unfortunately, given the public's limited of understanding of cryptography this is apparently an easy fraud to pull off. The key trick is that non-technical people are prone to believe things that just sound jargony enough and that technical people tend to think they know a lot more than they actually do-- and so they're easily sent off into the weeds. In cryptosystems the details are more important than you could possibly imagine. So all you have to do is make a forgery that works for a slightly modified cryptosystem and then lots of people who THINK they understand how ECDSA works will rush out to claim the result holds. Most modifications that you can think of are sufficient to make the scheme insecure. So, for example, a couple years ago Craig Wright claimed to 'prove he was Satoshi' by simply copying some pre-existing signatures out of the blockchain and posting somewhat obfuscated instructions on verifying them. It was figured out pretty quickly, but still managed to fool a lot of people-- they were too caught up in the mumbojumbo to think of the obvious. The \"modification\" in this case was that the message the scammer was claiming to sign just has no relationship to the message that was actually signed. More recently it appears that someone attempted something similar again, but this time with 'signatures' that weren't from the blockchain... resulting in 'verification' from the developers of some BCH clients to an engineer at RedHat . But it turns out that, again, that the attempt was fake and people's partial but incomplete understanding of crypto burned them. As Bitcoin developer Pieter Wuille notes \" ECDSA signatures where the message isn't a hash and chosen by the \"signer\" are insecure. \"-- this time the scammer just published 'hash', r, s tuples. The hash part of ECDSA is integral to the algorithm. If the verifier doesn't run the hash themselves, the security properties of ECDSA don't hold and an existential forgery becomes trivial. [This same vulnerability was baked into the original OP_DSV opcode in BCH-- it originally didn't hash the incoming data but left that up to the user-- but I reported it and they appear to have fixed it before deploying it.] If the verifier doesn't perform the hash himself but just accepts a value given by the signer, he becomes susceptible to the following: Given public key P, pick random nonzero values a and b. Compute R=aG+bP. Now (R.x, R.x/b) is a valid signature under key P for \"message-hash\" (R.x*a/b). This doesn't compromise the security of real ECDSA because you cannot find a message that hashes to a chosen (R.x*a/b) value. People should be wary of obfuscated or overly technical 'proofs', -- things that look \"like\" a secure system but for some reason have people verifying it working with raw numbers or code. Well designed cryptographic software put in a lot of effort to avoid users being fooled by stunts like this. This stuff is tricky and anyone could be confused into accepting a false proof if they were convinced to effectively implement a bespoke cryptosystem themselves. A cryptosystem is not secure simply because you, personally, don't see how to break it. Here an an example Sage script to produce forgeries that will fool someone that accepts an ECDSA 'signature' without hashing the message themselves. It works with any EC key, including one that the forger hasn't seen a signature from before. F = FiniteField (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F) C = EllipticCurve ([F (0), F (7)]) G = C.lift_x(0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798) N = FiniteField (C.order()) P = P=-C.lift_x(0x11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5c) # block 9 coinbase payout key. def forge(c, a=-1): # Create a forged 'ECDSA' (hashless) signature # set a to something other than -1 to be less obvious a = N(a) R = c*G + int(a)*P s = N(int(R.xy()[0]))/a m = N(c)*N(int(R.xy()[0]))/a print 'hash1 = %d'%m print 'r1 = %d'%(int(R.xy()[0])) print 's1 = %d'%s for c in range(1,10): forge(c) This code produces fake forgeries of the sort that was used to trick people recently . hash1 = 25292222169426362969760742810503101183086560848420849767135309758511048414376 r1 = 61518691557461623794232686914770715342344584505217074682876722883231084339701 s1 = 54273397679854571629338298093917192510492979773857829699728440258287077154636"
    ]
  },
  {
    "question": "How can I accept bitcoins on my website?I have an online store and would like to begin accepting bitcoins. How can I go about doing this?",
    "answers": [
      "There are a number of ways one can go about accepting Bitcoin on a web interface. Keep in mind as you review these options that Bitcoin is still a young technology and many of these options aren't what you'd call \"friendly\" just yet. That said you do have quite a few options depending on your level of expertise and technical requirements: Use a service like: BitcoinPayFlow BitPay Use an existing shopping cart interface There are existing plugins for Ubercart, Magento and many other popular e-commerce platforms. If you are looking to modify an existing site that happens to run on one of these platforms, this may be your best bet. If you've yet to start a site and don't want to write code yourself this may still be your best bet since you can choose your platform prior to implementation. Roll your own using existing libraries This is your best bet if you're using a platform that isn't currently supported or if you have difficult integration requirements that cannot be satisfied by existing e-commerce platforms like Magento or Ubercart. Languages: ASP.NET/C# PHP Python Many others Roll your own using the JSON API directly This is only necessary if you are not using one of the half-dozen or so languages that already have pre-written libraries for interfacing with bitcoind. The list of languages may be short, but all of the major industry standards have been covered, so it's unlikely you will have to go this far.",
      "You can use services like BitcoinPayFlow or Bit-Pay . I'm working on a payment module to integrate BitcoinPayFlow with OpenCart, watch the project here - it should be ready within a couple weeks. Edit: Bit-Pay just released an OpenCart payment module. See here ."
    ]
  },
  {
    "question": "How is difficulty calculated?Can anyone explain me in the plain English how difficulty is calculated. I have a very approximate understanding that it is calculated based on the amount of hash power in all the bitcoin community over a specific period of time. But this is very vague. Also I understand it can change very rapidly. Can it only increase? Is there any formula how to calculate it or predict it? Thanks for a detailed answer, Meni Rosenfeld. Just to make sure I got everything right. I am summing up all the time, it took to generate the last 2016 blocks. And then apply the formula.",
    "answers": [
      "The Bitcoin difficulty started at 1 (and can never go below that). Then for every 2016 blocks that are found, the timestamps of the blocks are compared to find out how much time it took to find 2016 blocks, call it T. We want 2016 blocks to take 2 weeks, so if T is different, we multiply the difficulty by (2 weeks / T) - this way, if the hashrate continues the way it was, it will now take 2 weeks to find 2016 blocks. For example, if it took only 10 days it means difficulty is too low and thus will be increased by 40%. The difficulty can increase or decrease depending on whether it took less or more than 2 weeks to find 2016 blocks. Generally, the difficulty will decrease after the network hashrate drops. If the correction factor is greater than 4 (or less than 1/4), then 4 or 1/4 are used instead, to prevent the change to be too abrupt. There is a bug in the implementation, due to which the calculation is based on the time to find the last 2015 blocks rather than 2016. Fixing it would require a hard fork and is thus deferred for now. It is possible to give a rough estimate for the next difficulty change, based on the time to find the recent blocks. Nobody can make longer-term predictions for the future difficulty reliably, but anyone is free to speculate based on exchange rate trends, Moore's law and other hardware advances.",
      "Meni's answer is good. I just want to give some practical detail method about difficulty calculation, perhaps helpful for future views of this question's answer. Let's take a look at Satoshi's genesis block header (part of related info): $ bitcoin-cli getblockhash 0 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f $ bitcoin-cli getblockheader 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f { ... \"height\": 0, ... \"bits\": \"1d00ffff\", \"difficulty\": 1, ... } As we can see above, the genesis block has a '1' difficulty and '1d00ffff' bits. The bitcoin bits means the 'target' hash value, the new generated block must meet a condition: block header's double SHA-256 hash value must less than this 'target' value. The '1d00ffff' bits value in genesis block means the 'target' value: [0x00000000,0xffff,{0x00..0x00}] {0x00..0x00} at above has 26 bytes 0x00. Then, to find a new block, you must search that 32 bits nNonce value (and nTimes and the hashMerkleRoot also) until the block hash value has 4 bytes zero leading. By the way, the nNonce is one of the fields in block header structure: struct header_structure{ // BYTES NAME uint32_t nVersion; // 4 version uint8_t hashPrevBlock[32]; // 32 previous block header hash uint8_t hashMerkleRoot[32]; // 32 merkle root hash uint32_t nTime; // 4 time uint32_t nBits; // 4 target uint32_t nNonce; // 4 nonce }; Because SHA-256 algorithm (as well as any cryptographically secure hash algorithm) produces output that will appear like an uniformly random sequence , the practical 'trial and error' method is the only way to find a new block to meet the condition. The probability to find a block with the 4 bytes zero leading hash value is 1/(2^32), that means the average 'trial and error\" numbers are exactly 2^32 (i.e. 4G). For human easy understanding about this 'target' hash value, We define the term 'difficulty', which means the average 'trial and error\" numbers to find a block to meet the 'target' condition. And we define the 'difficulty' unit: 1 'difficulty' = 4G hashes Then, till today, the bitcoin blockchain height reach 501509, let's take a look at its header: $ bitcoin-cli getblockheader 0000000000000000006c5532f4fd9ee03e07f94df165c556b89c495e97680147 { ... \"height\": 501509, ... \"bits\": \"18009645\", \"difficulty\": 1873105475221.611, ... } The block 501509's bits = 0x18009645, it's the compact format of 256 bits integer, its 256 bits format is: [0x00000000,0x00000000,0x009645,{0x00..0x00}] {0x00..0x00} at above has 21 bytes 0x00. that is 0x009645 * (256 ^ 21） The genesis block's target is ( 0x00ffff * 256 ^ 26 ）which is the difficulty unit '1.0'. So, the difficulty = (0x00ffff * 256 ^ 26）/ (0x009645 * 256 ^ 21) = 65535/38469 * (256^5) = 1.703579505575918 * 2^40 = 1873105475221.611 So far, you have all the detail about how to calculate the 'difficulty'. In some cases, we also use the simple format 1.7T to say the difficulty, in above example： (1.703579505575918 * 2^40) = 1.703579505575918T 1T = 2^40 = 1024^4"
    ]
  },
  {
    "question": "What is an SPV client?I've seen SPV client mentioned in several places. What exactly is a SPV client? How is it different from a standard client?",
    "answers": [
      "Simplified Payment Verification: A Bitcoin implementation that does not verify everything, but instead relies on either connecting to a trusted node, or puts its faith in high difficulty as a proxy for proof of validity. BitCoinJ is an implementation of this mode. http://en.bitcoin.it/wiki/Scalability#Simplified_payment_verification Also read: https://en.bitnovosti.com/2018/07/06/jonas-schnelli-current-and-future-state-of-wallets/ https://github.com/bisq-network/bisq/issues/1062 http://en.bitcoin.it/wiki/Thin_Client_Security#Simplified_Payment_Verification_.28SPV.29 MultiBit , Bitcoin Wallet for Android , and Electrum are examples of SPV clients.",
      "SPV is Simplified Payment Verification and it is typically contrasted with \"running a full node\". SPV is around since bitcoin's original incarnation, it has been there since the beginning. It is a perfectly fine way to operate a wallet. The bitcoin network relies on certain \"consensus rules\" to operate. One of these rules is that you can not spend something you own twice. When you send a transaction into the bitcoin network it will eventually be written into the blockchain. Full nodes download the complete blockchain and check every transaction in it to conform to the rules. This is important for you receiving funds also, as it makes sure that what was spent by someone by sending it to you was legitimately spent and is therefor yours. An SPV wallet only downloads a certain part of the block chain, the \"block headers\". Every block in the block chain points to the previous block. The identifier used to identify a block is a \"hash\" of its header. Finding that hash is often referred to as the \"cryptographic puzzle\" or \"proof of work challenge\" that a miner has to solve in order to append a block to the chain. The hash has to conform to a certain difficulty which is dynamically adjusted in the network. In order to make sure that you are not being fooled you have to scan the most recent history of the blockchain to understand what the current difficulty is and whether new blocks that you see are actually valid according to that difficulty. This is way less data then the full blockchain. Another thing a full node does is relaying transactions. Bitcoin is a P2P network which means everybody talks to everybody else. In practice not all 10000 notes talk to all other nodes (that would require 100000000 connections!) but to a subset of nodes. So for your transaction to reach a miner who puts it into a block eventually it might have to be relayed by a node. An SPV wallet is not any less secure for an end user. It will correctly tell you what amount of bitcoin you can spend and whether an amount of bitcoin that was sent to you can actually be spent reliably (i.e. whether you own it). My wording might seem a little weird, that is because technically you never own anything, except for some cryptographic keys that allow you to spend certain funds that were sent to you. You might have read that it's better to run a full node. This statement is true with regards to the network as a whole: The more nodes enforcing the rules of the system the better. The more nodes operating and relaying transactions the better. Think of the four-eyes-principle on steroids. But it is not feasible or even possible for every user to run a full node. For example if you have a wallet on your mobile device which might not have enough resources to validate each and every transaction in the network, or not enough bandwidth to participate. To summarize: If there were no full nodes there would not be a bitcoin network. But for using bitcoin to send/receive funds it is not required to run a full node. Your own security is not affected. IMHO it is better to participate and thereby grow bitcoins value as a utility than not participating at all. It is also better to use your own wallet than for instance a web wallet at any given exchange. Further readings: https://medium.com/@jonaldfyookball/why-every-bitcoin-user-should-understand-spv-security-520d1d45e0b9"
    ]
  },
  {
    "question": "What is a compressed Bitcoin key?The standard Bitcoin client in version 0.6 apparently introduces compressed keys. What are they? Are there any drawbacks to using them? Any incompatibilities with older software? Reductions in cryptographic strength?",
    "answers": [
      "A compressed key is just a way of storing a public key in fewer bytes (33 instead of 65). There are no compatibility or security issues because they are precisely the same keys, just stored in a different way. The original Bitcoin software didn't use compressed keys only because their use was poorly documented in OpenSSL. They have no disadvantages other than that a little bit of additional computation is needed before they can be used to validate a signature. If you think of a public key as a point somewhere along a giant letter U, an uncompressed key is the x and y coordinates of the point. A compressed key is how high up on the U the point is along with a single bit indicating whether it's on the left or right side. As you can visualize, they both encode precisely the same thing, but the compressed form requires half as much space plus one bit. (Of course, they're really points on elliptic curve secp256k1 , but the concept is the same.)",
      "Format (private keys): uncompressed: 0x80 + [32-byte secret] + [4 bytes of Hash() of previous 33 bytes], base58 encoded compressed: 0x80 + [32-byte secret] + 0x01 + [4 bytes of Hash() previous 34 bytes], base58 encoded case 1: secret (hex): 1111111111111111111111111111111111111111111111111111111111111111 uncompressed: secret (base58): 5HwoXVkHoRM8sL2KmNRS217n1g8mPPBomrY7yehCuXC1115WWsh pubkey (hex): 044f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa385b6b1b8ead809ca67454d9683fcf2ba03456d6fe2c4abe2b07f0fbdbb2f1c1 address (base58): 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a compressed: secret (base58): KwntMbt59tTsj8xqpqYqRRWufyjGunvhSyeMo3NTYpFYzZbXJ5Hp pubkey (hex): 034f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa address (base58): 1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9 Obtained from the Bitcoin developer mailing list: http://sourceforge.net/mailarchive/forum.php?thread_name=CAPg%2BsBhDFCjAn1tRRQhaudtqwsh4vcVbxzm%2BAA2OuFxN71fwUA%40mail.gmail.com&forum_name=bitcoin-development"
    ]
  },
  {
    "question": "Can someone explain how the Bitcoin Blockchain works?I'm trying to figure out how the blockchain works and how to read it via blockchain.info website. Is there a laymen way of explaining how the block chain works and how to read the blockchain to trace transactions? What I know so far is: the blockchain is just a public ledger of transactions on the bitcoin network.",
    "answers": [
      "If you are completely new to Bitcoin, you may find my second answer more accessible, which is a less technical description . As you said, the blockchain is a log of all transactions that were ever verified on the Bitcoin network. The transactions are collected in blocks , which are found approximately every ten minutes in a random process called mining. As transactions transfer ownership of Bitcoin balances, each of these blocks represents an update of the user's balances on the network. By following the blockchain from the Genesis Block and applying all transactions that were validated in each block in the correct order, you arrive at the current status quo. Each block header contains: [Illustration by Matthäus Wander (Wikimedia)] Timestamp: The time when the block was found. Reference to Parent ( Prev_Hash ): This is a hash of the previous block header which ties each block to its parent, and therefore by induction to all previous blocks. This chain of references is the eponymic concept for the blockchain. Merkle Root ( Tx_Root ): The Merkle Root is a reduced representation of the set of transactions that is confirmed with this block. The transactions themselves are provided independently forming the body of the block . There must be at least one transaction: The Coinbase . The Coinbase is a special transaction that may create new bitcoins and collects the transactions fees. Other transactions are optional. Target: The target corresponds to the difficulty of finding a new block. It is updated every 2016 blocks when the difficulty reset occurs. Nonce: An arbitrarily picked number to conveniently add entropy to a block header without rebuilding the Merkle tree. The block's own hash: All of the above header items (i.e. all except the transaction data) get hashed into the block hash, which for one is proof that the other parts of the header have not been changed, and then is used as a reference by the succeeding block. As many miners compete to find the next block, often there will be more than one valid next block discovered. This is resolved as soon as one of the two forks progresses to a greater length, at which any client that receives the newest block knows to discard the shorter fork. These discarded blocks are referred to as extinct blocks (sometimes also referred to as orphaned blocks , although their complete ancestry is known). When a transaction is submitted to the network, it is passed on peer to peer by all clients. Upon discovery miners will put it on their list of transactions that they want to verify and update the Merkle Root. On Blockchain.info you can track a transaction either by requesting the page directly with the transaction hash http://blockchain.info/tx/ e.g. http://blockchain.info/tx/37df28642f97db7003a7bc6663467eb1e9cb4493b6c94bf089ee77f87acdae3d or by calling one of the involved addresses through http://blockchain.info/address/ e.g. http://blockchain.info/address/1DrZtRNsSu9BqGcY4D9etFno4H95DqNmKb Either way for each transaction you will see a line with a big arrow that shows you which addresses' were used to fund the transaction and what addresses received which portions of the transaction.",
      "For user32260 : Bill sells Sally some apples for £2.50 Bill is a fruit vendor. Sally wants to buy some apples for £2.50. Sally wishes to use Bitcoin to pay Bill for the apples. Bill presents Sally his payment address, for example as a quickresponse code: Sally uses a Bitcoin wallet on her smartphone to scan the code. She is presented a screen where she can enter an amount to send to Bill's address. She types '£2.50' and presses send. A moment later Bill's tablet notifies him that there is an incoming payment pending, which is not confirmed yet. About ten minutes later, the payment is finalized when it gets confirmed . Under the hood 1) The payment order (Transaction) : The software on Sally's smartphone checks whether Sally has a sufficient balance and then creates a payment order, which we'll call a transaction . This transaction is composed of three pieces of information: which \" coins \" get spend, the payment to the recipient, and a signature. Sally's wallet is connected to other participants in the network. The wallet passes the transaction to all of them, who in turn forward it to all of their connections. Within a few seconds, every participant in the network has received notification of Sally's payment order. Each and every participant checks whether the referenced \"coins\" exist, and whether the signature matches the owner's. 2) Confirmation : So far, Sally's payment is only a promise, because the transaction is still unconfirmed . To change that, some network participants, which we'll call miners , work on confirming these transactions. The miners grab all the unconfirmed transactions and try to pack them into a set. When this set doesn't fulfill the difficulty requirement, they reshuffle it and try again. Miners all over the planet are performing this work until at some point, somebody finds a set with the right properties: a valid block . Because finding a valid block is such an unlikely event, the announcement of the new block proves that the network has expended work to find it. Just as with the transactions before, the miner sends the block to all their connections, who in turn forward it. Every participant checks the work (to confirm that the block follows the rules) and when satisfied, applies the included transactions to their own ledger: the transactions get executed and the \"coins\" that were used by the senders get marked as spent, whereas the recipients gain new \"coins\" as instructed by the transactions. Sally's transaction (and all the others) is now confirmed. Bill can now spend the \"coins\" he received from Sally. 3) The Blockchain Let's take a step back. Before Sally paid Bill, Sally got her bitcoins from Alice. The order of transactions is crucial as transactions can only spend \"coins\" that have already been created. Sally can't pay Bill if she didn't get the money from Alice first. The transactions have an explicit position in the block that confirms them and each block has a fixed position in the block chain by referencing its direct predecessor. E.g. Block 90 links to Block 89 as its predecessor, in turn Block 89 builds on Block 88 , and so forth, until Block 1 points at the 0th block, the Genesis Block . Genesis Block ← 1 ← … ← 88 ← 89 ← 90 The eponymous blockchain has useful properties: Deterministic results : Everyone can start from the Genesis Block and apply each block consecutively to arrive at the same result. Synchronization & Consensus : When you have applied the latest block, the balances in your ledger have the exact same state as in all the other participants' ledgers. Unchangeable History : As each block builds upon its predecessor, each new block buries the history under more work (see graphic below): Illustration: Mark Montgomery/IEEE Spectrum"
    ]
  },
  {
    "question": "Will Bitcoin suffer from a mining Tragedy of the Commons when mining fees drop to zero?One issue that I haven't seen clearly addressed is the possible Tragedy of the Commons in Bitcoin's future (see this answer ). 40 years into the future, the only significant direct benefit for honest miners is transaction fees, as the block reward is almost zero. The potential problem here is Tragedy of the Commons - it is possible that while the entire network will benefit from miners, the financial incentive for any individual honest miner to mine will be too small, so fewer miners \"than necessary\" will mine, leaving the network open to 51% attacks. In this scenario, the Bitcoin network will fall pray to frequent attacks and will effectively disintegrate. Also consider extensions like Open Transactions , that might make conducting transactions on the real Bitcoin network unnecessary for most users, who will flock to 2nd level networks and reduce the miner's rewards from TX fees even more. As Bitcoin is being designed and promoted as a Future Proof system, people have tried to analyse the system's economic behavior in this future. What analysis has been done on this problem? Is the problem likely to happen (speculative question, I know ... but back up your arguments)? If there is a likely problem in the current implementation, what are some possible way to adjust the protocol in the future to combat this problem? Update - please see here , I described a possible scenario that leads to network insecurity because of this issue. Update 2 - linking to a recent thread I created on the forum about this. Update 3 - Added a wiki entry .",
    "answers": [
      "There will definitely be a tragedy of the commons problem if things stand as they are now. This was discussed at some length here and elsewhere. There are some proposed ways to address this and make transaction fees nonzero (block size limit, hardcoded fees, insurance entities, mining cartel, gentleman's agreements which are maintained for fear defection would beget more defection, etc.), but I don't think either results in the combination of competitive transaction fees and a level of hashrate which is enough to offer reasonable security. This means that there must be some way to improve the network's security at a given hashrate. The only way I know to do that is by augmenting proof-of-work with proof-of-stake, discussed for example here . This is based on the observation that obtaining a majority of the bitcoins in existence is orders of magnitude more difficult than obtaining a majority of the hashrate.",
      "Mike Hearn just posted about how Network Assured Contracts handle this problem. I don't find an immediate flaw with this. This is how I understand the proposed solution: Anyone with an interest in a high hash rate (basically, anyone holding a large amount of coins), can initiate or cooperate on SIGHASH_ANYONECANPAY transactions. Those are an effective way for people to say stuff \"I pledge 10 BTC for the next miner to mine a block, provided 100 total BTC is donated in this transaction ... otherwise, I'll get my money back in 5 blocks\"? So, if people or organizations holding a large amount of BTC see that the security is too low for their standard, they can chip in ... provided others do so as well."
    ]
  },
  {
    "question": "What happens if your bitcoin client generates an address identical to another person's?Here's a what-if scenario: Person A has a Bitcoin address with 25BTC. Person B opens up their Bitcoin client: which may or may not have the complete blockchain (the latter would mean no copies of Person A's transactions) Person B presses \"New Address\", and Person A's address happens to somehow be generated. Now, the blockchain finishes synchronizing. What happens? Is this a possibilty, sans the astonishing improbability? After all, random number generation can be influenced.",
    "answers": [
      "If this happens, then Person B will be able to spend person A's bitcoins. However, there are only two ways this can happen: a) Person B generates the same keypair (private key) as person A or b) Person B generates a different keypair, which (public key) hashes to person A's address (a hash collision) Take a look at the specification for at bitcoin address: https://en.bitcoin.it/wiki/Technical_background_of_Bitcoin_addresses A Bitcoin address is a 160-bit hash of the public portion of a public/private ECDSA keypair For \"a\" to happen, person B would need to break \"secp256k1\". I am no expert on this field, but from what I can find on bitcointalk.org , then the \"strength\" of this is 2^128 bits. And if you're wondering how strong that is, then look for the video \"Exhaustive search attacks\" from Dan Boneh . 11 minutes in the video he says \" anything that's bigger than 2^90 is considered sufficiently secure \" (its about attacking 3DES, which is a symmetric block cipher so I'm not sure it actually apply to secp256k1, but I really have no better argument for why 2^128 is \" so secure that you won't never, ever, ever generate the same key as someone else \" And for \"b\" to happen, you would need to find a collision on RIPEMD-160(SHA-256(pk)). As far as I know, then neither RIPEMD-160 nor SHA-256 is known to have any vulnerabilities to hash collision attacks. So somehow breaking both or randomly generation a key which hashes is exactly the same as another bitcoin address, is highly unlikely. There is also a chance for you computer to catch on fire, and some of the materials to melt together into a lotto coupon with winning numbers on (and a valid barcode), but it just won't happen because of the chance is so unbelievably small (it's the same with the \" click and generate another persons bitcoin address \"). EDIT Woops, one important thing: This all assumes that all bitcoin addresses are properly generated using \"true random\". All brain-addresses and addresses generated using a bad PRG, might be easy to find by either using a flaw in the PRG or exploit the (flaws in the) human brain.",
      "This is the way I see it. The total number of bitcoins that will ever be mined is 21 million. The smallest bitcoin unit is a satoshi (0.00000001 BTC). If we place all possible satoshis into a wallet of their own, we would get the maximum number of wallets that could have any balance to them (so the actual number of wallets with bitcoins is obviously less). This is 21x10^6(BTC) x 10^8 (satoshi/BTC) = 21 x10^14 wallets. It's a huge number, but it's eclipsed by 2^256 possible wallets. So in this worst case scenario, the probability of guessing a wallet with one satoshi is 21x10^14/(2^256)=1.813595x10^-62. An incredibly small number."
    ]
  },
  {
    "question": "How many bitcoins will there eventually be?Since bitcoins are being regularly rewarded to miners , will the number of bitcoins continue to grow indefinitely, or will there be a maximum total number of bitcoins in existence? And if there is some kind of limit, what is it and how is it enforced?",
    "answers": [
      "Every block introduces 50 new coins in the system. This quantity (50) halves every 210,000 blocks. So, getting the limit of coins it is possible to generate is quite easy : it's the sum of a geometric series. Also, note that this is an upper bound ; the actual quantity will probably be a bit lower due to rounding issues (BTC has a finite number of decimals, 8).",
      "A pre-defined schedule limits the total number of bitcoins so that they gradually approach a total of 21 million (ignoring those that have been lost through deleted or misplaced wallet files). The limit of 21 million bitcoins is \"hard-wired\" in to the protocol , and there will never be more bitcoins than this:"
    ]
  },
  {
    "question": "What is meant by Bitcoin dust?I've seen the term \"dust\" used to describe small transactions that might be considered as spam by the Bitcoin network. Is there is a generally accepted definition of this term?",
    "answers": [
      "Dust is often used colloquially to refer to any small amount UTXO. In contrast, Bitcoin Core’s precise definition of dust is used in mempool policy to define a minimum for output amounts in standard transactions. Bitcoin Core considers a transaction output to be dust, when its value is lower than the cost of creating and spending it at the dustRelayFee rate. The default value for dustRelayFee is 3,000 sat/kvB¹, which results in the same dust values as the prior dust definition used before Bitcoin Core 0.15.0. The previous dust definition tied the dust limit to the minRelayTxFee rate and the spending cost of an output exceeding 1/3 of its value. dust = (input_vsize + output_size) × 3 sat/vB At the default dustRelayFee of 3,000 sat/kvB, given the size of a P2PKH input being 148 bytes and the size of a P2PKH output being 34 bytes, P2PKH outputs worth less than 546 satoshis are considered dust by Bitcoin Core (546 satoshi being the smallest non-dust value). For P2WPKH outputs, Bitcoin Core considers outputs worth less than 294 satoshis ² dust. Since the input sizes of scripthash and taproot outputs are unknowable , Bitcoin Core combines their actual output sizes with the input sizes of the corresponding keyhash types for dust thresholds of 540 satoshis for P2SH, and 330 satoshis for P2WSH and P2TR. The dustRelayFee can be set with the hidden command line option -dustrelayfee . Additionally, Bitcoin Core 0.15.0 added a discard_rate . The discard_rate matches the longest target fee rate estimate (currently the 1,000 block fee rate estimate), but is bounded to at least dustRelayFee and at most 10,000 satoshi/kvB. Any change output that would be dust at the discard_rate , i.e. would cost more to spend than its value at the discard_rate , will automatically be dropped to the fee instead of being created as a change output. Other uses of \"dust\" Note that the term \"dust\" is also colloquially used to refer to a) any UTXOs of vanishingly low value and b) for UTXOs that are uneconomical to create or spend at the current feerate . ¹ The transaction size was measured in bytes before segwit. Since segwit, the relevant measure is transaction weight which is either given in virtualbytes (vbyte, vB) or weight units (wu) where 4 wu = 1 vB. For non-segwit transactions, their size is equal to their virtualsize: 1 B = 1 vB. For segwit transactions, their virtualsize is smaller or equal to their size. You can read more about these units on Is there a difference between bytes and virtual bytes (vbytes)? . ² The attentive reader might expect the dust limit for P2WPKH outputs to be 297 satoshis as P2WPKH outputs are 31 bytes and P2WPKH inputs are about 68 vbytes , but it appears that when the dust limit for P2WPKH outputs was implemented , the code contained a rounding error in the vsize of the input that caused it to be assumed one vbyte smaller than it actually is. (Hat tip to Crypt-iQ for pointing this out .)",
      "EDIT: This answer still gets upvotes 10 years later, so I'm going to try and update the answer a bit as all of the links and numbers were horribly out of date. Dust is any transaction that is considered too small to be worth carrying out. Dust is a theoretical problem in cryptocurrency because a bad actor could attempt to flood the processing network with an overload of tiny transactions: the equivalent of trying to shutdown a store by paying at the only register with one penny at a time. Therefore, there are some safeguards in the BTC network that prevents \"dust\" transactions from propagating. Minimum transaction fees are also a way of preventing dust from being a problem. The exact size below which a transaction is considered \"dust\", however, has no hard definition. Different clients, software, and different nodes might all have different limits. And those limits might change over time as the value of BTC changes. Amusingly, when I originally wrote this answer BTC was around $20 and 0.01 BTC was considered dust by some clients as it was only worth $0.20. As I edit this article today, that same 0.01 BTC is worth about $170, so I don't think it would be classified as dust by anyone. The Bitcoin Core currently defines dust here in this code . (Even if you can't read C code, the majority is just text describing the intent of the fucnction.): bool IsDust(int64_t nMinRelayTxFee) const { // \"Dust\" is defined in terms of CTransaction::nMinRelayTxFee, // which has units satoshis-per-kilobyte. // If you'd pay more than 1/3 in fees // to spend something, then we consider it dust. // A typical txout is 34 bytes big, and will // need a CTxIn of at least 148 bytes to spend, // so dust is a txout less than 54 uBTC // (5460 satoshis) with default nMinRelayTxFee return ((nValue*1000)/(3*((int)GetSerializeSize(SER_DISK,0)+148)) < nMinRelayTxFee); } I'd consider this the lowest threshold of dust: 54 uBTC. If Bitcoin Core rejects a transaction as dust it's very unlikely for a transaction to be successful. But other software and/or markets might have higher thresholds for dust. And Bitcoin Core might change its threshold again if the prices and/or fees change significantly. The exact definition of dust, and the threshold for what is considered dust may change over time with the transaction volume (and therefore competition for space in the blockchain) and exchange rates."
    ]
  },
  {
    "question": "Where do bitcoins come from and what gives them their value?Where do bitcoins come from? From the WeUseCoins.com video it appears they are just being produced by \"miners\" and sold to people. So who backs Bitcoin or gives it its value?",
    "answers": [
      "Although individual bitcoins enter the Bitcoin economy as miners are rewarded for processing transactions, it's much more helpful to think of all 21 million bitcoins as having been created when Satoshi Nakamoto defined the Bitcoin protocol and launched the Bitcoin network in 2009. The reason for this is that the Bitcoin protocol specifically defines and controls when and how a limited total number of coins are rewarded to miners for the job of securing the Bitcoin network. These \"bitcoins\" are really just mathematical tokens which are very carefully controlled by the network protocol to prevent counterfeiting, theft, etc. By agreeing to use these mathematical tokens as money, the larger Bitcoin community is essentially \"backing\" their value and turning them into a currency in the same way traditional African and Asian societies used the money cowry despite the absence of any central bank. Unlike the money cowry: there will never be more bitcoins they are impossible to counterfeit they can be divided into as small of pieces as you want and they can be transferred instantly across great distances via a digital connection such as the internet. Presumably, the members of the Bitcoin community who choose to accept them as money consider these features to be worth something, and value the bitcoin accordingly based on supply and demand on open currency exchanges . Because bitcoins are given their value by the community, they don't need to be accepted by anyone else or backed by any authority to succeed. They are like a local currency except much, much more effective and local to the whole world. So to sum up, bitcoins come from the Bitcoin community's agreement to follow a set protocol, and are backed by everyone who uses them as money.",
      "That is basically it. They have value because they are scarce, fungible (one Bitcoin is as good as another), easily transferred, and easily verified. The only other component they need to have value is a general agreement that they will be used as a medium of exchange or a prevailing belief that they will be in the future. It is the variation in these two factors that accounts for most of the volatility in the value of Bitcoins today. They aren't backed by anything because they're a commodity. What is gold backed by?"
    ]
  },
  {
    "question": "Explanation of what an OP_RETURN transaction looks likeHow is OP_RETURN used and why was it introduced in the first place?",
    "answers": [
      "Note: I went out and learned about how the OP_RETURN opcode works at the byte level in a bitcoin transaction. I’m writing it here so that others can learn quickly. First, a brief history of why we’re even talking about OP_RETURN . Back in 2013 different players in the bitcoin ecosystem were trying to include bits of information into transactions so that they could take advantage of the irreversibility of the blockchain. Imagine for instance you wanted to write a contract and place it in an unchangeable location that at any future date one could go back to verify it existed. You can do this by using the blockchain. You add some bits to the transaction's scriptSig value that don't alter the end result of running that script, but allow you to store information like “I hereby declare to give asset A to address XYZ at time UNIX_TIMESTAMP”. There were even stranger ways people would add extra bits, like including it in the BTC value of an output. Some members of the community did not like this, as they saw these extra bits as polluting the blockchain. The extra bits were a network efficiency concern because more bits meant larger block chains and more of an onus on those who are running full nodes, and it was also a community consensus concern because they thought “we all implicitly agreed to store financial data in the blockchain, which is important to everyone, but we did not agree to store data like small text messages and invoice text”. To reach a middle ground in these opposing views, the core-developers made the opcode OP_RETURN a valid opcode to be used in a bitcoin transaction, which allows 80 arbitrary bytes to be used in an unspendable transaction. A good explanation of this can be found here: https://bitcoinfoundation.org/bitcoin/core-development-update-5/ Later in February 2014, the bytes count was reduced from 80 to 40 bytes. This change is documented in the link below. Note that in this pull discussion we learn that no more than one output with OP_RETURN can be included in a single transaction: https://github.com/bitcoin/bitcoin/pull/3737 Now that we’ve got the reason behind OP_RETURN down, let’s look at an example of OP_RETURN. I used chain.com’s API to find a transaction which has an OP_RETURN in its scriptSig. That tx’s hash is 8bae12b5f4c088d940733dcd1455efc6a3a69cf9340e17a981286d3778615684 Make sure you are connected to a fully-loaded bitcoind node, and run this command: $> bitcoind getrawtransaction 8bae12b5f4c088d940733dcd1455efc6a3a69cf9340e17a981286d3778615684 1 which will give you this output: { \"hex\" : \"0100000001c858ba5f607d762fe5be1dfe97ddc121827895c2562c4348d69d02b91dbb408e010000008b4830450220446df4e6b875af246800c8c976de7cd6d7d95016c4a8f7bcdbba81679cbda242022100c1ccfacfeb5e83087894aa8d9e37b11f5c054a75d030d5bfd94d17c5bc953d4a0141045901f6367ea950a5665335065342b952c5d5d60607b3cdc6c69a03df1a6b915aa02eb5e07095a2548a98dcdd84d875c6a3e130bafadfd45e694a3474e71405a4ffffffff020000000000000000156a13636861726c6579206c6f766573206865696469400d0300000000001976a914b8268ce4d481413c4e848ff353cd16104291c45b88ac00000000\", \"txid\" : \"8bae12b5f4c088d940733dcd1455efc6a3a69cf9340e17a981286d3778615684\", \"version\" : 1, \"locktime\" : 0, \"vin\" : [ { \"txid\" : \"8e40bb1db9029dd648432c56c295788221c1dd97fe1dbee52f767d605fba58c8\", \"vout\" : 1, \"scriptSig\" : { \"asm\" : \"30450220446df4e6b875af246800c8c976de7cd6d7d95016c4a8f7bcdbba81679cbda242022100c1ccfacfeb5e83087894aa8d9e37b11f5c054a75d030d5bfd94d17c5bc953d4a01 045901f6367ea950a5665335065342b952c5d5d60607b3cdc6c69a03df1a6b915aa02eb5e07095a2548a98dcdd84d875c6a3e130bafadfd45e694a3474e71405a4\", \"hex\" : \"4830450220446df4e6b875af246800c8c976de7cd6d7d95016c4a8f7bcdbba81679cbda242022100c1ccfacfeb5e83087894aa8d9e37b11f5c054a75d030d5bfd94d17c5bc953d4a0141045901f6367ea950a5665335065342b952c5d5d60607b3cdc6c69a03df1a6b915aa02eb5e07095a2548a98dcdd84d875c6a3e130bafadfd45e694a3474e71405a4\" }, \"sequence\" : 4294967295 } ], \"vout\" : [ { \"value\" : 0.00000000, \"n\" : 0, \"scriptPubKey\" : { \"asm\" : \"OP_RETURN 636861726c6579206c6f766573206865696469\", \"hex\" : \"6a13636861726c6579206c6f766573206865696469\", \"type\" : \"nulldata\" } }, { \"value\" : 0.00200000, \"n\" : 1, \"scriptPubKey\" : { \"asm\" : \"OP_DUP OP_HASH160 b8268ce4d481413c4e848ff353cd16104291c45b OP_EQUALVERIFY OP_CHECKSIG\", \"hex\" : \"76a914b8268ce4d481413c4e848ff353cd16104291c45b88ac\", \"reqSigs\" : 1, \"type\" : \"pubkeyhash\", \"addresses\" : [ \"1HnhWpkMHMjgt167kvgcPyurMmsCQ2WPgg\" ] } } ], \"blockhash\" : \"000000000000000004c31376d7619bf0f0d65af6fb028d3b4a410ea39d22554c\", \"confirmations\" : 2655, \"time\" : 1404107109, \"blocktime\" : 1404107109 } Now, look at this transaction’s list of outputs, in particular the 1st one. By referencing the Bitcoin Wiki’s page on Script , Bitcoin’s stack-based programming language, we can see here that the OP_RETURN opcode is represented by the hex value 0x6a. This first byte it followed by a byte which represents the length of the rest of the bytes in the scriptPubKey. In this case we see the hex value Ox13, which means there are 19 more bytes. These bytes comprise the arbitrary less-than-40 bytes you are allowed to send in a transaction marked by the OP_RETURN opcode. If you pop the message bytes into a UTF8 decoder, you’ll see that 636861726c6579206c6f766573206865696469 becomes “charley loves heidi”. Aw! It’s almost like a digital version of a couple’s romantic heart tree carving. Now you understand at a byte level how OP_RETURN is supposed to work. You can write software now that searches for the OP_RETURN opcode in an output’s scriptPubKey, and use it to verify a contract or some other digital asset.",
      "If you want to write OP_RETURNs to the blockchain without getting into the internals of how transactions are built, an easy way is to use our libraries for PHP and Python: https://github.com/coinspark/php-OP_RETURN https://github.com/coinspark/python-OP_RETURN These support either sending individual transactions with one OP_RETURN attached, or else sending a batch of linked transactions to embed larger pieces of content. That content can then be retrieved from the blockchain using a single identifier. Assuming you're using Bitcoin Core 0.11, you can change the value of OP_RETURN_MAX_BYTES to 80 , rather than 40 as it currently stands in the code."
    ]
  },
  {
    "question": "In the ASIC-age, is it worth starting mining Bitcoin at home?I have recently learned about Bitcoin and would like to get rich quickly into mining. I have control of a laptop library full of ancient computers powerful gaming PC cluster of GPUs an old ASIC, I got for three times its worth off eBay a cluster of EC2 servers My power bill is frightfully expensive dirt cheap subsidized by my neighbors included in rent non-existent, because I produce a power surplus Is it worth getting started with mining?",
    "answers": [
      "Generally, it's not worth your time and effort to mine at home! (Some exceptions may apply.) Age of ASIC mining CPU mining has been unprofitable since 2011 , GPU mining just slightly later . Today, ASICs rule mining. The Bitcoin network has more than 1.7 Ehash/s (Oct 2016) now which is 1,700,000,000,000 Mhash/s. Your graphics card will be running full blast to churn out a few hundred Mhash/s, your CPU maybe a few dozen. With CPU or GPU you will never collect a sufficient balance with a mining pool that you could even get paid out. It's a waste of time, even if you don't pay for power. Mining has gone big scale Meanwhile, ASIC mining has gone industrial. Corporations are building mining centers in regions with very cheap power, and filling them with millions of USD worth of ASIC miners. Greater mining power in one hand does have some slight advantages which adds to their more efficient processes. Finally, ASIC miners have been catching up quickly technologywise: Every few months new chips get announced moving the scale down a few more nm. Currently, we are reaching 16nm technology (Oct 2016), which is already pretty close to the general state of the art. The problem with that is that every step of miniaturization comes with a leap in power efficiency, quickly obsoleting older generations of ASICs. Chances are that your investment will outdate before it pays for itself – even when you are just looking at cost of acquisition and have no cost of power. Mining profits tend to zero The mining market tends to reach an equilibrium: While it is very profitable to mine, there is room for investments. The additional mining power increases the difficulty for all which in turn reduces the profitability. When the difficulty rises, it drives out the least cost efficient mining operations, in turn increasing the profitability of the remaining miners. If you're not in a particularly advantageous position, you will be quickly pushed out of the market. Also see: Why does mining profitability tend towards zero? If you're not paying for your power, someone else is Anyway, if you're \"not paying for your power\", because it's included in rent (e.g. in a dormitory), you're either privatizing profits by socializing costs, i.e. stealing from your neighbors, or you'll be paying for it next year when your landlord increases your rent to cover the higher power bill. If you produce a power surplus or use the ASIC to replace electric heating, hey, you might be one of that exceptions I mentioned going in. There might be some altcoins that can still be profitably CPU/GPU mined and traded for Bitcoin thereafter, but I am not sure whether even they are worth it when you factor in your time investment. If you have understood all of the above, please feel free to check out How much Bitcoin will I mine right now with hardware X? How can I start mining Bitcoin?",
      "Bitcoin, as the answers imply, is long out of the reach of home miners, however other coins can use all your hardware, e.g. Gridcoin (GRC). Gridcoin rewards work done on the BOINC platform which is a distributed super-computer. This clearly needs peers with general purpose computing resources, not ASICs which can only perform one task. Anyone can make a BOINC project. Once the Gridcoin community vote on its inclusion in the 'whitelist', users processing work for the project receive GRC."
    ]
  },
  {
    "question": "How anonymous are Bitcoin transactions?I read some sources that say Bitcoin transactions are anonymous, some that say they are semi-anonymous, and some that say they are not anonymous at all. In what ways are the transactions anonymous and in what ways are they not anonymous?",
    "answers": [
      "Technically the appropriate term is \"pseudonymous\" - imagine that your bitcoin address is like an email address or an online alias: how hard it is to trace to your actions depend largely on what you do with it. There is, for example, a bitcoin address in my forum signature that would obviously be VERY traceable back to me. On the other hand if I install the client on a separate system which only connects to the internet through TOR and obtain my bitcoins by mining them from a pool like Eligius (no accounts/email necessary, they only ask for a bitcoin address) then it would be very difficult indeed to trace those funds to me. And of course there are shades of gray in-between. As I said, think of it as being an email address and then consider how your actions with that bitcoin address can be tied to you. It's difficult but possible to make truly anonymous bitcoin transactions.",
      "It is considered pseudo-anonymous. With casual usage, it is not very anonymous at all. Transactions occur between cryptographic addresses and anyone can create any number of these addresses. However, Bitcoin transactions can be traced back to your IP address. The history of all transactions can be analyzed for spatial and temporal correlations. If one address can be linked to a person, then related transactions can be identified. I would say that bitcoin offers a degree of privacy not offered by other means of online payment, but for a sufficiently motivated entity, it is possible to reconstruct a person's bitcoin transaction activity. There are steps that one can take to make it more anonymous, but it is certainly not as anonymous as physical cash. And, you have to know what you're doing to use it in complete anonymity. I would not advise using bitcoin if you are seeking complete anonymity."
    ]
  },
  {
    "question": "How to calculate transaction size before sending (Legacy Non-Segwit - P2PKH/P2SH)I know that I pay the transaction fee per kB, so how can I calculate how large the transaction will be before I send it via the RPC api. I run a site using bitcoins, and I cannot let the user's balance go negative, so I need to know if they have enough balance to cover the cost.",
    "answers": [
      "Assuming all the inputs you are spending are from regular \"pay to address\" transactions, each input will contribute 180 (plus or minus 1) bytes to the transaction. Each output adds 34 bytes to the transaction. And there's a fixed extra 10 bytes which are always present. The \"plus or minus 1\" comes from the fact that each input needs a signature to be claimed. The signature contains two 32 byte values, but if either of the values has a first byte of 0x80 or more, it has a 0x00 byte prepended to it. So I'm assuming one of the two is high and the other is low. That way I'm off by at most one byte per input. So if your transaction has in inputs and out outputs, the transaction size, in bytes will be: in*180 + out*34 + 10 plus or minus 'in' For example, this transaction has 40 inputs and 16 outputs. That gives us a transaction size of 40*180 + 16*34 + 10 +- 40 i.e. 7754 +- 40 bytes. The actual size is 7761 bytes. If the inputs are from \"pay to pubkey\" transactions then the inputs are smaller than for \"pay to address\" transactions. And this will be different also for \"pay to script hash\" inputs too, depending on how/if that's implemented. Edit: This transaction was made with bitcoins stolen in the Linode heist and shows a transaction size of 1337 , possibly a deliberate use of leetspeak in the blockchain. Edit2: Now that compressed public keys are commonplace, each input is 32 bytes shorter and so the transaction size is now: in*148 + out*34 + 10 plus or minus 'in'",
      "Here are some calculations based on the Protocol Documentation . A Bitcoin Transaction is composed of the following: Version (4 Bytes) TxIn Count (1 ~ 9B) For each TxIn: Outpoint (36B) Script Length (1 ~ 9B) ScriptSig(?) Sequence (4B) TxOut Count (1 ~ 9B) For each TxOut: Value (8B) Script Length(1 ~ 9B)* Script (?)* LockTime (4B) Assuming a standard P2SH/P2PKH transaction is created, the script length marked in asterisk will be bound to 1byte as the Script Length is encoded as a variable integer; while the script size marked in asterisks will be bound to 24bytes as it will only contain a script hash. So, in summary, we can assume that the maximum bound of each TxOut to be 34 bytes if we are paying to a P2SH/P2PKH address, since there are 4 opcodes in each output script. A great breakdown can be found here . Assuming we are spending P2PKH outpoints for our TxIn. Our ScriptSig (composed of a 72byte DER Encoded Transaction Signature + 33byte Public Key) would be 146bytes in size and our script length will only consume 1byte as the size of the ScriptSig is less than 0xFD. Therefore, a standard P2PKH/P2SH transaction spending a ONE UTXO redeemable with a basic ScriptSig paying to only ONE output is 189bytes. Otherwise, we can also further generalise this to: in marks the number of TxIns out marks the number of TxOuts Assuming that in < 254 and out < 254. Size of P2SH/P2PKH Transaction = in * 146 + out * 33 + 10 Computing the size of P2SH/P2PKH transaction that is being funded with complex inputs (i.e. UTXOs spendable with M-of-N signatures, hashed-timelocked contracts) is inherently difficult and is dependent on the complexity of the redeemScript used to produce the scriptHash of the prior P2SH transaction."
    ]
  },
  {
    "question": "What is a soft fork? What is a hard fork? What are their differences?When people talk about possible changes to how Bitcoin works they sometimes say a particular change can be implemented as a soft fork. What does that mean? How does this compare to a hard fork?",
    "answers": [
      "What is a Project Fork? A fork in software development refers to the event of an independent project spinning off from a software project. Such forks sometimes occur in the opensource sphere, when there are irreconcilable plans/goals within a project's community, then often leading to a split in the community and two distinct projects thereafter . In practice this takes form in the sourcecode being copied and henceforth being developed in a different direction independently by the forkers. For example in this conventional sense of fork, Litecoin is a fork of Bitcoin: Litecoin started as a copy of Bitcoin's code-base, but developed into an independent project (although still closely related). Softfork and Hardfork in Bitcoin terminology The terms softfork and hardfork in Bitcoin describe compatibility breaking changes in the Bitcoin protocol: Should the community be irreconcilably divided about such an issue, the old version and the new version of Bitcoin could emerge as distinct projects thereafter. While both versions of the Bitcoin protocol are in use, the differences in acceptance may cause a lasting blockchain-fork, i.e. two distinct longest chains which are both considered valid by part of the network. Softforks are forward compatible Softforks restrict block acceptance rules in comparison to earlier versions. The new rules allow a subset of the previous valid blocks, therefore all blocks considered valid by the newer version are also valid in the old version. If at least 51% of the mining power shifts to the new version, the system self-corrects: Blocks created by old versions of Bitcoin Core that are invalid under the new paradigm might commence a short-term \"old-only blockchain-fork\", but eventually, they would be overtaken by the chain fork created under the new paradigm, as the hashing power working on the old paradigm would be smaller (\"only old versions\") than on the new paradigm (\"accepted by all versions\"). However, if less than 51% of the hashing power switches to the new version, the blockchain-fork will not mend automatically as the chain created under the old rules has more hashing power and is incompatible to the new rules. This can either be remedied by the adopters of the softfork giving up their chain, or more hashing power switching to the softfork chain. The latter would cause the softfork chain to eventually overtake and reorganize the other chaintip. Hardforks are not forward compatible Hardforks ease block acceptance rules making previously invalid blocks valid in the new version. Obviously, this is not forward compatible as older versions will not accept the new blocks, causing the users of the old paradigm to remain on their own blockchain-fork indefinitely. To implement a hardfork, without a blockchain-fork, all users must switch to the new protocol consensually. HF != blockchain-forks Lately, I've seen \"hardfork\" being used interchangeably with \"chain split\". They refer to different things. A chain split is the state of the network when mining is based on more than one chaintip at the same time. This can happen for various reasons, including hardforks, softforks, buggy node software, and simply two miners discovering a block at the same height.",
      "Softforks are forwards-compatible Old nodes will accept blocks created by new nodes. With a softfork, only miners will have to upgrade, or else they will end up on the losing fork. Users and merchants can keep running older nodes, which will accept the newer blocks. Hardforks are not forwards-compatible Old nodes may not accept blocks created by new nodes. With a hardfork, everyone (miners, users, and merchants) will need to upgrade to the new code."
    ]
  },
  {
    "question": "How does the Lightning network work in simple terms?Could you please describe how the Lightning network is supposed to work? How does it scale better than pure blockchain transactions? What are the advantages and disadvantages of Lightning Network and blockchain transactions?",
    "answers": [
      "The Lightning Network is a collection of payment channels between pairs of nodes. To create a payment channel, two users commit funds to a UTXO under shared control. The shared funds allow the users to pay each other by changing how much they will pay out to each eventually. The state of the payment channel is stored in presigned Bitcoin transactions that spends the shared funds back to the individual users. As long as neither broadcasts the final state of the channel to the Bitcoin network, you can think of the funds in the channel like beads on an abacus—they can only go from one side to the other, but cannot leave the channel. By having multiple channels, users can forward payments from one peer to another, allowing payments between peers that don’t have direct connections. The Lightning Network allows for instant payments with a significantly compressed blockchain footprint. Let’s say that you and I want to open a payment channel. 1. Putting funds into Lightning We negotiate to each send 0.05 BTC into a shared 2-of-2 multisig output, the channel funding output .¹ This will require a transaction on the Bitcoin blockchain. As a “balance sheet” and escape hatch, we negotiate a 2-of-2 multisig transaction that pays out 0.05 BTC to you and 0.05 BTC to me. We call this the commitment transaction . The commitment transaction comes actually in two variants. I sign your commitment transaction and give it to you. If you want to put it in effect, you need only add your own signature and broadcast it to the Bitcoin network. Vice versa, you sign and give me my copy of the commitment transaction. The commitment transactions are future transactions for the Bitcoin network, they're just not valid yet because we have not actually created the channel funding output yet, and because they are each missing one signature. The commitment transaction comes in two variants because the copy you and I hold are asymmetric: your commitment transaction puts a timelock on your Settlement Output, and mine locks my Settlement Output. We’ll see below why we need that. The commitment transaction guarantees that either of us can close the channel and return the funds to our respective controls by themselves. Now that we are confident to be able to to get back our funds, we can sign and broadcast the funding transaction: We are later going to use the following shorthand to represent a channel and its current balances: 2. Payment Now, I want to pay you 0.01 BTC. We each create a new commitment transaction (\"balance sheet\") as before, but this one says that you get 0.06 BTC and I get 0.04 BTC. Each of us gets a new commitment transaction signed by the other to that effect as before. To make sure that neither of us can use the old commitment transaction the other signed previously, we each create a justice transaction to prevent cheating. The justice transaction allows the channel partner to spend our timelocked output from our first commitment transaction to the themselves if we use the outdated commitment. If we use the correct commitment, the funds go to ourselves after the timelock passes, until then the counterparty can take the funds if we cheated. I.e. when I try to activate the (now obsolete) 0.05 - 0.05 BTC balance sheet, my paid-out funds are locked for a number of blocks. This gives you time to broadcast the justice transaction in which I signed off on my 0.05 BTC output being sent to you. It's safe for me to give you your justice transaction, or really to anyone, because the justice transaction will only be valid as a response to the fraudulent use of the old commitment transaction.² With the setup as described above, I'd have to come online before the timelock expires to catch an attempt at cheating, but obviously it wouldn't be safe for me to keep payment channels open if I might be offline for extended periods. Luckily, there are watchtower services that take a small payment to monitor for cheating and can broadcast the justice transaction on your behalf when they detect it. 3. Network payment Alright, now you and I can send money back and forth thousands of times, with almost instant effect (depending only on how fast we can communicate with each other) without adding any additional transaction to the Bitcoin blockchain. Yet, on the other hand, if one of us ever tried to defraud the other, they would be instantly taken to court by having the dispute resolved on the blockchain to their own detriment. Pretty spiffy, but not terribly useful yet. By the theory of six degrees of separation , everyone is connected to any other participant via only a few hops. Let's say you are getting some coffee from Bob the Barista. You do not have a payment channel with Bob, but you have the channel with me, and both Bob and me each have a payment channel with Alice. Let's assume that each payment channel has 100 m₿ in it, split equally. Our \"network\" now looks like this: Now, since you don't have a direct payment channel to Bob (and it would be very inefficient if you had to create a payment channel with every business partner you ever meet), you route your payment through the network. Instead of only writing an update of the balance between Bob and you as I described above, this becomes a concerted effort: Your wallet finds a route from you to Bob that has a) sufficient liquidity, b) least fees, and c) fewest hops. To make a payment, each involved payment channel updates its balances. With a payment of 1 m₿ for the coffee, this updates our network to: As you can see, the balances at the ends have shifted appropriately from you to Bob, but the other participants have the same balance (although shifted to other payment channels). It's important to realize, that the payment can only go through completely or not at all . Either we all update the balances, or no one does. Now, imagine that you don't have only the one payment channel with me, but you have maybe a half a dozen payment channels with other users! :) 4. Cooperative channel closing Other than in the above case where one side closes the channel unilaterally, one of us can request to cooperatively close a channel from the other. When we agree, we collaborate to create a final payout transaction that doesn't lock any funds and allows immediate spending after confirmation. We could even use this transaction to spend some of our balance directly to a third party on the blockchain, or to create another different payment channel. Let’s say I want to pay Carol on-chain when we close the channel after the second commitment transactions have been exchanged. 5. Trade-offs You cannot receive more money through the Lightning Network in one payment than the sum of your channel counterparties’ balances. Sender and receiver have to be online for a payment to be conducted. Your Lightning Network payments don't get recorded on the blockchain for eternity, (i.e. better payment privacy), but your Lightning node has a permanent identity and your announced channels’ funding outputs are publicly associated with your node’s identity (observers may guess how much funds you have deployed to the Lightning Network), or which outputs went to you when channels get closed. Instant payments! But your funds are tied up in payment channels. If you need those funds for an on-chain payment, you need to close the channel or splice out a payment with the assistance of your channel partner. Lower fees! Payments on Lightning don't require an on-chain transaction fee, but if you route payments through others payment channels, they will charge a proportional fee for the liquidity they provide. However, as other Lightning nodes are competing to transfer your payment for you, this costs much less than an on-chain transaction fee (unless the payment amount is huge). 6. Further reading: How is a node in the middle prohibited from keeping the money in a routed Payment in Lightning network? What are the trade-offs between transacting on LN and Bitcoin mainchain? How are paths found in Lightning Network? ¹ This examples is a so-called “dual-funded” channel. Many channels are funded only by one party upon creation. Channels funded by one party start off with the entire balance on one side and therefore only capable of sending payments but not receiving. Dual funded channels were recently implemented by some Lightning Network implementations for the first time. ² The commitment transactions and justice transaction mechanism are why Lightning needed the transaction malleability fix from segwit. We can only rely on this chain of half-signed, unconfirmed transactions if the transaction id’s of the prior transactions can be predicted reliably.",
      "Lightning allows you to lock coins between two wallets, and then send special transactions between each wallet which only become \"real\" when they are added to the blockchain. But you don't do that, because on-chain costs you more fees, so you keep updating the transactions between each other. Lightning not only makes it possible to send transactions off-chain from A to B, but also from A to B to C etc. Which would make it possible to create one big network, where most transactions happen off chain, you don't need to trust anyone and where all transactions are instantaneous."
    ]
  },
  {
    "question": "Will there be 21 million bitcoins eventually?Every x blocks the mining reward is halved. Will the reward be halved forever such that we never quite reach 21 million bitcoins, or will we reach 21 million bitcoins at some point and will the reward cease to exist altogether? Extra points for pointing to the relevant code!",
    "answers": [
      "People say the total will be 21000000 BTC. ... however: The 1st 210000 blocks each allow creating 50 BTC. The 2nd 210000 blocks each allow creating 25 BTC. The 3rd 210000 blocks each allow creating 12.5 BTC. ... The 10th 210000 blocks each allow creating 0.09765625 BTC. The 11th 210000 blocks each allow creating 0.04882812 BTC, and not 0.048828125 BTC, because only 8 decimals of precision are supported. ... The 33rd 210000 blocks each allow creating 0.00000001 BTC. After that, the reward is 0. If you sum all these numbers together, you get 20999999.9769 BTC. ... however, either due to an oversight or intentionally, the coins created in the genesis block cannot be spent. This leaves us with 20999949.9769 BTC. ... however, due to an early problem in Bitcoin, fixed by BIP30, it was possible to create a coinbase transaction identical to a previous coinbase. This caused the coins created by that older coinbase to be irreversibly \"overwritten\". This happened in block 91842 (overwriting the coinbase of block 91812) and 91880 (overwriting the coinbase of block 91722). Each time, 50 BTC was lost. This leaves us with 20999849.9769 BTC. ... however, the protocol rules allow creating up to the amounts listed above. Due to various bugs and miners experimenting with code, some blocks claim less than allowed. Those coins can never be recovered. Block 124724 tried to intentionally claim 0.00000001 BTC less than allowed, but accidentally also failed to claim the fees, losing 0.01000001 BTC. Between block 162705 and block 169899, 193 blocks claimed less than allowed due to a bug, resulting in a total loss of 9.66184623 BTC. Between block 180324 and block 249185, another 836 blocks claimed less than allowed, resulting in a total loss of 0.52584193 BTC. Block 501726 had no transaction outputs (except a 0-value commitment), losing the entire 12.5 BTC subsidy. Block 526591 didn't claim half of the block reward, losing 6.25 BTC. This leaves us with 20999821.02921183 BTC. ... however, since recently there is a concept of provably unspendable coins. Coins can be sent to an \"address\" which provably burns them (using OP_RETURN). Bitcoin Core tracks these and removes them from its database, so they are easily accounted for. At least 3.71612692 BTC were burned this way. This leaves us with 20999817.31308491 BTC (taking everything up to block 528333 into account) ... However, various wallets have been lost or stolen, transactions have been sent to the wrong address, people forgot they owned bitcoin. The totals of this may well be millions. People have tried to tally known losses up here . https://bitcoin-supply.com/ tracks provably lost bitcoin through publicly available logic. As of 15 March 2022 they tracked 2,823.43062071 BTC lost This leaves us with: ??? BTC.",
      "Neither. The reward eventually ceases, but not at 21 million Bitcoins. Here's the code (edited for clarity and brevity): int halvings = nHeight / 210000; CAmount nSubsidy = 50 * COIN; // COIN is one Bitcoin // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. return nSubsidy >> halvings; (Source.) Note that it cuts the reward in half using the bit-shift operator, which means that eventually it won't be able to reduce the block reward by exactly half. So how many Bitcoins does it end up making in total? 20,999,999.9769 BTC, or 2,310,000 satoshis short of 21 million. (If you want to be a lot of fun at parties, bring this up whenever someone says that the maximum number of Bitcoins is 21 million.) Then there are the various Bitcoins that aren't spendable due to various quirks of the Bitcoin protocol, like the genesis block coinbase , or the duplicated coinbase . [Edit: Or the many other instances of unspendable Bitcoins that Pieter mentions in his answer.]"
    ]
  },
  {
    "question": "What is the Merkle root?The Bitcoin wiki Vocabulary article explains why the Merkle root exists: Every transaction has a hash associated with it. In a block, all of the transaction hashes in the block are themselves hashed (sometimes several times -- the exact process is complex), and the result is the Merkle root. In other words, the Merkle root is the hash of all the hashes of all the transactions in the block. The Merkle root is included in the block header. With this scheme, it is possible to securely verify that a transaction has been accepted by the network (and get the number of confirmations) by downloading just the tiny block headers and Merkle tree -- downloading the entire block chain is unnecessary. This feature is currently not used in Bitcoin, but it will be in the future. How can you check if a transaction has been verified only using Merkle roots? How does that mechanism work?",
    "answers": [
      "The idea (as I understand it) is that the Merkle tree allows for you to verify transactions as needed and not include the body of every transaction in the block header, while still providing a way to verify the entire blockchain (and therefore proof of work) on every transaction. To understand this, first understand the concept of a tree. Consider an 8 transaction block. Imagine each of those 8 transactions at the base of a pyramid: these are called leaves. Put four \"branches\" on the second tier of the pyramid and draw two lines from each of them to the leaves so that each branch has two leaves attached to it. Now join those four branches to two branches on pyramid level 3 and up to one branch (what is called the root of the tree) on the top of the pyramid. (Our tree is growing upside down in this example.) Now we can start to understand the hashing process. Hash the hashes of the \"leaves\" and include that as part of the 2nd level branches that those leaves are attached to (these are called child nodes and parent nodes). Now hash the hashes of those hashes and include that as part of the third level branches. And so on. (And if you had more than 8 transactions, all you need are more levels to the pyramid.) So now you have a root node that effectively has a hash that verifies the integrity of all of the transactions. If one transaction is added/removed or changed it will change the hash of its parent. Which will change the hash of its parent, and so on, resulting in the root node's hash (which is the Merkle root) changing as well. So how does this help us with potentially not having to have the entire blockchain? Because we could verify the transactions as needed. If we have a transaction that claims to have been from block #234133 we can get the transactions for that block, verify the Merkle tree, and know that the transaction is valid. We can do that without necessarily knowing all of the transactions from #234132 or #234134 because we know that the blocks are tamper proof. Even better, if we know where it is in the Merkle tree and we know the hashes of the branches we don't even need all of the transactions from #234132. (There were 868 in that block.) We start with just our transaction and its sibling (if it has one) and calculate the hash of those two and verify that it matches the expected value. From that we can ask for the sibling branch of that and calculate the hash of that and verify it. And continue with this process, up the tree. Which only takes ten verifications for 868 transactions. (That's one of the great things about trees, they can hold a lot of values with only a relatively small number of layers.) How do we know that the source of this data isn't lying to us about the hash values? Because a hash function is one-way, there is no way that a deceptive party could guess a value that would hash with our second-to-last value to create the Merkle root. (Which we know from our verified blockchain.) This reasoning holds further down the tree: there's no way to create a fake value that would hash to our expected value. Another way to think about it, is that even a single alteration of a transaction at the base of the tree, would result in a rippling change to all the hash values of nodes in its branch all the way up to the root's hash value. In short, the Merkle tree creates a single value that proves the integrity of all of the transactions under it. Satoshi could have just included the hash of a big list of all of the transactions in the Bitcoin header. But if he had done that that would have required you to hash the entire list of transactions in order to verify its integrity. With this way, even if there are an extremely large number of transactions the work you need to do (and the number of hashes you need to request/download) in order to verify the integrity is only log(O). [As always, feel free to edit this. This is primarily just inference on my part from looking at the spec.]",
      "\"Figure 7-2. Calculating the nodes in a merkle tree\" from Mastering Bitcoin shows the Merkle Root (H ABCD ) of a list of four transactions: Tx A, Tx B, Tx C, and Tx D: To verify that a transaction—for example, that with hash H K —is a valid transaction (i.e., part of a list of, in this example, 16 transactions with hashes H A , H B , … H P ), one need only perform at most 2*log 2 (N) < N hashes, shown in the Merkle path here: If H K leads to the correct Merkle root, then T K was in the transaction list. And the Merkle path , needed to verify H k corresponds with the Merkle root, only contains 4 hashes in the above example. The Merkle path takes up much less space than storing all the transactions in a block. (In the example above: 4 hashes takes much less space than 16.) This is why SPV is lighter-weight. In this case N = 16, and 2*log 2 (16) = 5.55… is indeed less than 16."
    ]
  },
  {
    "question": "What keeps the average block time at 10 minutes?I've been told \"the network\" sets the difficulty level such that there will be one new block mined every ten minutes. I imagine the rich would instead prefer to keep difficulty as high as possible to prevent other people winning their 50 BTC and causing inflation, whereas the poor would prefer as low a difficulty as possible in order to get a greater share of the BTC available. (By rich and poor, I mean only according to how many BTC someone has.) What's the force saying \"No, forget your petty self-interest and set the difficulty to 10 minutes.\"?",
    "answers": [
      "The bitcoin network rules define which difficulty each block has. This is done through a simple formula that only depends on the block chain itself. This means that if you give me a blockchain with blocks 1 through N, I can tell you with 100% accuracy what the difficulty of block N+1 will need to be, and I can reject any block which has the wrong difficulty. This means it is not really \"the network\" deciding on a difficulty, but really each separate node calculating and enforcing it independently . The actual formula is this: at every block N which is a multiple of 2016, look at the time stamps of the past 2015 blocks, and change the difficulty for what follows to old_difficulty*(2 weeks)/(time the past 2015 blocks took). Additional rules on which time stamps are allowed in blocks prevent cheating (mostly). In short, by using a bitcoin client, you agree to its network rules, and those include the difficulty adjustment.",
      "Each individual client checks the validity of each block it receives. If it receives an invalid block, it ignores that block as if it didn't exist. If you mine a block and other clients ignore it, you don't get your 50 Bitcoins. You only get to keep your 50 Bitcoins if the block you mined becomes a link in the accepted public chain. One of the first things that is checked by the client when it receives a block is that the block meets the difficulty target that it calculates based on how quickly blocks have been generated. If that client doesn't think that block meets the difficulty target that it calculated, then it ignores the block. So you have to mine a block that other clients will accept, or you don't get your 50 Bitcoins."
    ]
  },
  {
    "question": "What is relation between scriptSig and scriptPubKey?Scenario: A is sending 1 BTC to B. scriptSig appears in the Input Script. scriptSig = Here, public key is the Public Key of the sender, A. (this is the public key corresponding to his Bitcoin Address which has some unspent transaction). What is the sig part of scriptSig? scriptPubKey scriptPubKey = OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG pubKeyHash = Hash of the Public Key of Recipient (in our case, B). The sender (A) only has the Bitcoin Address of the recipient (B), so how does he get the pubKeyHash from his Bitcoin Address? Now, this is my understanding so far: Input Script carries information about the \"previous transaction\" of the sender and points to the appropriate \"output\" part of \"previous transaction\" using an index. The output of the previous transaction is the total available balance for the sender (A) which can be claimed to send Bitcoins to the recipient (B). This Input Script is also used to verify that the sender (A) is the actual owner of the Bitcoins held in the referenced output of previous transaction. Output Script tells us, how many bitcoins the Sender wants to Transfer to the Recipient and it also mentions the Bitcoin Address of recipient. Questions: The public Key in scriptSig is different from the public Key in scriptPubKey? How can the signed information of the Sender be verified by the recipient, if they don't share the same Public Key? I have tried understanding the example given on wiki which shows how the script is executed in a stack based manner but could not understand it. I have some more questions, but I think I will ask them in a different question instead of putting it altogether here. Thanks.",
    "answers": [
      "First of all two matching scripts are used in two different transactions, one that transfers funds to an address (Transaction A ) and one that spends those funds (Transaction B ). The scriptPubKey is created by the user that creates Transaction A . It basically adds a claiming condition to the output that is being created. A user may only claim and thus spend the bitcoins associated with the output if he can prove that he owns the output. This is where Transaction B and the scriptSig comes into play. Assuming a user wants to send some funds somewhere. He creates a new transaction, and adds outputs to it until he has enough to cover the desired amount. Now he has to prove that he owns those outputs, which he does by providing the output that is needed to claim them, i.e., the public key matching the address and the signatures with the matching private key. The sender of Transaction A does not yet know the public key, but does know a hash of the public key, because he knows the address he wants to send to. The address is nothing more than the hash of the public key . So the sender now knows all he needs to be able to send the funds to the receiver. When the receiver wants to spend the funds again he provides the input to the scriptPubKey . As you can see the scriptPubKey consists of taking the public key that was pushed on the stack, duplicating it, hashing it and comparing it to the hash of the public key the output was destined for. If they match we still have both the signature and the public key on the stack, which are used by OP_CHECKSIG to see whether the input had a valid signature attached. Take this transaction for example. It claims one output , by providing the public key and the matching signature. It then creates two new outputs and specifies the conditions for the next user to claim them.",
      "I had the same question as well and spent forever trying to understand it and finally cracked it. \"The sender (A) only has the Bitcoin Address of the recipient (B), so how does he get the pubKeyHash from his Bitcoin Address?\" The key is that sender (A) doesn't need to get the pubKeyHash from \"his\" Bitcoin Address because it's not relevant. (I also wondered the same thing!) Think of scriptPubKey happening first. A creates this with B's bitcoin address in place of . That is A's job done. What A has said is \"1 BTC now belongs to B but.... only if B can prove that he is the true owner of the bitcoin address that B provided to me\". Now take A out of the picture. B comes along and in his wallet, he sees this 1 BTC amount show up. So technically B \"owns\" it. But in order for B to spend it, that is send to someone else, B needs to prove that the bitcoin address he gave to A was indeed his. This is where scriptSig comes in. So the is B's responsibility and B knows all this info anyway. After reading lots of articles on this, the developer's documentation explains it the best hands down. https://bitcoin.org/en/developer-guide#transactions You just have to read it slowly a few times. The dev docs also answers your other question of \"What is the sig part of scriptSig?\" ... data Bob signs includes the txid and output index of the previous transaction, the previous output’s pubkey script, the pubkey script Bob creates which will let the next recipient spend this transaction’s output, and the amount of satoshis to spend to the next recipient."
    ]
  },
  {
    "question": "What are bitcoin \"confirmations\"?When I receive bitcoins I see a certain number of \"confirmations\" in the client. What do these mean? Why do most sites make me wait for 6 \"confirmations\" before a purchase will go through?",
    "answers": [
      "Bitcoin confirmations represent the number of blocks in the block chain that have been accepted by the network since the block that includes the transaction. In simpler terms it represents the difficulty of a double spend attack. With zero confirmations no proof of work has been done, so you can't tell if anyone considers the transaction valid. Even with a single transaction it is possible for an attacker to pre compute a single block. With zero or even one confirmation a double spend is very possible since the next block that is solved may confirm a different block instead of the one that has the transaction. That different block my show the coins being spent elsewhere. The odds that a double spend has occurred gets exponentially smaller with each confirmation. An attacker must match the power of the entire bitcoin network to keep up with block creation so as time goes by it becomes increasingly difficult to forge a transaction. It is generally accepted for most transactions that 6 confirmations represent enough security to assure the transition is valid.",
      "If you don't grasp the basic concept, imagine for a second that a network outage split the bitcoin network in half. I could send one transaction giving 30 bitcoins to Abel to one half and one transaction giving those same 30 bitcoins to Fred to the other. Each half would accept that transaction and until the two halves reconnected, you wouldn't know which transaction would be honored tomorrow. Confirmations are simply blocks that have been generated after the block that contains your transaction. Because there is no central authority that can be consulted to be sure a transaction will be committed, recipients use the number of confirmations as a way of protecting against double-spend attacks. The network is always trying to extend the longest chain, and eventually, some chain will win. The deeper the transaction is in the chain, the higher the chance it will win because the network tries very hard not to duplicate efforts. (Because miners want their coinbase transactions to win, they all try very hard to extend the chain most likely to win, which makes sure it does in fact win.) Effectively, the more confirmations, the higher the likelihood that a transaction will remain forever in the public hash chain rather than a conflicting transaction if there was one. At 6 confirmations, it is perhaps one in a billion that a transaction won't be permanent -- and that's if the sender is attempting a double spend attack."
    ]
  },
  {
    "question": "Should I leave the Bitcoin client open?Some people recommended that I leave my Bitcoin client open because it helps the network. Apart from the security implications, why should I do this? I thought that miners were the ones responsible for validating transactions and including them in the blockchain. What role does the Bitcoin client play in the network?",
    "answers": [
      "I would add two points to those already mentioned: First, if you cannot accept inbound connections (because you are behind NAT or have specifically disabled them) you won't really be helping the network. Second, if you are running any version earlier than 0.3.24, you could actually be harming the network, due to a bug in those versions. For some reason that isn't well-understood, the Bitcoin peer-to-peer network is consistently short of available inbound connection slots. This makes it more difficult for newly-started clients to establish a resilient connection to the Bitcoin network. If you can accept inbound connections, leaving your client running helps reduce this problem.",
      "Bitcoin is a peer-to-peer network, which means that the clients not only receive the blocks from other clients, but send out the blocks to other clients. (You may notice the \"connections\" number in the bottom right of the original client. You can think of this as \"peers\" in a torrent client). So yes, by having your client open you are technically helping relay the recent blocks out across the network faster than they would get their otherwise, but there is really no reason to keep a client running all the time. At one point, the client also doubled as a CPU miner, but we are far past the point where that is useful from a security point of view."
    ]
  },
  {
    "question": "What is the difference between kH/s, MH/s, and GH/s?I started mining on a friend's computer and it shows 300 kH/s. But when I research other peoples' hash rates I usually see MH/s. Are these speeds the same as kilobytes and megabytes? Also, when I say 300 kH/s does that mean 300,000 Hashes generated per second?",
    "answers": [
      "Sure: 1 kH/s is 1,000 hashes per second (sometimes mistakenly written KH/s). 1 MH/s is 1,000,000 hashes per second. 1 GH/s is 1,000,000,000 hashes per second. 1 TH/s is 1,000,000,000,000 hashes per second. 1 PH/s is 1,000,000,000,000,000 hashes per second.",
      "Mining capability is measured in the number of attempts to find a block a miner can perform. Each attempt consists of creating a unique block candidate, and creating a digest of the block candidate by means of the SHA-256d , a cryptographic hashing function. Or, in short, a hash . Since this is a continuous effort, we speak of hashes per second or [H/s] . Hash rate denominations 1 kH/s is 1,000 (one thousand) hashes per second 1 MH/s is 1,000,000 (one million) hashes per second. 1 GH/s is 1,000,000,000 (one billion) hashes per second. 1 TH/s is 1,000,000,000,000 (one trillion) hashes per second. 1 PH/s is 1,000,000,000,000,000 (one quadrillion) hashes per second. 1 EH/s is 1,000,000,000,000,000,000 (one quintillion) hashes per second. 1 ZH/s is 1,000,000,000,000,000,000,000 (one sextillion) hashes per second. Conversions 1 MH/s = 1,000 kH/s 1 GH/s = 1,000 MH/s = 1,000,000 kH/s 1 TH/s = 1,000 GH/s = 1,000,000 MH/s = 1,000,000,000 kH/s and so forth SI unit prefixes The denomination of hash rates follows the International System of Units (SI) . Hereby, the prefixes kilo , mega , giga , tera , peta , exa , and zetta each translate to an increase by a factor of one thousand. Please note, that the symbol for kilo is a lower-case \"k\". As \"K\" is the symbol for kelvin , the unit of thermodynamic temperature. The following table from Wikipedia shows an overview of the prefixes, symbols, and factors they correspond to. Inconsistency of kilobyte, megabyte, and gigabyte The computer industry's use of kilobyte, megabyte, and gigabyte is inconsistent with the SI. The Joint Electron Device Engineering Council (JEDEC) has redefined the prefixes kilo, mega and giga in relation with bit and byte as powers of 1024 instead of 1000. Higher prefixes were not redefined by JEDEC. In order to avoid this inconsistency, the International Electrotechnical Commission (IEC) has proposed the binary prefix which uses kibi [Ki], mebi [Mi], and gibi [Gi] for 1024¹, 1024², and 1024³ respectively. The following table from Wikipedia gives an overview."
    ]
  },
  {
    "question": "What effects would a scalable Quantum Computer have on Bitcoin?A scalable quantum computer is a quantum computer that is easy to extend - adding more (q)bits of memory is not a fundamentally hard problem, and will happen. Or, alternatively, that it follows Moore's Law - its memory capacity and speed will increase exponentially over the years with technological advancement (the exponent might be relatively low). Suppose such a Quantum Computer were constructed tomorrow - what would this mean for bitcoin?",
    "answers": [
      "You have a good discussion in: https://bitcointalk.org/index.php?topic=133425.0 Basically, ECDSA is compromised, hashing isn't. With a quantum computer, you could easily deduce the private key corresponding to a public key. If you only have an address, which is a hashed public key, the private key is safe. Anyway, to spend a transaction, you need to send the public key. At that point you are vulnerable, but the attack is not straightforward. In general, quantum computers are not exponentially better than classical computers. You cannot access all the states in the superposition, only global properties. You can read http://www.cs.virginia.edu/~robins/The_Limits_of_Quantum_Computers.pdf to get a good idea of what they can and cannot do.",
      "Worst case scenario: Bitcoin ECDSA algorithm would be broken. Because quantum computers can easily decrypt the private key using the public key, anyone with a quantum computer can extract Bitcoins using the corresponding public key. Bitcoin hashing would become exponentially difficult. There's already a predicted escalation in mining difficulty due to the advent of ASIC, and quantum computers would create a spike in mining difficulty to which ASIC mining effects pale in comparison. In the short run, this would lead to hyperinflation, but the long run effects aren't known at this point. The hashing advantage of quantum computer will be curtailed by block mining limitations. To quote from the Bitcoin wiki: \"The difficulty is the measure of how difficult it is to find a new block compared to the easiest it can ever be. It is recalculated every 2016 blocks to a value such that the previous 2016 blocks would have been generated in exactly two weeks had everyone been mining at this difficulty. This will yield, on average, one block every ten minutes. As more miners join, the rate of block creation will go up. As the rate of block generation goes up, the difficulty rises to compensate which will push the rate of block creation back down.\" This means that the rate of block creation will not be impacted by quantum computers (the increase in key generation is proportional to the increase in difficulty, resulting in an overall mining rate of 1 bitcoin block every 10 minutes), but it will drastically increase the mining difficulty, exponentially more than ASIC miner already have. This gives miners with quantum computers (presumably corporations, government agencies, or other power organizations) a major advantage, to the point of being considered a monopoly, on the bitcoin market. Unless quantum computers either: (a) become publicly available (b) are given their own class for hashing purposes, so as to limit their mining advantage Then miners with access to quantum computers have an unfair mining advantage, which can (and will be) used to manipulate the value and distribution of bitcoins. Furthermore, Quantum computer's hashing power can be used as voting power. If a coalition of people with scalable quantum computers could generate enough hashes to comprise over 51% of the total Bitcoin hashes,they could use that power to greatly manipulate the bitcoin network. As explained in the Bitcoin wiki (\"Weaknesses\") \"An attacker that controls more than 50% of the network's computing power can, for the time that he is in control, exclude and modify the ordering of transactions. This allows him to: Reverse transactions that he sends while he's in control. This has the potential to double-spend transactions that previously had already been seen in the block chain. Prevent some or all transactions from gaining any confirmations Prevent some or all other miners from mining any valid blocks The attacker can't: Reverse other people's transactions Prevent transactions from being sent at all (they'll show as 0/unconfirmed) Change the number of coins generated per block Create coins out of thin air Send coins that never belonged to him With less than 50%, the same kind of attacks are possible, but with less than 100% rate of success. For example, someone with only 40% of the network computing power can overcome a 6-deep confirmed transaction with a 50% success rate. It's much more difficult to change historical blocks, and it becomes exponentially more difficult the further back you go. As above, changing historical blocks only allows you to exclude and change the ordering of transactions. It's impossible to change blocks created before the last checkpoint.\" However: \"Since this attack doesn't permit all that much power over the network, it is expected that no one will attempt it. A profit-seeking person will always gain more by just following the rules, and even someone trying to destroy the system will probably find other attacks more attractive. However, if this attack is successfully executed, it will be difficult or impossible to \"untangle\" the mess created -- any changes the attacker makes might become permanent.\" All this being said, is it possible for a scalable quantum computer (specially, one that is programmed (like ASIC) to hash blocks) to have an exponential advantage over traditional computers, FPGAs, ASICS, etc.? That question is better addressed here: https://cs.stackexchange.com/questions/586/could-quantum-computing-eventually-be-used-to-make-modern-day-hashing-trivial-to There's a lot of mathematics involved, which is a bit above my academic proficiency, but we can derive at least this much: Most of the algorithms quantum computers are famous for efficiently utilizing (Shor's algorithm, Grover's search algorithm) probably can't be used for hashing Bitcoin blocks. One possible exception noted is the collision attack, which if done using Grover's algorithm, could possibly perform better attacks than conventional computers: \"Can quantum-computers perform better collision attacks? Actually I'm not sure about it. Grover's algorithm can be extended, such that if there are t items (that is, preimages), the time to find one is reduced to O(N/t−−−−√). But this gives no collision - running the algorithm again might return the same preimage. On the other hand, if we choose m1 at random, and then use Grover's Algorithm, it is probable that it will return a different message. I'm not sure if this gives better attacks.\" https://cs.stackexchange.com/questions/586/could-quantum-computing-eventually-be-used-to-make-modern-day-hashing-trivial-to In the event that scalable quantum computers manage to corner the Bitcoin network, new code will be released to patch this vulnerability, so while there would be a long-term breakage of the network in the short term, there's nothing to worry about for Bitcoin users in the long term."
    ]
  },
  {
    "question": "Can bitcoins be counterfeited?Traditional currencies have anti-counterfeiting features designed to make them hard to copy, but despite this attempt counterfeit money is a real threat. Since bitcoins are digital, it's trivial to copy them. Does this mean that bitcoins can be counterfeited?",
    "answers": [
      "There is no such thing as a \"bitcoin\" that can be copied. Rather, there is a list of all the transactions that have taken place on the bitcoin network and the order they have taken place. Every client has a copy of this list. Essentially, the only way to counterfeit bitcoins would be to spend them in more than one place. This is called a double-spend attack. However, because of the design of the bitcoin block chain (the list of all the transactions) and the way that list is secured by mining, this requires a tremendous amount of computer power. http://en.bitcoin.it/wiki/How_bitcoin_works#Double_spending See also the question about how mining works What exactly is Mining?",
      "As others have said \"copying a bitcoin\" is trivial but of no value. Your wallet consists of addresses and each of those addresses has a certain value. When your wallet says you have \"20 bitcoins\" it simply an abstraction. Currently your wallet file consists of multiple addresses and the combined value of those addresses according to the bitcoin block chain is 20 bitcoins. When you transfer bitcoins to someone you don't hand over \"a bitcoin\". You submit a transaction to the network. The network makes sure your address is valid and has the proper value. So there is no risk of counterfeiting because there is nothing to counterfeit. There is a risk of double spending. When I transfer bitcoins from me to you the network prevents me from doing it again (and again and again ...). When you submit a a transaction the network verifies that each transaction is valid before including it in the next block. IF hypothetically you had enough computing power you could cheat. You could include your invalid transaction in the block and sign it as valid. The strength of bitcoin comes from the size of the network. Currently ~17Thash/second. An insane amount of computation power. As long as the network remains large enough and diverse enough that one entity can't control 51% there is very little risk of double spending, so long as the recipient waits for a confirmation."
    ]
  },
  {
    "question": "What methods could a government use to shutdown Bitcoin?Let's say that a government decided to shut down the Bitcoin network. What options would they have to achieve this? Would they need to convince other governments? All governments? Let's set as a precondition that they were able to scare away all the developers, so the Bitcoin community could not adjust the software.",
    "answers": [
      "Honestly, I think the best way for the government to shut down Bitcoin would be as a secret project. Simply construct a VLSI ASIC miner built using 40nm/1Gtransistor technology and build 100,000 of them. Effectively make them appear distributed around the world using VPNs, the bandwidth is low. Then execute frequent 51% attacks on the Bitcoin chain to \"unconfirm\" transactions to major sites. Confidence in the Bitcoin system would drop to nothing. Another trick would be to switch the miners off and on unpredictably. If done right, this could lead to hours between confirmations at some times. One can imagine the community responding to this in a coordinated way to develop a workaround. But if you assume subversion and interference in that process, such a response could be avoided. Of course, they could also summarily execute anyone found using Bitcoins. It's effective too, but also pretty unlikely.",
      "I think the best way of analyzing your question would be to break the destruction of the Bitcoin into categories. There is the notion of a hard destruction meaning an attempt is made to physically compromise the Bitcoin network either by a 51% attack or international legislation. And there is the notion of a soft destruction, where attempts are made to De-legitimize the currency through media manipulation and also persistent DDOS attacks on the infrastructure supporting the Bitcoin. In terms of Hard Destruction, I can identify the following scenarios: The NSA or some other entity with both the budget and experience create a VLSI project to both develop and deploy an ASIC design that would result in a 51% attack International regulation is developed that significantly inhibits one's ability to exchange Bitcoins for local currencies. Essentially forcing the Bitcoin underground like a drug cartel A mathematician discovers how to break ECDSA (very unlikely) Innovation results in the Bitcoin being replaced with another currency In terms of Soft Destruction, I can identify the following scenarios: The media alongside a covert multi-government effort conduct several propaganda campaigns to sway public opinion that the Bitcoin is either a massive scam or somehow bad Cumbersome regulations are adopted to monitor and control Bitcoin exchange Persistent DDOS attacks occur on the major exchanges like Mtgox and also the supporting infrastructure One way to attack Bitcoin would be to have large amounts of money alternately pushed into Bitcoin and pulled out of Bitcoin, thereby massively increasing volatility. These market fluctuations could be aggravated by a covert government programme of destructive funding and public dis-information. This would make doing business in Bitcoin more difficult. In all honesty, the Bitcoin is an experiment. We have no idea what will happen and who will oppose it."
    ]
  },
  {
    "question": "Have any cryptography experts vetted the bitcoin source code?Theoretically, bitcoin's open source nature makes it more resistant to bugs and exploits. However, due to the specialized nature of the code, even many programmers don't fully understand the cryptography pieces. Have any well-regarded cryptography experts done an analysis of the code and published their thoughts anywhere?",
    "answers": [
      "\"It looks good to me\" tends to make for a pretty boring paper. Security expert Dan Kaminsky has given talks and written articles about the Bitcoin system. His two main points are that it cannot scale to the number of transactions a payment processing system needs and that it is not as anonymous as many people think. He also wrote , \"As a note, I have a tremendous amount of respect for BitCoin; I count it in the top five most interesting security projects of the decade. Entire classes of bugs are missing. But it's just not an anonymous solution, and the devs will say as much.\"",
      "Brian Warner is a security expert and he has studied the source code. His presentation about Bitcoin is by far the best deep technical explanation I've seen: http://vimeo.com/27177893 There is a brief mention about the security of the source code, embedded in two hours of brilliant explication of the security of the overall system design. Also, the cryptography mailing list hosted by Jack Lloyd is a discussion forum for a wide range of cryptography and security experts. Bitcoin has been discussed several times. The discussions that I have looked at on that list tend to be more about the protocol, the economics, and so forth than about the actual source code. Here is a google search that returns letters from that mailing list that have the string \"Bitcoin\" in: https://encrypted.google.com/search?hl=en&q=site%3Alists.randombit.net%20bitcoin"
    ]
  },
  {
    "question": "What is the longest blockchain fork that has been orphaned to date?The orphaned blocks view from BlockChain.info shows a recent fork of the blockchain (starting with block 173,928) that went four blocks long before being orphaned. Other than the controlled rewind following the Value Overflow bug in August 2010 in which 53 blocks were orphaned, is there a fork of blocks orphaned as long or longer than this one that occurred at 173,928?",
    "answers": [
      "Short answer: 4 [Prior to the March 12, 2013 fork] The Value Overflow incident seems to be the longest ever blockchain split. The problem with blockchain forks is that once they are resolved the only trace they leave is a log entry. To reconstruct the following I used the printblocktree output that theymos gave me in this question and the information from Blockchain.info . As far as I can see from the printblocktree there have been 90 blockchain forks observed by theymos in the blockchainrange [90392-189512]. This dataset has the following forks: 1x block length 4 (starting from block 174161) 1x block length 3 (starting from block 174120) 4x block length 2 (starting from blocks 93669, 174233, 179217 and 179639) 87x block length 1 (starting from blocks 90392, 90676, 90858, 91405, 92094, 93047, 93088, 93619, 93642, 93669, 93670, 93671, 93855, 94671, 98529, 99365, 100740, 101902, 102674, 105401, 109912, 117103, 118553, 120406, 123583, 128501, 130077, 130200, 155180, 157929, 161673, 162257, 163959, 165439, 165519, 166890, 167283, 167620, 167742, 167863, 168920, 169517, 171064, 173494, 174102, 174104, 174121, 174174, 174182, 174185, 174187, 174232, 174242, 174291, 174307, 174313, 174330, 174343, 174414, 174452, 174531, 174593, 174605, 175998, 176210, 176478, 177854, 178119, 178293, 179791, 179890, 180143, 181230, 181591, 181618, 182210, 182321, 183193, 183405, 183500, 183519, 184932, 186561, 187866, 188347, 188682 and 189512) Blockchain.info does have quite a few more orphans in their database, apparently because they connect to a lot more nodes, but their history does not go back as far as theymos' printblocktree. The first blockchain fork that bitcoin.info observed was based on block 142257 since then we observed 540 forks: 2x block length 4 (starting from blocks 174161 and 173927) 4x block length 3 (starting from blocks 174120, 174056, 174050 and 173956) 14x block length 2 (starting from blocks 183873, 179639, 179217, 176924, 175847, 175226, 174233, 174093, 173988, 173985, 173691, 170059, 165518 and 155180) 520x block length 1 (far too many to put them here...) The problem is quite evident: while both see forks, theymos' set has a smaller view of the network and misses or misinterprets forks (the one starting from 155180 is marked as a length 1 fork in the first results and as a length 2 in the second). We cannot be sure that blockchain.info catches all of the forks but we can be pretty certain that there was no fork longer than 4, as the fork would survive longer and would be seen by more nodes.",
      "The March 12, 2013 blockchain fork started with 225430 and so far has reached block 225461, so it is 31 blocks long. Some of those were mined long after the fork supported by v0.7 clients had regained longest chain. At the peak the fork which supported by v0.8 clients was at least a dozen blocks higher meaning transactions that had more than ten confirmations could then have been reverted to unconfirmed status (and if double spent, ignored as if the transaction had never been made."
    ]
  },
  {
    "question": "What are Channel Factories and how do they work?One of the open research questions for Lightning Network is that it will take a massive amount of on-chain transactions to create enough payment channels for all the Lightning Network users. Lately, I've seen the term \"Channel Factories\"¹ pop-up in this context. What are Channel Factories? How do they work? How does that help scale the Lightning Network? ¹ Apparently, the term was introduced by the paper Scalable Funding of Bitcoin Micropayment Channel Networks by C. Burchert, C. Decker and R. Wattenhofer",
    "answers": [
      "What are Channel Factories? In short, Channel Factories are payment channels that can be used to create more payment channels. That sounds weird, but it's really pretty simple: In a regular payment channel, you always have a transaction signed by all participating parties that's ready to commit the current channel balances to the block chain. For example, in a channel between Alice and Bob, this transaction might have two outputs, one paying Alice 0.25 BTC and one paying Bob 0.75 BTC. If this example transaction were broadcast, it would close the payment channel between Alice and Bob. However, it's possible to format the ready-to-commit transaction as a transaction that not only closes the existing payment channel but which also opens a new payment channel. In that case, the same security that allows the initial payment channel to have zero-conf security also extends its security to the second payment channel. The key feature of a regular payment channel is the ability to securely update the state (balance) of the channel many times without creating extra on-chain transactions, so the key feature of a Channel Factory is the ability to securely create and destroy new payment channels without creating extra on-chain transactions. How do they work? At least two people and preferably ten or more get together to create a payment channel (channel factory) deposit transaction. This has the regular payment channel logic that allows all of the participants to spend the money if they all agree, or for a dissatisfied participant to individually withdraw his funds if the other participants become uncooperative. When the deposit transaction has enough confirmations to satisfy all the participants, they update the state of the initial payment channel (channel factory) to create a bunch of non-broadcast payment channel opens between themselves. (The channels need to be between themselves because they each need to ensure none of the bitcoins used to open the channel are spent twice, i.e. double spent.) Since the initial payment channel (channel factory) already has sufficient confirmations, opening the secondary payment channels is instant. The second payment channels can then be used like normal payment channels (e.g. for routable payments Lightning Network) except that when it comes time to close them, the participants have the option of either committing the final state to the block chain or simply updating their balances in the channel factory in order to start a new channel. How does that help scale the Lightning Network? Let's assume we have a bunch of users who all want to open payment channels to each other. For n users, they need to open m channels where m = n(n-1)/2 . For current-generation Lightning Network channel open, they'll probably spend at least two inputs and generate at least three outputs (about 240 vbytes times m channels). For a channel factory, they'll have about n inputs (at 70 vbytes) and n + 1 outputs (at about 25 vbytes) plus 10 vbytes overhead. Here's the savings accounting: This doesn't count channel closing costs, which are harder to calculate since channels may remain open for variable lengths of time. Also not included is the additional savings available from Schnorr signature aggregation---if that should be activated on Bitcoin, it will increase Channel Factory efficiency moderately by decreasing the amount of space used by the inputs. Please note, numbers used here are a rough approximation. Note that although channel factories provide significantly lower costs even for small numbers of participants, where they really excel is at making it cheap to build a dense web of payment channels between users. This will likely significantly improve the quality of service of a widely-distributed Lightning Network by ensuring most paths from spender to recipient stay short, which helps the widely-distributed network further effectively compete with a more centralized network that has short paths between large hub-like entities."
    ]
  },
  {
    "question": "Why was the target block time chosen to be 10 minutes?According to the wiki , 10 minutes was chosen as a 'tradeoff'. Why ten minutes specifically? It is a tradeoff chosen by Satoshi between propagation time of new blocks in large networks and the amount of work wasted due to chain splits. However in the original Satoshi paper , 10 minutes is merely assumed for the purposes of calculating disk space requirements. A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. Is there a discussion elsewhere that explains how the 10 minute block time was arrived at?",
    "answers": [
      "10 minute blocks is simply a compromise. Shorter block time: PRO - Faster 1 confirmation time (to protect from 0-confirm double spend) PRO - Less payout variance for miners (less reliance on large pools) CON - Requires increased bandwidth (inter node communication) CON - More forks, longer forks, and longer re-org time CON - A greater portion of the raw hashpower is wasted, resulting in lower effective security. With a longer block interval target of longer than 10 minutes, the pros and cons would be reversed. The major benefit of a shorter block time is the reduced 1 confirm time. While a quicker block's 1 confirm transaction has less strength than a longer block's 1 confirm transaction it is still better than any block's 0 confirm transaction. The speed of 1st confirm may seem to be a huge benefit but in reality for most low value and time sensitive transactions such as the buying a cup of coffee, paying for a taxi, or using a vending machine, the risk of double spends is very low. Keep in mind that accepting credit cards is not without risk however merchants have long accepted they will face some losses however if those losses are minimal then it can just be seen as a cost of doing business. So many merchants could simply accept 0-confirm transactions without exposing themselves to more risk than they do from credit card fraud. The other factor that diminishes the real world potential of shorter target block intervals is that for many merchants, even \"faster\" confirmation times still isn't fast enough. For a Point of Sale transaction, an average confirmation time of 2 minutes is still significantly longer than what most merchants would consider to be workable. The average credit card transaction takes about 20 seconds (including delays by customer). The entire industry has spent significant resources to shave even a few seconds off. Changes like enabling customer to swipe card, swiping before all items have been rung up, and not requiring signatures on low value are all about shaving a couple seconds off an already quick process and the cost of those changes is considered acceptable in order to slightly improve the efficiency of a checkout. The other factor is that reducing the target interval only reduces the average confirmation time but half of them will be longer and the tail can be very long. Due to the random nature of blocks solutions about 15% of blocks will take longer than 2x the target, 3% longer than 3x the target and >7.5 minutes and about 0.5% will take longer than 4x the target. That uncertainty makes it difficult for a time sensitive business to as a matter of policy wait for confirmations. Having most transactions confirm in 30 seconds but some take minutes is going to lead to customer frustration at the point of sale. If the BTC economy grows large enough we could see expanded use of \"green addresses\" to fill the need for instant acceptance without confirmations. Such services could be provided by major corporations, and backed by insurance against fraud (for a small per transaction fee). This would be a more viable 0-confirm solution than a simple reduction of the block interval. That being said the 10 minute target was probably overly conservative and there are some advantages to a shorter block time.",
      "I found that part of the wiki frustrating too, and I just edited it. I'd appreciate corrections. Here's what I wrote: Ten minutes was specifically chosen by Satoshi as a tradeoff between first confirmation time and the amount of work wasted due to chain splits. After a block is mined, it takes time for other miners to find out about it, and until then they are actually competing against the new block instead of adding to it. If someone mines another new block based on the old block chain, the network can only accept one of the two, and all the work that went into the other block gets wasted. For example, if it takes miners 1 minute on average to learn about new blocks, and new blocks come every 10 minutes, then the overall network is wasting about 10% of its work. Lengthening the time between blocks reduces this waste. As a thought experiment, what if the Bitcoin network grew to include Mars? From the farthest points in their orbits, it takes about 20 minutes for a signal to travel from Earth to Mars. With only 10 minutes between new blocks, miners on Mars would always be 2 blocks behind the miners on Earth. It would be almost impossible for them to contribute to the block chain. If we wanted collaborate with those kinds of delays, we would need at least a few hours between new blocks."
    ]
  },
  {
    "question": "Will deflation destroy Bitcoin?With the limited total quantity of bitcoins, and people losing their wallets constantly decreasing that number, won't rampant deflation destroy Bitcoin?",
    "answers": [
      "There are two potential ways in which monetary deflation can impact a currency: 1. Usability Most modern currencies have a minimum unit, such as the penny in the United States, or the yen in Japan. If these currencies existed in only finite quantities, then as the economy grew and/or physical money was lost, there might eventually be too few of these units in circulation to allow normal commerce. Imagine if, for example, the U.S. dollar became so rare that you could buy a car with a single U.S. penny. How would you buy a loaf of bread? Bitcoin, however, does not have this problem because unlike the physical currencies of most countries, bitcoins are infinitely divisible. Even if only one bitcoin remained, it would be sufficient to run a substantial economy on, based on the ability to use tiny fractions of it like the Satoshi . If even the Satoshi were to become too highly valued/unavailable for commerce, the Bitcoin protocol could be updated to allow even smaller denominations. So the usability of bitcoins is safe from the effects of deflation. 2. Broader economic consequences from deflation Many economists believe that deflation is bad for an economy because people will be less likely to invest their money if they can \"earn\" increased value simply by holding on to it. Why buy something today, the argument goes, if you could buy it for half as much in a few months time? Also, taking out loans becomes very difficult, because to be practical they have to have negative interest rates and then why would anyone loan out money in the first place? However, there is good reason to believe that deflation might not have such a negative effect on Bitcoin. For one, Bitcoin is unlikely to become the only currency in the world economy, so investments, loans, etc. can simply be denominated in another currency. But even more importantly there are several concrete examples from history of strictly deflationary currencies. For example, the Iraqi \"Swiss\" dinar was a currency that ceased being printed after the first Gulf War, and was left in use only by the Kurdish regions of the country. With a finite number of \"Swiss\" dinars in existence, and some being lost or damaged over time, this left the currency in precisely the same state as Bitcoin. Since it was no longer backed by a government, many economists expected the currency and its economy to collapse. Instead, the Kurdish economy continued largely as normal for 13 years, and the \"Swiss\" dinar even appreciated against the \"Saddam\" dinar that was meant to replace it. Rick Falkvinge also raises another excellent point regarding deflationary economies. If, as economists expect, people would decline to buy something today as opposed to next year for half price, then it should be the case that no one ever buys computers, right? But in fact, the computer industry thrives despite this continued trend of \"whatever something costs today, it will cost a fraction of that within a few years\". Ultimately, this is a question for economists to duke out, and you can find more information about how different economic schools approach the problem here . Suffice it to say, this cannot be considered a crippling fault in Bitcoin as a technology.",
      "No. There are many things that could destroy bitcoin, but deflation is not one of them. While deflation is problematic for a currency backed by debt (as most, if not all, national currencies are), it is not an issue for commodity currencies (and bitcoin is most similar to commodity currencies). The deflation argument goes something like this: everyone, believing that the value of the currency is going to rise will simply hold the currency and never spend it. But this argument completely ignores the need for diversification (would you put all of your wealth into bitcoin?). It also ignores the fact that if people decided to put all their wealth into bitcoin and save everything, they would still need to eat and buy things at some point. They would have no choice but to spend it. And, if everyone actually did invest everything into bitcoin, it would create a bubble in the value that would eventually deflate and teach everyone why diversification is good. The argument also ignores the fact that hoarding itself is not bad...when people hoard bitcoin, they cause the value to rise and that creates wealth that others can use for their needs. In a way, hoarding is an investment in the broad bitcoin economy."
    ]
  },
  {
    "question": "Is there any way to track an individual bitcoin (or satoshi)?For example, if I wanted to \"collect\" important bitcoins is there any way to track a coin rather than a series of transactions? If I wanted one of the bitcoins from the infamous \" Bitcoin pizza \" purchase, for example, is there any way to do so? Perhaps the question I should be asking is more like \"Do bitcoins themselves even exist or just the records of transactions?\"",
    "answers": [
      "Here is a possible schema describing transactions from two addresses A and B that contain initially 50 BTC each: (A) 50 btc --tx1-----------------------> 25 btc (C) \\ `-> 25 btc (D) --. \\ tx3--> 50 btc (*) / .-> 25 btc (E) --' / (B) 50 btc --tx2-----------------------> 25 btc (F) There are three transactions here, and they mention only values: those transactions are stored in the block chain like: tx1 : (input on A: 50BTC; output on D: 25BTC, output on C: 25BTC) tx2 : (input on B: 50BTC; output on E: 25BTC, output on F: 25BTC) tx3 : (input on D: 25BTC, input on E: 25BTC; output on *: 50BTC) Only global amounts are involved, not individual satoshis . Could you tell where each of the satoshis in * came from? A or B ? Just impossible. Conclusion: There is no such thing as individual satoshis , they don't have identities in the Bitcoin framework. (And it's the same, or even worse, for bitcoins . An individual bitcoin is not well defined. It might be a grouping of smaller amounts in the same place (wallet), or at the same address, or in the same transaction, but at a given point in time .) It is however possible to track money flows between addresses, which may “dilute” into other flows, as illustrated in this answer .",
      "I've been playing with Gavin's \"bitcointools\" ( again ) to track what happened to the famous \"pizza\" Bitcoins. It turns out that rather than being rare collector's items, the 10,000 BTC exchanged for two pizzas have spread out to over a million different Bitcoin addresses since buying the pizzas, not counting the dilute fragments that ended up in transaction fees. As of block 166149, on Feb 10th 2012, 1,037,382 addresses have held the pizza coins since they were spent. 174,584 of those still hold pizza coins (the others may or may not be empty addresses, since it's possible to have two different transactions output to the same address without the coins becoming mixed together. In other words it's possible to have \"pizza coins\" and \"non pizza coins\" in the same address and still be able to tell which are which. Of the approximately 600k addresses which are currently holding funds, around 29% of them contain pizza coins. The shortest chain of transactions from the pizza purchase to currently held pizza coins has length 9, and the longest has length 6,723. There is no currently unredeemed output which contains 100% pure pizza coins. All the pizza coins have been diluted somewhat with other coins. The purest remaining are these 100 BTC which are 90.7276% pure pizza coin, and just 11 transactions separated from the pizza transaction. (The most recent 9 transactions each only have 1 input, so it's easy to follow it back that far. In the next transaction back the pizza coins came from both the last but one input, worth 4223 BTC, and 5th from last input, worth 5777. Together those 2 inputs make up the full 100% pure 10k BTC pizza coins. The other inputs in this big transaction, worth 1022 BTC in total are the only non pizza coins introduced. 10000 * 100 / 11022 = 90.7276%, the purity). I also checked my wallet to see if I was holding any pizza coins. 8 of my addresses are holding pizza coins, but very diluted. My 'strongest' has a purity of 1.1760%, and is a tiny withdrawal I made from MtGox in October 2011. Finally, here's some data showing the month-by-month spread of the pizza coins: pizza payment of 10000.00000000 BTC to 17SkEw2md5avVNyYgj6RiXuQKNwkXaxFyQ is in block 57043 -block --date-- --total-- ---used--%total- -active---%total---%used- 58815 May 2010 4 2 (50.00%) 4 100.00% 200.00% 63561 Jun 2010 4 2 (50.00%) 0 0.00% 0.00% 71436 Jul 2010 26 8 (30.77%) 24 92.31% 300.00% 77452 Aug 2010 34 10 (29.41%) 13 38.24% 130.00% 82997 Sep 2010 138 37 (26.81%) 106 76.81% 286.49% 88892 Oct 2010 2,016 265 (13.14%) 1,898 94.15% 716.23% 94801 Nov 2010 6,295 577 ( 9.17%) 4,428 70.34% 767.42% 100409 Dec 2010 7,510 835 (11.12%) 1,464 19.49% 175.33% -block --date-- --total-- ---used--%total- -active---%total---%used- 105570 Jan 2011 13,271 1,540 (11.60%) 6,150 46.34% 399.35% 111136 Feb 2011 19,055 2,632 (13.81%) 6,423 33.71% 244.03% 116038 Mar 2011 42,027 5,605 (13.34%) 24,341 57.92% 434.27% 121126 Apr 2011 69,544 9,085 (13.06%) 29,727 42.75% 327.21% 127865 May 2011 123,997 26,032 (20.99%) 57,911 46.70% 222.46% 134121 Jun 2011 249,138 54,047 (21.69%) 132,348 53.12% 244.88% 139035 Jul 2011 382,845 93,928 (24.53%) 146,156 38.18% 155.60% 143408 Aug 2011 494,140 108,340 (21.92%) 126,134 25.53% 116.42% 147565 Sep 2011 589,942 119,491 (20.25%) 111,178 18.85% 93.04% 151314 Oct 2011 680,787 131,370 (19.30%) 105,320 15.47% 80.17% 155451 Nov 2011 780,292 142,302 (18.24%) 114,013 14.61% 80.12% 160036 Dec 2011 885,172 156,321 (17.66%) 120,631 13.63% 77.17% -block --date-- --total-- ---used--%total- -active---%total---%used- 164780 Jan 2012 998,087 170,082 (17.04%) 136,985 13.72% 80.54% 166149 Feb 2012 1,037,382 174,584 (16.83%) 54,346 5.24% 31.13% Edit: I just found these 100% pure allinvain coins - undiluted after 24 hops from when 25k BTC was stolen from his computer . Edit 2: I don't mean to imply that the allinvain coins haven't been thoroughly looted. They have touched 755,796 different addresses since being stolen and are currently sitting in 109,235 different addresses, including 8 from my own personal wallet. The exact same 8 as have pizza coins in them, it turns out."
    ]
  },
  {
    "question": "How does change work in a bitcoin transaction?It seems that when you send a bitcoin transaction, all the coins in the sending address are spent in that transaction, divided into the amount that you intended to send, and \"change\", which goes back to you, but at another (newly created) receiving address. That makes it a bit difficult to track your balance on block explorer (especially since the new receiving address does not seem to be displayed in the Bitcoin client anywhere). Does it have it have to work like this, or is this a specific implementation detail of the client software? Also, do you have to wait for change to be confirmed before you can spend it again?",
    "answers": [
      "First, let's clarify the difference between accounts and addresses. \"Accounts\" are used for the convenience of people to track their funds. This is primarily used to track the source of funds. Since this is just for your tracking, you can move Bitcoins from one account to another just by moving a number from one column to another. No transactions are needed. (This is like when you know you owe your son $25 for allowance, and you have $200 budgeted for groceries.) \"Addresses\" are used to receive Bitcoins in transactions. The coins are sent to an address. The client associates each address with an account and adds received funds to that account. This is simply done for convenience to allow people to track indirectly which address funds were sent to. But you can have any number of addresses associated with the same account. Change comes from the way Bitcoins are spent. To spend a certain number of Bitcoins, you must pull in Bitcoins from transaction outputs to accounts you control. Note that in the spending part, it doesn't matter what address this is or what account that address is associated with. When you spend Bitcoins from a particular account, that just means you debit that account for the amount you send. It doesn't mean the funds come from addresses associated with that account. Remember, the association between addresses and accounts is for receiving only, not sending. (Like when you spend money on groceries, it's not like you have specific bills for groceries. You just have an amount budgeted.) So when you pull in transaction outputs, you form a pile of Bitcoins big enough for the number you are trying to send. Usually, it won't be exact since you must claim an entire output. So the excess forms the 'change'. Since there is no address associated with sending Bitcoins, there is no particular address the change should be sent to. So, to preserve anonymity, the client creates a new one just to receive the change from this transaction. Since this address isn't really associated with an account and shouldn't be used to receive any more Bitcoins (because that would senselessly tell people the same recipient got the coins as got this change) the client does not display it. Because the client manages coins in a particular way, it doesn't make sense to try to view coins it is managing with any kind of explorer. It's specifically trying to obscure the fact that all the coins are related. Those kinds of services are intended to monitor recieved funds, not managed funds.",
      "The information in David's answer is correct, but it may not answer the actual question -- it's unclear whether the question is about change in general, or specifically sending change to a new address. If the latter, nothing needs to be added. If, however, the question was about the practice of change in general, then yes, it is necessary. The reason for this is that an output, when used as an input, must be spent in its entirety. Say someone sends you 10 BTC, that 10 BTC is a single output. You cannot spend part of that coin, the same way you couldn't slice off a part of a physical coin and have it maintain its value. The reason for this is that an output is actually a script, and to spend an output you simply broadcast the solution to this script. That output, in its entirety, becomes an input -- and if you were to not include change, the difference between the inputs and outputs would all go to transaction fees. What is client-specific is how to handle this change: the Satoshi client sends it to a new address, while other clients may simply send the change back to one of the output addresses. The change is an output like any other, which means that you do need to wait for confirmations -- but you can still use that change to send another transaction immediately, you'll just need to wait for the first transaction to confirm before the second one can."
    ]
  },
  {
    "question": "What's the difference between a wallet and an address?Bitcoin seems to have the concept of a wallet and an address. Are they the same thing? If not, how do they differ?",
    "answers": [
      "Addresses are public-key hashes of an asymmetric key pair An address represents a hash of a public key of an asymmetric key pair .¹ The owner of the key pair can use the private key to sign transactions or messages (for example in order to prove ownership). Only by using the correct private key a valid signature may be created, which then anyone can verify as valid by using the associated address (which, again, represents the public key). Wallets are an abstract concept, a \"keyring\" A wallet is an abstract construct, which contains the set of public and private key pairs randomly generated for the user. In a deterministic wallet, the keys are derived from a passphrase (a specific seed, masterkey or password) instead of a random seed. Essentially, it corresponds to a keyring in the cryptographic sense. The Bitcoin client software abstracts the wallet for the user such that it checks each of the addresses contained in the wallet, whether there are any balances ( transaction outputs ) associated in the blockchain with them. It sums the funds up and presents them as a single total balance. Underlying, however, these balances are stored publicly in the blockchain (that's right, the wallet doesn't contain your coins, it just allows you to spend them). They are split up to numerous addresses and transaction outputs: Address #15521² has 3 BTC in transaction output 1 Address #23414 has 1.2 BTC in transaction output 1 0.7 BTC in transaction output 2 ... Everyone can see them, however, usually can't determine the identity of the owner. ¹ To be more accurate an address is a Base58-encoded hash of the public key. ² Of course, real addresses actually are alphanumeric strings with up to 34 characters.",
      "A wallet and an address are not the same thing. An address is a Bitcoin public key to which transactions can be sent. This concept is present in the Bitcoin protocol itself. A wallet is a collection of private keys that correspond to addresses. A private key is necessary to spend from an address. The concept of a wallet is present only in Bitcoin clients. The format of the wallet is stereotypically a text file on disk, but may differ between clients and have highly important features such as encryption and address labeling. Terminology-wise, one sends Bitcoin to or receives it from an address and one encrypts, exports, backs up, and imports their wallet ."
    ]
  },
  {
    "question": "How can I run bitcoind in pruning mode?I read this comment : You could consider running a pruning node, which is practically the same as a full node (including security), except it throws away some of the old history. Version 0.11 will make that possible But I can't find details of how to run bitcoind in pruning mode. Questions on this site seem not to be recent enough to yield answers, and I also don't see a pruning mode in the bitcoind parameters . Any insights into this?",
    "answers": [
      "By setting the -prune option. -prune= Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain. (default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, 550 = automatically prune block files to stay under the specified target size in MiB) The feature was originally introduced in Bitcoin Core 0.11 (see release notes ). As of version 0.12 pruning can be used while running a wallet. But note the -txindex and -rescan caveats. Also note that the specified MiB will only include the block files and some undo space. Besides that you will also need some disk space for the chain state and block index databases.",
      "There are more details in the release notes . To enable block pruning set prune= on the command line or in bitcoin.conf , where N is the number of MiB to allot for raw block & undo data. A value of 0 disables pruning. The minimal value above 0 is 550. Where 550 is the size in MB you want the node to occupy in your system. The bitcoin.conf is in the Bitcoin data directory , you can create a text file by the name there, if there isn't a bitcoin.conf yet."
    ]
  },
  {
    "question": "Import wallet.dat into a new Bitcoin-Qt clientI had Bitcoin-Qt on my computer with several bitcoins in my wallet, using Vista. Then my computer crashed. Finally I was able to get my computer fixed and download a new version of Bitcoin-Qt. Now I would like to import my original wallet.dat from the old client which was encrypted into an new version of Bitcoin-Qt. How do I do that?",
    "answers": [
      "First, close the Bitcoin-Qt client. Then you have to locate your Bitcoin folder. For Windows, it should be here: %APPDATA%\\Bitcoin and for Linux: ~/.bitcoin In that folder, there should be a wallet.dat file. If you currently have no bitcoins in your wallet, you can just delete that file and replace it with your backup. If you have some bitcoins in this wallet as well, backup that wallet file as well, or send all the coins to an address from your backed up wallet. When you placed the other wallet.dat file in place, you should run Bitcoin-Qt with the -rescan option. Here's how to do that in Windows: Go to C:\\Program Files (x86)\\Bitcoin using Windows Explorer. In that folder, hold shift and right-click and select Open command window here ( picture ). In the command prompt, type bitcoin-qt.exe -rescan and hit enter ( picture ). Now Bitcoin-Qt should start and rescan the blockchain to calculate the balances of the addresses in your wallet.dat file. (Source for pictures: cant see bitcoin after restore of backup )",
      "For OSX: Backup your original wallet.dat file ( ~/Library/Application Support/Bitcoin/wallet.dat by default). This contains the private keys for your bitcoins. If you lose it, you lose your coins. Install Bitcoin Core on a machine with 100s of gigabytes of free space. Allow it to download the blockchain. This could take days. Replace the wallet.dat file on the new machine with your old one. Start Bitcoin Core on the new machine with the rescan flag, to scan the blockchain for your newly imported bitcoin. You can do this with the command line /Applications/Bitcoin-Qt.app/Contents/MacOS/Bitcoin-Qt -rescan . This can also take a long time (hours). Your wallet should now be imported and working on the new computer."
    ]
  },
  {
    "question": "How do you get a Bitcoin Public Key from a Private KeyHow do I, in extreme specificity, convert a given private bitcoin key into a public bitcoin key (Talk to me like I'm 5 and I have to do this step by step or the evil witch will cook me alive in her oven). NOT where can I find a program that will do this, but if I were to do it myself, what would I do? Private Key: 18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725 supposedly results in the public key: 0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6 Others have asked how to get private to public, I haven't seen a really specific answer, just more general direction, but no answers explain all the variables. I understand this is rather complex and if a given individual thinks its too much work to answer, I totally respect that. Note: I do not care for the Bitcoin Address, just interested in Privatekey to Publickey and the specifics of how. Variables such as the \"a\" and \"b\" in the ECDSA Curve Algorithm are already designated by Bitcoin (according to https://en.bitcoin.it/wiki/Secp256k1 ). the \"base point\" aka \"G\" is also specified on that page. the \"private exponent\" or \"k\", I have yet to find. Some of these variables are supposedly \"random\" which appears to be false as every generator that you can put a private key into seems to always spit out the same public key...so.... all the variables are either already preset or are derived from the private key. Thanks for any help on this. I've been trying to research and understand this for days, but it seems sometimes I don't understand the terms and or notations, but I think I've gotten past that and now am just missing parts of the equation. EDIT ADD: This is the previous stated private key in Decimal: 11253563012059685825953619222107823549092147699031672238385790369351542642469 This is the previous stated public key (x and y values) in decimal: 36422191471907241029883925342251831624200921388586025344128047678873736520530 20277110887056303803699431755396003735040374760118964734768299847012543114150 All I want to know is how to go from that private key to the public key. Supposedly it is a simple equation that doesn't involve bit shifting or xor etc. It may include \"point multiplication\" (which I don't see how you can multiply a point defined as having both an x and a y). No one seems to understand the intricacies of this. Do you guys suggest I actually offer some fraction of a bitcoin to whoever explains it clearly?",
    "answers": [
      "I'll try answering this again in a different way, using small numbers to keep it readable. convert the private key to binary representation, so decimal number 105, which is 0x69 in hex, becomes 01101001. calculate this list of points, by repeatedly doubling the Generator point G: 1*G 2*G = G+G 4*G = 2*G + 2*G 8*G = 4*G + 4*G 16*G = 8*G + 8*G 32*G = 16*G + 16*G 64*G = 32*G + 32*G write the bits of the private key next to this list like this: privkey pointlist 1 1*G 0 2*G 0 4*G 1 8*G 0 16*G 1 32*G 1 64*G now start adding only those points which hava a 1 written next to them. 9*G = 1*G + 8*G 41*G = (9+32)*G = 9*G + 32*G 105*G = (41+64)*G = 41*G + 64*G now you have calculated the public key for privatekey 105 by using only point doubling and point adding operations. The actual value will be: (0xf219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63, 0x4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1) The public key will then be in one of two formats: full, this is a 65 byte number, starting with a byte 0x04 compressed, this is a shorter form, 33 bytes, starting with either 0x02 or 0x03. The full public key is 0x04, followed by 32 bytes of the x-coordinate, followed by 32 bytes of the y-coordinate. The compressed public key is 0x02 or 0x03 depending on whether the y-coordinate is an even or odd number, followed by 32 bytes of the x-coordinate. Then some more notes on your question: Some older texts used to refer to scalar point multiplication, as exponentiation, that is why sometimes the private key is referred to the private exponent. the parameters of the curve were chosen randomly once. meaning that the designers of the secp256k1 curve tried to unsuccessfully convey that there is no specific structure to this curve. Meaning that the NSA could or could not have put a mathematical backdoor in the curve parameters. when using this curve and generating your public key, -you- have to choose your private key randomly, in a way that it is impossible for anyone to guess it. the generateor G is a specific point on the elliptic curve, defined in the secp256k1 curve.",
      "Here's a self-contained Python script that does the conversion. You can check its work by comparing to entering your private key as the \"Secret Exponent\" at Brainwallet . I took the script from this Bitcointalk thread and stripped out unnecessary stuff (like the code to use the public key to sign a message and verify that signature). Converting the Python to instructions for a human is left as an exercise to the reader (although I'd argue that in a scenario like this Python code, with appropriate documentation, is just fine as instructions to a human). Note that it's entirely possible to compute this with pen and paper, but it could take a while, and you're likely to make a mistake, due to having to deal with such enormous numbers. Also note that there are no individual operations here that are much more complicated than you'd learn in primary/elementary school. There's basic comparisons < > == , arithmetic + - * , division where you care about the quotient / , remainder % , or both divmod , and bitwise AND ( & , which is pretty easy if you work in hex; or can be replicated with arithmetic). I don't think a (non-genius) 5 year old could actually do it (sorry, the evil witch wins this round), but I think an average adult with enough patience could learn the math needed in nearly no time (with the Python script as a..well..script, to follow). Actually calculating even one public key without the aid of electronic computing devices could take a very long time, however (at a guess: years). #! /usr/bin/env python # python 2.x class CurveFp( object ): def __init__( self, p, a, b ): self.__p = p self.__a = a self.__b = b def p( self ): return self.__p def a( self ): return self.__a def b( self ): return self.__b def contains_point( self, x, y ): return ( y * y - ( x * x * x + self.__a * x + self.__b ) ) % self.__p == 0 class Point( object ): def __init__( self, curve, x, y, order = None ): self.__curve = curve self.__x = x self.__y = y self.__order = order if self.__curve: assert self.__curve.contains_point( x, y ) if order: assert self * order == INFINITY def __add__( self, other ): if other == INFINITY: return self if self == INFINITY: return other assert self.__curve == other.__curve if self.__x == other.__x: if ( self.__y + other.__y ) % self.__curve.p() == 0: return INFINITY else: return self.double() p = self.__curve.p() l = ( ( other.__y - self.__y ) * \\ inverse_mod( other.__x - self.__x, p ) ) % p x3 = ( l * l - self.__x - other.__x ) % p y3 = ( l * ( self.__x - x3 ) - self.__y ) % p return Point( self.__curve, x3, y3 ) def __mul__( self, other ): def leftmost_bit( x ): assert x > 0 result = 1L while result <= x: result = 2 * result return result / 2 e = other if self.__order: e = e % self.__order if e == 0: return INFINITY if self == INFINITY: return INFINITY assert e > 0 e3 = 3 * e negative_self = Point( self.__curve, self.__x, -self.__y, self.__order ) i = leftmost_bit( e3 ) / 2 result = self while i > 1: result = result.double() if ( e3 & i ) != 0 and ( e & i ) == 0: result = result + self if ( e3 & i ) == 0 and ( e & i ) != 0: result = result + negative_self i = i / 2 return result def __rmul__( self, other ): return self * other def __str__( self ): if self == INFINITY: return \"infinity\" return \"(%d,%d)\" % ( self.__x, self.__y ) def double( self ): if self == INFINITY: return INFINITY p = self.__curve.p() a = self.__curve.a() l = ( ( 3 * self.__x * self.__x + a ) * \\ inverse_mod( 2 * self.__y, p ) ) % p x3 = ( l * l - 2 * self.__x ) % p y3 = ( l * ( self.__x - x3 ) - self.__y ) % p return Point( self.__curve, x3, y3 ) def x( self ): return self.__x def y( self ): return self.__y def curve( self ): return self.__curve def order( self ): return self.__order INFINITY = Point( None, None, None ) def inverse_mod( a, m ): if a < 0 or m <= a: a = a % m c, d = a, m uc, vc, ud, vd = 1, 0, 0, 1 while c != 0: q, c, d = divmod( d, c ) + ( c, ) uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc assert d == 1 if ud > 0: return ud else: return ud + m # secp256k1 _p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL _r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L _b = 0x0000000000000000000000000000000000000000000000000000000000000007L _a = 0x0000000000000000000000000000000000000000000000000000000000000000L _Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L _Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L class Public_key( object ): def __init__( self, generator, point ): self.curve = generator.curve() self.generator = generator self.point = point n = generator.order() if not n: raise RuntimeError, \"Generator point must have order.\" if not n * point == INFINITY: raise RuntimeError, \"Generator point order is bad.\" if point.x() < 0 or n <= point.x() or point.y() < 0 or n <= point.y(): raise RuntimeError, \"Generator point has x or y out of range.\" curve_256 = CurveFp( _p, _a, _b ) generator_256 = Point( curve_256, _Gx, _Gy, _r ) g = generator_256 if __name__ == \"__main__\": print '=======================================================================' ### set privkey # wiki #secret = 0xE9873D79C6D87DC0FB6A5778633389F4453213303DA61F20BD67FC233AA33262L # question secret = 0x18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725L ### print privkey print 'secret', hex(secret) ### generate pubkey pubkey = Public_key( g, g * secret ) ### print pubkey print 'pubkey', hex(pubkey.point.x()), hex(pubkey.point.y()) print '=======================================================================' See also an even-more-stripped-down version written in C#. class CalcPub { public static void Main() { var p = BigInteger.Parse(\"0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\", NumberStyles.HexNumber); var b = (BigInteger)7; var a = BigInteger.Zero; var Gx = BigInteger.Parse(\"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\", NumberStyles.HexNumber); var Gy = BigInteger.Parse(\"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\", NumberStyles.HexNumber); CurveFp curve256 = new CurveFp(p, a, b); Point generator256 = new Point(curve256, Gx, Gy); var secret = BigInteger.Parse(\"18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725\", NumberStyles.HexNumber); Console.WriteLine(\"secret {0}\", secret.ToString(\"X\")); var pubkeyPoint = generator256 * secret; Console.WriteLine(\"pubkey {0}{1}\", pubkeyPoint.X.ToString(\"X\"), pubkeyPoint.Y.ToString(\"X\")); } } class Point { public static readonly Point INFINITY = new Point(null, default(BigInteger), default(BigInteger)); public CurveFp Curve { get; private set; } public BigInteger X { get; private set; } public BigInteger Y { get; private set; } public Point(CurveFp curve, BigInteger x, BigInteger y) { this.Curve = curve; this.X = x; this.Y = y; } public Point Double() { if (this == INFINITY) return INFINITY; BigInteger p = this.Curve.p; BigInteger a = this.Curve.a; BigInteger l = ((3 * this.X * this.X + a) * InverseMod(2 * this.Y, p)) % p; BigInteger x3 = (l * l - 2 * this.X) % p; BigInteger y3 = (l * (this.X - x3) - this.Y) % p; return new Point(this.Curve, x3, y3); } public override string ToString() { if (this == INFINITY) return \"infinity\"; return string.Format(\"({0},{1})\", this.X, this.Y); } public static Point operator +(Point left, Point right) { if (right == INFINITY) return left; if (left == INFINITY) return right; if (left.X == right.X) { if ((left.Y + right.Y) % left.Curve.p == 0) return INFINITY; else return left.Double(); } var p = left.Curve.p; var l = ((right.Y - left.Y) * InverseMod(right.X - left.X, p)) % p; var x3 = (l * l - left.X - right.X) % p; var y3 = (l * (left.X - x3) - left.Y) % p; return new Point(left.Curve, x3, y3); } public static Point operator *(Point left, BigInteger right) { var e = right; if (e == 0 || left == INFINITY) return INFINITY; var e3 = 3 * e; var negativeLeft = new Point(left.Curve, left.X, -left.Y); var i = LeftmostBit(e3) / 2; var result = left; while (i > 1) { result = result.Double(); if ((e3 & i) != 0 && (e & i) == 0) result += left; if ((e3 & i) == 0 && (e & i) != 0) result += negativeLeft; i /= 2; } return result; } private static BigInteger LeftmostBit(BigInteger x) { BigInteger result = 1; while (result <= x) result = 2 * result; return result / 2; } private static BigInteger InverseMod(BigInteger a, BigInteger m) { while (a < 0) a += m; if (a < 0 || m <= a) a = a % m; BigInteger c = a; BigInteger d = m; BigInteger uc = 1; BigInteger vc = 0; BigInteger ud = 0; BigInteger vd = 1; while (c != 0) { BigInteger r; //q, c, d = divmod( d, c ) + ( c, ); var q = BigInteger.DivRem(d, c, out r); d = c; c = r; //uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc; var uct = uc; var vct = vc; var udt = ud; var vdt = vd; uc = udt - q * uct; vc = vdt - q * vct; ud = uct; vd = vct; } if (ud > 0) return ud; else return ud + m; } } class CurveFp { public BigInteger p { get; private set; } public BigInteger a { get; private set; } public BigInteger b { get; private set; } public CurveFp(BigInteger p, BigInteger a, BigInteger b) { this.p = p; this.a = a; this.b = b; } }"
    ]
  },
  {
    "question": "What happens if two miners mine the next block at the same time?The process of mining as described in the answer to this question is simultaneously repeated by multiple miners. Is it possible for two miners to find the next block at the same instant? If it is, what happens if they do?",
    "answers": [
      "Yes, it is possible, and you can actually follow \"orphaned blocks\" here: https://blockchain.info/orphaned-blocks Bitcoin clients always trust the longest chain, so if two blocks is mined on the same time, it's up to (51% of) the miners to decide which is going to be 'accepted' and which is going to be worthless. This is one of the reasons why you shouldn't trust only a few confirms, as the confirms could be a orphaned blockchain. After \"enough\" confirms, everyone will mine on the \"correct\" blockchain, because any work(mining) on a orphaned blockchain is waste of power (unless your trying to perform a 51% attack).",
      "What Nicolai said is not completely right. The network would decide which one is the main chain according to the following block mined. Let's assume that block A and B are mined at almost the same time. The miners would accept the first block that was broadcast to them, so there would be some miners accept A and others accept B, it doesn't matter whether A/B is accepted by 51% or more miners or not. Miners accepting A would try to mine the next block on top of A, while other miners accepting B would try to mine the next block on top of B. If next block to be found is on the top of A, then miners mining on the B will turn to the A chain, which is the main chain. BTW, the block B is named as an orphaned block, you can find more on the https://blockchain.info/orphaned-blocks . Of course, there may be a circumstance that the next block is mined at roughly the same time both on top of A and on top of B, then the process mentioned above would circulate again till the problem gets solved. Now you can understand why the new blocks won't be spendable until at least 120 blocks have been built on top of it in a chain."
    ]
  },
  {
    "question": "ECDSA: (v, r, s), what is v?Deterministically signing a Tx with RFC6979 returns v, r, s , where r and s are the 2 values used in standard ECDSA signatures. v = 27 + (y % 2) , so 27 + the parity of r , as pybitcointools indicates . So for even r , we get v = 27 , odd r we get v = 28 . How is the value of v (27 or 28) important? Why is it necessary to have a v value? Also, why is it 27 ?",
    "answers": [
      "This has nothing to do with RFC6979, but with ECDSA signing and public key recovery. The (r, s) is the normal output of an ECDSA signature, where r is computed as the X coordinate of a point R, modulo the curve order n. In Bitcoin, for message signatures, we use a trick called public key recovery. The fact is that if you have the full R point (not just its X coordinate) and s, and a message, you can compute for which public key this would be a valid signature. What this allows is to 'verify' a message with an address, without needing to know the full key (we just do public key recovery on the signature, and then hash the recovered key and compare it with the address). However, this means we need the full R coordinates. There can be up to 4 different points with a given \"X coordinate modulo n\". (2 because each X coordinate has two possible Y coordinates, and 2 because r+n may still be a valid X coordinate). That number between 0 and 3 we call the recovery id, or recid. Therefore, we return an extra byte, which also functions as a header byte, by using 27+recid (for uncompressed recovered pubkeys) or 31+recid (for compressed recovered pubkeys). Strictly speaking the recid is not necessary, as we can just cycle through all the possible coordinate pairs and check if any of them match the signature. The recid just speeds up this verification. In general, if h is the cofactor, the maximum number of different points with given \"X coordinate modulo n\" will be 2(h+1). In the case of secp256k1, which has cofactor 1, we get 2(1+1) = 4.",
      "As all the other answers already outline: v is required to recover the correct public key for a signature because there are sometimes (even with low probability) more than one valid public key to be retrieved by a signature. Here's a cheat sheet: 27 uncompressed public key, y-parity 0 , magnitude of x lower than the curve order 28 uncompressed public key, y-parity 1 , magnitude of x lower than the curve order 29 uncompressed public key, y-parity 0 , magnitude of x greater than the curve order 30 uncompressed public key, y-parity 1 , magnitude of x greater than the curve order 31 compressed public key, y-parity 0 , magnitude of x lower than the curve order 32 compressed public key, y-parity 1 , magnitude of x lower than the curve order 33 compressed public key, y-parity 0 , magnitude of x greater than the curve order 34 compressed public key, y-parity 1 , magnitude of x greater than the curve order For any v >= 35 you might be dealing with Ethereum signatures as per EIP-155 : v = recovery_id + CHAIN_ID * 2 + 35"
    ]
  },
  {
    "question": "How long would it take a large computer to crack a private key?I am doing a presentation on Bitcoins and I was looking for some calculations to make people feel safe about the private key encryption. Please first answer, how long in bytes the private key is, then how many combinations of numbers it will contain, and then what is the fastest computer or network of supercomputers and how long it would take to crack a private key using that computer. I think the result would be very educational based on my own calculations. Thank you.",
    "answers": [
      "how long in bytes the private key is 32 bytes, or 256 bits then how many combinations of numbers it will contain There are 2^256 different private keys. That's a little larger than a 1 followed by 77 zeroes. what is the fastest computer or network of supercomputers At its peak around August 2011, the Bitcoin network was checking 15 trillion sha256 hashes per second. (See http://bitcoin.sipa.be/ ) how long it would take to crack a private key using that computer If we assume it takes the same time to run an ECDSA operation as it takes to check an sha256 hash (it takes much longer), and we use an optimisation that allows us to only need 2^128 ECDSA operations, then the time needed can be calculated: >>> pow(2,128) / (15 * pow(2,40)) / 3600 / 24 / 365.25 / 1e9 / 1e9 0.6537992112229596 It's 0.65 billion billion years. That's a very conservative estimate for the time taken to break one single Bitcoin address. Edit: it was pointed out that computers tend to get exponentially faster over time, according to Moore's Law . Assuming computing speed doubles every year (Moore's law says 2 years, but we'll err on the side of caution), then in 59 years it'll only take 1.13 years. So your coins are safe for the next 60 years without a change to the algorithms used to protect the blockchain. However, I would expect the algorithms to be changed long before it's feasible to break the protection they provide.",
      "A Bitcoin private key is a random 256-bit number. However, the public key reveals some information about the private key. The best known algorithms for breaking ECDSA require O(sqrt(n)) operations. That means 2^128 operations would be needed to break a Bitcoin account. The largest ECDSA key broken to date of the type that Bitcoin uses was 112 bits long. A Bitcoin account is more than 4,000 billion billion times harder to break. The only realistic risk would be quantum computing."
    ]
  },
  {
    "question": "What are multi-signature transactions?What are multi-signature transactions, and why might they be used? Also see: How does one make multisignature transactions with the bitcoin client? How can I create a multi signature 2-of-3 transaction?",
    "answers": [
      "A multi-signature address is an address that is associated with more than one ECDSA private key. The simplest type is an m-of-n address - it is associated with n private keys, and sending bitcoins from this address requires signatures from at least m keys. A multi-signature transaction is one that sends funds from a multi-signature address. The primary use case is to greatly increase the difficulty of stealing the coins. With a 2-of-2 address, you can keep the two keys on separate machines, and then theft will require compromising both, which is very difficult - especially if the machines are as different as possible (e.g., one pc and one dedicated device, or two hosted machines with a different host and OS). It can also be used for redundancy to protect against loss - with a 2-of-3 address, not only does theft require obtaining 2 different keys, but you can still use the coins if you forget any single key. This allows for more flexible options than just backups. It can also be used for more advanced scenarios such as an address shared by multiple people, where a majority vote is required to use the funds. Multi-signature transactions are often conflated with BIP 16 and 17. In fact they are not directly related. Multi-signature transactions have been supported by the protocol for a long time; but implementing them would require a special output script. What BIP 16/17 do is offer a standard way to encapsulate a script within an address; this makes it easier to use advanced scripts, with the most prominent example being multi-signature transactions.",
      "Enjoy! \"Bitcoin Faucet Hacked\" How a future version of the Faucet will work to prevent a similar incident: http://gavintech.blogspot.com/2012/03/bitcoin-faucet-hacked.html \"BIP 16 / 17 in layman's terms\" http://bitcointalk.org/index.php?topic=61125.0 \"The Truth behind BIP 16 and 17\" http://bitcoinmedia.com/the-truth-behind-bip-16-and-17/"
    ]
  },
  {
    "question": "Why is downloading blocks taking longer and longer?First off, this really needs to get fixed. I'm downloading blocks for at least 8 hours now, and it's still not done. I know the problem of having to download the entire block chain is being worked on, but I feel it's already out of hand. Setting up an application should take something you would measure in minutes, not hours or days. (After spending the entire night, it's now 4:15am, I would estimate the setup time to be two days .) Also downloading can be much optimized as it is. It's far from using my maximum download speed, and being connected to one peer is as fast as being connected to 8+ (yup, also tried port forwarding). Now, ontopic. Is it normal that downloading blocks goes slower, the further you progress? The first half (out of 194.000) went in the blink of an eye, after that it became less and less fast. Now at 20.000 blocks remaining, progress comes in bursts, but there can easily be 20 seconds of inactivity and when it bursts it's like 10 blocks. Is this normal behavior? And also, why doesn't the number of connections make any difference for the speed at all? If it works like Bittorrent, which some describe it to work like, it should get faster with more people who can upload to you (more connections). I've Googled, but all I've found is that it takes a few hours and that it may get stuck. It's not stuck and taking as long as people describe it to be, but I just wonder if it's normal that it's going slower and slower, and why it doesn't saturate my download capacity (like BitTorrent) no matter how many connections. Thanks",
    "answers": [
      "Very little of the time is spent downloading the blockchain data compared to how much time your computer is spending verifying each transaction. Bitcoin does a ton of disk i/o for this. As there are more transactions since April (thanks to SatoshiDICE, we now see 40K and more transactions a day) those blocks take longer to verify. If you are on an encrypted filesystem, that will really be hurtful for perfomance. If so, consider moving the blockchain and index to a filesystem that isn't encrypted and then symlink to them there. Also, the latest release of the Bitcoin.org client (v0.6.3) has peformance improvements in this area over previous releases. End uses generally will not need to run the client and instead use SPV (Simplified Payment Verification) . So individuals and organizations that do want to run the full client should recognize that to do so requires a beefy CPU and quick storage (SSD maybe even). A future version (after 0.7) will include LevelDB which should make huge gains as far as performance. In the meantime, you can always securely download a full set of blockchain data from Sourceforge that is as-of a fairly recent point in time.",
      "Okay, combining answers and what more I've observed: The rate of blocks slows down because more recent blocks are larger. The number of blocks remaining is not actually a good measure for estimated time. You can make an estimate based on how much data is downloaded (in how much time) and how much data is left: At the moment of writing, my blk000x.dat files are totaling 8.3GB (10 Feb 2013). I can't say anything about how fast the data size will increase, perhaps someone can comment on this for future readers. Update: It seems to be growing rather fast, probably linearly with the number of transactions per block The reason it doesn't max out your download speed, is because it's actually doing a lot of other things to verify the transactions. Downloading a zip with nightly blk000x.dat files is a lot faster, but copying the files didn't work... In the end I just left it running a few more hours. Also see the comment about a bug this might introduce when an error is present in the files (intentionally or not). Encrypted filesystems make it take even longer because verifying blocks is an disk-intensive process. If you can, use an SSD , this speeds it up by a lot. You could be done in a few hours instead of taking all night. Usually this process just takes a while. 24 hours is not uncommon. Best is to leave your computer running during the night, and don't be disappointed when it's still not done in the morning. Hope this helped! Credits to the other answers for some of the bullet points."
    ]
  },
  {
    "question": "What prevents a pool miner from stealing an entire block?As I understand it,when mining BTC, and calculating a block, the goal is to find a SHA-256 hash below a certain value (with the previous block, a nonce, and other things as the input). Are pool miners all performing that calculation directly (just with different nonces?) If so, what prevents the miner who \"finds\" the block from keeping it, and not reporting it back to the pool? I'm assuming there's some safeguard here, and the miners aren't actually going to find the full solution.",
    "answers": [
      "When you are running a miner in a pool, you communicate through getwork protocol. It basically boils down to requesting work and sending back shares (and in rare cases, solutions to blocks). Work in getwork is a Block Header, not an entire Block. The coinbase transaction is encoded in the merkle root, but is not known to the miner. The block hash that creates a share or a block solution is ONLY valid for a given merkle root. If you change the coinbase, giving yourself all the money, you invalidate your solution and have to start over. If you are mining your own blocks, no pool should accept your shares (unless it is dumb). To sum up - a miner does not know the coinbase transaction, nor can it change the block without invalidating it. On the other hand, a miner can withhold a block solution while still submitting other shares. This will make the pool get less money while still having to potentially pay for those shares. This exploit can be detected by statistics though, so over a long period of time such a malicious miner can be found out.",
      "The blocks you mine contain a coinbase transaction, which pays the block reward to an address of your choice. When mining in a pool, you set the payment address to the pool's address. If you were to mine a block and try to change the payment address to your own address, this would change block hash and invalidate the block. You can't cheat a pool by mining with your own payment address because they will check that. Pools get a regular proof of work from their miners by giving them an easier difficulty target, so that the miner regularly passes mined blocks back to the pool which get checked. So basically you either mine for a pool, which pays the pool, or you mine solo. You can't do both at once."
    ]
  },
  {
    "question": "Where are the user's bitcoins actually stored?On the person's computer? On bitcoin.org? :) Where does that information reside that tells others and me how much bitcoins I have? I assume it can't be on my PC because I could easily hack the file that contains that data and get myself more bitcoins, right?",
    "answers": [
      "It seems like what's called for here is a basic explanation of two of Bitcoin's big concepts: the wallet and the blockchain: A \"wallet\" is a collection of ECDSA keypairs. For those not familiar with cryptography, a keypair consists of a \"public key\" and a \"private key\" which can be used to encrypt or sign bits of data. The public key, as the name suggests, is known to everyone and can be used to encrypt messages in such a way that the holder of the private key alone may decrypt them. The private key may also be used to sign messages in such a way that anyone holding the public key may verify that the message truly came from you. Every Bitcoin address consists of such a keypair - the \"address\" you send people is the public half and the private half resides in your wallet.dat file. The \"blockchain\" is a constantly growing database of transaction information which is sent out to all nodes in the Bitcoin network. When you perform a transaction, that transaction is distributed to the network and assuming the transaction is valid, will be included in the next \"block.\" This is where the coins themselves are stored. When you initiate a transaction, all previous transactions to or from that address are scanned and a balance is calculated. If your transaction exceeds this available balance, it will be rejected by the network and will not be included in a block. It's also important to note that the blockchain technically doesn't store \"coins\" it stores transaction information. The coins themselves are not discrete things which need storage - when coins are mined the miner's balance is credited via a \"generate\" transaction which adds to his or her available balance. When coins are sent from A to B, that transaction subtracts from A's balance and adds to B's balance. This is similar to the way that your employer may, via EFT, send \"money\" to your bank and you can use your debit card to spend that \"money\" in a store, all without anyone ever seeing a discrete physical dollar bill. Most money in the world today exists merely as transaction histories and balances - Bitcoin is no exception.",
      "The information is split. Some information is stored on your PC in the wallet file. Some information is stored in the public blockchain . Stored in your wallet file is the list of accounts that you control and the secret key needed to spend coins sent to those accounts. Stored in the public blockchain (held on every computer running the Bitcoin client) is the record of every transaction ever made, including any transactions that sent you coins. When you wish to spend your coins, you check the blockchain to find unspent coins sent to you (or mined by you). You compose a transaction that specifies which unspent coins in the block chain you wish to spend and what account(s) you wish to send those coins to. You can return any 'change' to an account you control. You use the keys in your wallet to sign the transaction. You then broadcast that transaction to miners. They confirm that your transaction is valid, making sure it spends only coins that exist, are unspent, and that it has the proper signatures. They make sure that the number of coins coming out of the transaction is less than or equal to the number of coins claimed by the transaction. They then commit that transaction into a new block linked into the hash chain, and the transfer is complete."
    ]
  },
  {
    "question": "How does the bitcoin client make the initial connection to the bitcoin network?Once the bitcoin client is connected to a machine (or multiple machines) on the bitcoin network, they can share information (e.g. the block-chain, IP addresses of other nodes, etc). I understand how this peer-to-peer architecture is robust to nodes joining/leaving/crashing and not relying on any central authority. My question is: when I start my client, it has no information about the IP addresses of the other nodes, so how does it know who/where to connect to initially ? How does one 'boot-strap' a peer-to-peer network?",
    "answers": [
      "The Bitcoin client has a number of sources that it uses to locate the network on initial startup. In order of importance: 1) The primary mechanism, if the client has ever run on this machine before and its database is intact, is to look at its database. It tracks every node it has seen on the network, how long ago it last saw it, and its IP address. 2) The client can use DNS to locate a list of nodes connected to the network. One such seed is bitseed.xf2.org . The client will resolve this and get a list of Bitcoin nodes. 3) The client has a list of semi-permanent nodes compiled into it. 4) The client can connect to a well-known IRC network, irc.lfnet.org , and find other nodes that way. (This method has been removed as of version 0.8.2) 5) It takes IP addresses from the commandline (-addnode).",
      "The connection method depends on the client. Bitcoin Core will spend up to 11 seconds trying to connect to a peer in its database. If that doesn't work, it will query a DNS server (known as a DNS seed) to get addresses for peers the seed believes are active. If that doesn't work within 60 seconds, it will fallback to one of its hardcoded addresses. Once a connection is made to a remote peer, the local node will request more addresses from that remote peer. Other clients may work differently---for example, BitcoinJ by default jumps straight to querying the DNS seeds. If that doesn't work, it will fallback to hardcoded addresses. A few more details may be found in the Peer Discovery section of the Bitcoin.org Developer Guide ."
    ]
  },
  {
    "question": "How can I accept Bitcoin donations on my blog or site?If I sell things, there are many services that allow me to accept bitcoins as payment. But for those who simply want to accept bitcoins on their blog or other site ... as donations. A simple bitcoin address can be listed but what other options are available, such as an icon that can be clicked on, like what Flattr offers, perhaps?",
    "answers": [
      "Although bloggers could turn to an external service to manage this for them, it might be more beneficial to simply offer a simple QR code with a description alongside. This would mean that all of the income from the BTCs would go direct to the blogger. My personal blog has an article describing in detail how to do this . I'm not trying to plug anything honestly, just sharing knowledge. This can be imaged with a Bitcoin wallet, or dragged like a Bitcoin swatch onto the Multibit client. A simple click will trigger a protocol handler within the browser (if installed) that would activate an wallet plugin.",
      "And Blockchain.info has added Facebook \"pay a friend\" feature. http://www.Blockchain.info Another method -- for requesting funds is: http://www.bitcoinchipin.com Another thread on this topic: http://www.reddit.com/r/Bitcoin/comments/v51nz/newb_here_i_have_a_couple_of_websites_and_want_to/"
    ]
  },
  {
    "question": "Why can’t the genesis block coinbase be spent?According to the bitcoin wiki : The first 50BTC block reward went to address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa , though this reward can't be spent due to a quirk in the way that the genesis block is expressed in the code (this may have been intentional). But where is this quirk? How would you change it to allow it to be spent?",
    "answers": [
      "When a node starts up it initializes its copy of the block database alongside the genesis block and then begins the synchronization process. For some reason, Satoshi decided not to add the coinbase transaction from the genesis block to the global transaction database. Thus all the nodes in the network would reject the block. I'm not sure if this was done on purpose or if it was simply an oversight. In any event, it is forever bound to 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa.",
      "How would you change it to allow it to be spent? In order to make the coinbase spendable, the following changes have to be made to validation.cpp (v0.16.2). Note : as mentioned this would be considered a hard fork. Step 1 - Disable skipping the genesis block (which is intended to keep the bug as part of consensus), Line 1818 : // Special case for the genesis block, skipping connection of its transactions // (its coinbase is unspendable) if (block.GetHash() == chainparams.GetConsensus().hashGenesisBlock) { if (!fJustCheck) view.SetBestBlock(pindex->GetBlockHash()); // return true; <- comment this line out } Step 2 - Skip assertion of previous block for genesis block, Line 1874 : if (block.GetHash() != chainparams.GetConsensus().hashGenesisBlock) { assert(pindex->pprev); } Step 3 - Skip writing undo data for genesis block, Line 1989 : if (block.GetHash() != chainparams.GetConsensus().hashGenesisBlock) { if (!WriteUndoDataForBlock(blockundo, state, pindex, chainparams)) return false; }"
    ]
  },
  {
    "question": "ELI5: What's the difference between a child-key and a hardened child-key in BIP32I've read BIP32 , and I do understand it more or less. Could someone please explain to me like I'm 5 years old what the difference between a child-key and a hardened child-key is? I'm trying to add HD wallet generation to a service I'm building. I need to be completely informed about this before I dabble in it. Fret not, I'll be using Bitcore , so I won't be dabbling with the crypto directly.",
    "answers": [
      "Essentially, a hardened child key is is computed with hash(parent private key + index) , whereas a non-hardened child key is computed with hash(parent public key + index) . So what practical consequences does this have? With an extended public key, you can derive non-hardened child public keys. This is useful in situations where you want to accept payments without immediately being able to spend them. For example, if you had a website selling alpaca socks, your server could use an extended public key to accept payments without losing all of your money if it got hacked. So that's a reason why you might use non-hardened derivation. With an extended private key, you can also derive hardened keys. However, non-hardened public keys are weaker when an attacker has 1) the extended public key and 2) one of the non-hardened private keys that was derived from it. In that circumstance, the attacker can work out the private key of the extended public key, and therefore get every key that can be derived from that, hardened and non-hardened. So what should your app use by default? You should use non-hardened keys, and disable the ability to export private keys when that would allow an attacker to compromise other keys in the wallet. Even if an attacker gets ahold of one of the private keys, in situations where the attacker doesn't have access to the extended public key, non-hardened is equivalent to hardened security. In my mind, the features of non-hardened keys outweigh the added security of hardened keys. However, if you don't need the features of non-hardened keys, then you should use hardened keys, because they're more secure."
    ]
  },
  {
    "question": "How does Bitcoin Cash implement replay protection?Bitcoin Cash says that they are providing replay protection for their fork. How does this replay protection work?",
    "answers": [
      "Bitcoin Cash (aka Bitcoin ABC aka UAHF) provides two methods of replay protection, both of which are opt in. If you do not create transactions which use these features, then your transactions are vulnerable to replay. The first method is a redefined sighashing algorithm which is basically the same as the one specified by BIP 143. This sighash algorithm is only used when the sighash flag has bit 6 set. These transactions would be invalid on the non-UAHF chain as the different sighashing algorithm will result in invalid transactions. This means that in order to use this, you will need to transact on the UAHF chain first and then on the non-UAHF chain second. The second method uses an OP_RETURN output which has the exact string: Bitcoin: A Peer-to-Peer Electronic Cash System as the data of the OP_RETURN. Any transaction which contains this string will be considered invalid by UAHF nodes until block 530,000. This means that prior to block 530,000, you can split your coins by transacting on the non-UAHF chain first with the OP_RETURN output, and then transacting on the UAHF chain second. Update: They Bitcoin Cash specification now requires that all transaction use the redefined sighashing algorithm as explained for the first method. This means that there is now two way transaction replay protection; transactions made on the Bitcoin ABC chain will be invalid on the non-ABC chain and vice versa."
    ]
  },
  {
    "question": "When should I use -reindex-chainstate and when -reindexWhat is the difference between the options -reindex and -reindex-chainstate ? Is one of the options faster? When should each option be used?",
    "answers": [
      "-reindex : wipes the chainstate (the UTXO set) wipes the block index (the database with information about which block is where on disk) rebuilds the block index (by going over all blk*.dat files, and finding things in it that look like blocks) rebuilds the chainstate (redoing all validation for blocks) based on the blocks now in the index -reindex-chainstate : wipes the chainstate rebuilds the chainstate using the blocks in the index you had before The latter should be strictly faster, as it does not need to rebuild the block index first. Perhaps the progress bar during reindex confuses you: that progress is only for the rebuilding of the index. The recreation of the chainstate happens after that rebuild is completed. You should use -reindex only when you were running in pruning mode, or if you suspect the blocks on disk are actually corrupted. Otherwise, when you only suspect corruption of the chainstate (which is far more likely), use -reindex-chainstate .",
      "if you using reindex-chainstate is more faster . also i have collection script to monitor block status block monitor example script you can ruuning with crontab and see how many block have been sync and compare with mainnet block excplorer."
    ]
  },
  {
    "question": "How do I see the IP address of a bitcoin transaction?How do I see the IP address that someone used to send or receive bitcoins with? Is it stored in the blockchain?",
    "answers": [
      "No, IP addresses are not stored in the blockchain. But Gavin Andreson indeed notes that Unless you are very careful in the way you use Bitcoin (and you have the technical know-how to use it with other anonymizing technologies like Tor or i2p), you should assume that a persistent, motivated attacker will be able to associate your IP address with your bitcoin transactions. One way to do this is to simply run bitcoin peer-to-peer clients that connect to a large fraction of the active nodes. It's not as hard as you might think. See Dan Kaminsky's Black Hat 2011 talk , starting at slide 21, for more. (Thanks to kirian for reminding me of the link). Then see An Analysis of Anonymity in the Bitcoin System 2011-07-22 by Fergal Reid, Martin Harrigan for how to link together the various bitcoin addresses that each user uses. Some related background is outlined by Craig Reading: Bitcoin Theft – The Top Ten Threats | Genesys Guru Blog",
      "The blockchain doesn't store IP addresses . In order to obtain the IP address of someone sending or receiving bitcoins, you would have either observe the activity of the network very carefully, or track them down by some other means. Keep in mind that, for example, someone could receive bitcoins without ever being connected to the internet ."
    ]
  },
  {
    "question": "What is the coin selection algorithm?When creating a transaction in the standard client, what is the algorithm used to determine which unspent outputs will be used as inputs? Has this changed since the first version? What different algorithms are used by alternative clients? Does the client make any attempt to optimize which 'coins' are used based on minimizing the transaction size, the resulting fragmentation, or the 'age' of the coins (value/transactions) used as the source?",
    "answers": [
      "I couldn't find the results of the Coin Selection written out anywhere, and just finished piecing it together from the code. It works as David mentioned , but here are more details. The Coin Selection Algorithm logic to transfer Target amount If any of your UTXO ² matches the Target¹ it will be used. If the \"sum of all your UTXO smaller than the Target\" happens to match the Target, they will be used. (This is the case if you sweep a complete wallet.) If the \"sum of all your UTXO smaller than the Target\" doesn't surpass the target, the smallest UTXO greater than your Target will be used. Else Bitcoin Core does 1000 rounds of randomly combining unspent transaction outputs until their sum is greater than or equal to the Target. If it happens to find an exact match, it stops early and uses that. Otherwise it finally settles for the minimum of the smallest UTXO greater than the Target the smallest combination of UTXO it discovered in Step 4. As David mentioned, the subset problem will first restrict to UTXO that have at least one confirmation if sent by yourself, or six confirmations if received from another wallet, then later relaxes these requirements in two further passes if no suitable set of UTXO could be discovered. Some examples Alice has four UTXO: • UTXO_A 0.1BTC • UTXO_B 0.3BTC • UTXO_C 0.5BTC • UTXO_D 1BTC I will be ignoring transaction fees for simplicity's sake. Example 1: Alice wants to send 0.3BTC . Bitcoin Core discovers that UTXO_B matches the Target, and it only uses UTXO_B as input. Example 2: Alice wants to send 0.4BTC . Bitcoin Core finds that UTXO_C is the smallest UTXO greater than the Target, and that the sum of all UTXO smaller than the target (i.e. UTXO_A + UTXO_B = 0.1 + 0.3 = 0.4 ) matches the Target here. Both UTXO_A and UTXO_B are used as inputs. Example 3: Alice wants to send 0.45BTC . Bitcoin Core finds that UTXO_C is the smallest UTXO greater than the Target, and that the sum of all UTXO smaller than the target (i.e. UTXO_A + UTXO_B = 0.1 + 0.3 = 0.4 ) does not surpass the Target. UTXO_C is used as the sole input, being the next smallest input greater than the Target. Example 4: Alice wants to send 0.35BTC . Bitcoin Core finds that UTXO_C is the smallest UTXO greater than the Target, and that the sum of all UTXO smaller than the target (i.e. UTXO_A + UTXO_B = 0.1 + 0.3 = 0.4 ) does not match the Target. It adds up randomly selected UTXO 1000 times until they surpass the Target, remembering the smallest sufficient combination. The smallest sufficient combination is then compared with the smallest single input greater than the target. Assuming that it does find the best combination here which would be UTXO_A + UTXO_B , it finds that Target < UTXO_A + UTXO_B < UTXO_C and uses UTXO_A and UTXO_B as inputs. Example 5: Alice wants to send 0.6BTC . Bitcoin Core finds that UTXO_D is the smallest UTXO greater than the Target, and that the sum of all UTXO smaller than the target (i.e. UTXO_A + UTXO_B + UTXO_C = 0.1 + 0.3 + 0.5 = 0.9 ) does not match the Target. It starts trying random combinations as before, and in this situation would probably discover that UTXO_A + UTXO_C = Target . As it finds a combination that matches the Target, it breaks and immediately goes with that combination. UTXO_A and UTXO_C are used as inputs. ¹ \"Target\" is used here for the amount to be spent. ² UTXO = Unspent Transaction Output",
      "Yes, that is exactly what the client does. It uses heuristics to do this, solving a subset/sum or knapsack problem. It uses a multi-pass approach, first trying to use only coins with at least six confirmations. In the next two passes it relaxes these requirements. Within each pass, it tries to minimize the number of transaction outputs claimed and then the amount of change returned. Note that all coins in your wallet are considered. In the accounting model that the Bitcoin client uses, specific coins do not belong to specific accounts. If you want to check the code yourself, search for SelectCoins in wallet.cpp ."
    ]
  },
  {
    "question": "What unique business models has Bitcoin enabled?Are there specific, unique business models that have been made possible by the invention of Bitcoin? And if so, what are they? Edit: I seem to be getting a lot of answers about the areas of industry that people hope and or predict Bitcoin will be great for. That's all well and good, but it's not what I'm asking in this question. What I'm curious to find are specific, unique-to-Bitcoin business models that did not and could not have existed before. David Schwartz suggest there may be none (and he may be right), in which case there shouldn't be any answers here. Please don't upvote answers which don't answer this question! As a simple clarifying analogy, consider this question asked of the internet. We can answer with things like \"Pay per click advertising\", MMO gaming, etc. because these things are specific, unique compared to anything that came before, and only possible due to the internet. True, these have become entire industries, but they are industries that didn't exist in any form before the internet. All I'm wondering is if anyone knows of any comparable things for Bitcoin. I don't know of any, and I'm a fairly Bitcoin-aware guy. That's why I asked. Hopefully this clarifies the question.",
    "answers": [
      "The only thing I can think of is Mike Hearn's idea for Smart Property . This would allow the ownership of physical assets to be digitally exchanged and stored in the block chain. Other than that, I think Bitcoin mainly improves the efficiency of many, mainly digital, business models.",
      "Selling electricity over the Internet. I am operating a quite powerful solar array in a sunny region where the connection to the grid is rather poor and does not allow me to feed back much. By placing some mining rigs there, I'm able to simply \"sell\" my excess electricity over the DSL line."
    ]
  },
  {
    "question": "How is block-solution-withholding a threat to mining pools?If I understand the technical process (for most mining pools) correctly, a participant in a mining pool is given block data to combine with a nonce to try to solve the block. If they get close (but not close enough to give the actual solution) to solving a block, they have solved a \"share\", and at that point return proof-of-work to the mining pool to receive a share of the final payout when the block is solved. However, the participant performing the mining DOES know if they actually solve the block. At this point, a malicious miner running custom mining software could potentially choose to not send the solution to the pool. I think I have seen this referred to as a \"solution withholding attack\". How vulnerable are pools and pool-miners to this threat? [Edit]: Also, what can pools do to detect or deter this threat?",
    "answers": [
      "Every pool is vulnerable to the threat. And there's pretty much nothing they can do about it other than perhaps to try to force their miners to use a closed source mining program that they try to make tamper-proof. Your analysis is precisely correct. Miners know when they only found a share versus when they solved a block. A malicious miner could submit shares but withhold solved blocks. The consequences of this depend on the payout model the mining pool uses. If, for example, the pool uses a fixed pay per share, such a miner is robbing the pool operator. But he does no harm to the other miners. If it uses most of the other distribution schemes, such a miner is robbing the other miners since he is being paid out of solved blocks and never contributes to the number of solved blocks. The amount of harm he does is typically proportional to the amount of hashing power he has. This attack is typically undetectable because it just appears to be ordinary bad luck. An attacker can use a large number of distinct user names so it wouldn't appear suspicious that no blocks had been solved. There are generally two motives for such an attack, depending on the payout plan the pool uses. One would simply be to make the pool operator lose money. In a PPS plan, you would get paid normally for your mining, all of which would be a straight loss to the pool operator. With other payout plans, making the pool seem unlucky (and thus driving away miners from that pool) could be a part of the motive. You still get paid for your shares, so the cost to launch such an attack (assuming you were already going to mine) is not that much. The consensus is that such attacks are likely to remain rare and generally insignificant. The payout for the attack is simply too small and it's not an effective way to bankrupt a pool or get miners to desert a pool unless it's a particularly small pool, in which case there's generally no point. Note that it is not possible for an attacker to submit any blocks he finds himself and keep the profits. To earn shares, he must attempt to solve the blocks the pool asks him to solve, and those will include a coinbase entry that pays the block reward to the pool's operator.",
      "There are at least two things you can do with block withholding: The well-known sabotage - not submitting blocks at all to cause financial harm to the pool or its participants. The lesser-known lie-in-wait - delay submitting of a block, and use knowledge of the imminent block for extra profit. The attacks and a proposed solution (oblivious shares) are analyzed in section \"Block withholding\" (currently 6.2) of Analysis of Bitcoin Pooled Mining Reward Systems ."
    ]
  },
  {
    "question": "Why does Bitcoin send the \"change\" to a different address?For example I have an address (A) with 20 BTC and send 9 BTC to address (B). Bitcoin will create a \"change\" portion of the transaction where the remaining 11 BTC goes to address (C). Why not send the change back to A? Instead of: Initial balance: A: 20 BTC B: 0 BTC C: 0 BTC Transaction Pair: A -> B 9 BTC A -> C 11 BTC End result A: 0 BTC B: 9 BTC C: 11 BTC Why not? Initial balance: A: 20 BTC B: 0 BTC Transaction Pair: A -> B 9 BTC A -> A 11 BTC End result A: 11 BTC B: 9 BTC",
    "answers": [
      "Two reasons: So whoever sent to your \"A\" address can't claim to have sent you 31 bitcoins (\"See! Look on block explorer, there are two transactions sending to \"A\", one for 20 bitcoins and one for 11-- send me back the extra 11!\") Using a new change address makes it more difficult for other people to track of how many bitcoins you have or where you're spending them.",
      "While the other answers are slightly true, there's another reason. Addresses which have been spent are inherently less secure than unspent addresses. This is because, when spending on an address, you reveal the public key to the address. This means that in order to steal those funds, you only need to find the private key, whereas normally you'd need to break the hash and find the private key. Both of these tasks are extremely difficult, so for now it's not much of a concern if you send to spent addresses. The problem arises with the theoretical quantum computer. ECDSA, the technology which secures your private key, is extremely easy for quantum computers to reverse. The hash isn't. Therefore, when quantum computers become popular used addresses will become exponentially less secure. More info at https://bitcoin.stackexchange.com/a/7134/11666 Also: https://bitcointalk.org/index.php?topic=153302.0 In the BitcoinTalk post, the concern brought up about hackers cracking transactions between broadcast and inclusion in blocks is reasonable. Fortunately, honest miners include the first transaction first regardless of fee, so that attack is foiled. It is also prevented by the fact that it would still take quite some time to crack the public key."
    ]
  },
  {
    "question": "Nonce size - Will it always be big enough?If I understand correctly, the block only has 4 bytes (32 bits) for the nonce. Is it possible for the difficulty to become high enough that there are no nonce solutions? If so, then what options does a miner have?",
    "answers": [
      "The difficulty is already to the point where it requires over a quadrillion hashes to solve a block. 2^32 is only 4 billion. Fewer than one in a billion times will there be any nonce that makes the block valid. A miner simply has to try every possible nonce on a different block. He can vary the coinbase, the transaction set, and/or the block timestamp. Any change to any of these things results in a new chance for there to exist a valid nonce. Often the best choice is to bump the timestamp, a practice called NTime rolling . The block timestamp doesn't have to be exact anyway, so you can back the timestamp back, say, ten seconds before you start mining and then bump it up 20 times before giving up and getting a new block. At worst, your block timestamp will be off by a dozen seconds or so -- nobody cares about that. After that, you probably want to get a new block because there might be some new transactions to include -- this not only improves the efficiency of the network as a whole but reduces the chances you'll miss out on a transaction fee.",
      "Whether or not there is a solution depends on the contents of the block as well as the possible values of the nonce. The transaction block can be altered if necessary which essentially means you get another 32 bits of nonce values to try. There is an additional component of a transaction block called the \"coinbase\" that can be altered without altering the actual transactions within the block. This has been in the past to insert short messages into the block chain ."
    ]
  },
  {
    "question": "How do I import a private key into Bitcoin-Core?How do I import a private key into Bitcoin-Qt? bitcoind is nowhere to be found, and pywallet says it requires \"bsddb\" when I run it, which is also nowhere to be found. I generated some vanity addresses and I want to use them.",
    "answers": [
      "Run Bitcoin-Core Select Help (to the right of Settings) Select Debug Window Select Console If you encrypted your wallet, unlock it by entering walletpassphrase \"YourLongPassphrase\" 600 next to the > input box Next to the > input box type importprivkey (Note that the private key must not have spaces, remove them if they are included in your backup) Example: importprivkey 5KJvsngHeMpm884wtkJNzQGaCErckhHJBGFsvd3VyK5qMZXj3hS",
      "For those of you looking to import your Vanity address into your BitCoin QT client, here are the instructions ( source ): Backup Your Wallet Although this process is well tested and used you should always take another backup of your wallet.dat file before starting. Open Debug Window Then go to menu: /Help/Debug Window and click on the tab - Console. Unlock your wallet If your wallet is encrypted (I hope it is!) you must unlock it. If not just skip this step. To do this just type into the box at the bottom: walletpassphrase \"YourLongPassphrase\" 600 You need the quotes if there is a space in your phrase else there is no need for them. The 600 means your wallet is unlocked for 10 minutes (600 seconds). Run Import Command in Debug Window In the console at the very bottom is a text entry box. In here enter: importprivkey yourPrivateKeyInWalletImportFormat \"TheLabelThatIWant\" The private key must not have any spaces, remove them if they existt in your backup. The label may have spaces, the quotes are only needed if you want a space in the label. You now have to be patient. On a fast PC it takes 2 minutes to import, and during this time it looks like you application has hung. You are now done. But always best to check it worked. Check Key Imported OK Once Imported you can check that you have the address by closing the Debug window and going back to your address book. You should see the address here. Restart your BitCoin QT Client to see the new address in your Receive \"Tab\" Backup Wallet Your backup of your wallet will not have this key in obviously. So before you do anything else backup the wallet.dat file as normal."
    ]
  },
  {
    "question": "What are pros and cons of txindex option?I am reading \"Mastering Bitcoin\" written by Andreas and I found this explanation about \"txindex option\" Transaction Database Index and txindex Option By default, Bitcoin Core builds a database containing only the transactions related to the user’s wallet. If you want to be able to access any transaction with commands like gettransaction, you need to configure Bitcoin Core to build a complete transaction index, which can be achieved with the txindex option. Set txindex=1 in the Bitcoin Core configuration file I am not sure what situations should I enable the option. In my understanding, I can set txindex=0 if I use bitcoind as just a transmission tool of Bitcoin so that I can save data and time to sync the blockchain data. Otherwise, if I intend to make a blockexplore site like Blockchain.info , I need to set txindex=1 . Is my understanding of this correct?",
    "answers": [
      "If you're using Bitcoin Core just for your own personal use, you probably don't need the -txindex=1 option. But, if you're using Bitcoin core for development or blockchain analysis of some sort, you will need to set -txindex=1 to be able to get transactions data for any transaction in the blockchain. The tradeoff is just that keeping an index is slightly slower, but allows you to do things like: bitcoin-cli getrawtransaction aec2729f5e46750b310b6feadcf853098aa86df74f93322a701c29cd68b22568 (where aec2729f5e46750b310b6feadcf853098aa86df74f93322a701c29cd68b22568 is the ID of a transaction that does not affect your wallet at all). Also, if you have been running your client for a while but haven't had txindex=1 set, then it might take a few hours to build the index. If you want to rebuild, launch with the -reindex option.",
      "By default -txindex=0 Bitcoin Core doesn't maintain any transaction-level data except for those in the mempool or relay set pertinent to addresses in your wallet pertinent to your \"watch-only\" addresses If \"txindex\" is set to true (1), Bitcoin Core maintains an index of all transactions that have ever happened, which you can query using the remote procedure call (RPC) method getrawtransaction or the RESTful API call get-tx . Several popular wallet and \"block explorer\" programs require -txindex=1 . Note that txindex does not alter the behavior of Bitcoin's peer-to-peer interface."
    ]
  },
  {
    "question": "How to unstuck a low-fee transaction with blockchain.info?I've sent a transaction from blockchain.info , but accidentally included too little fee. What can I do to cancel the transaction or speed up the transaction's confirmation? This is a complementary question to Why is my transaction not getting confirmed and what can I do about it? which answers the question's broader implications and proposes mitigation mostly focused on Bitcoin Core.",
    "answers": [
      "this is a generic answer applying to \"light\" wallets - I don't know much about the blockchain.info-wallet There are several approaches that may work, I've tried to list all the methods I know below. I don't know how the blockchain.info-wallet works, but probably I would try things in this order: Wait for the transaction to go through (see 0a below) Do a \"CPFP\" (see 2 below) Ask the pools for help (see 3 below) Wait for the transaction to be forgotten and retry sending (see 0b below) Try to do a double spend (see 1b below) 0) Wait it out. 0a) Wait for the transaction to go through. Most likely there will be free capacity in the network after some hours, some days or a week. In periods with free capacity, even low-fee transactions will pass. Rarely one has to wait longer than the next Sunday evening. 0b) Wait for the transaction to be forgotten, and then create a new transaction with a higher fee. In some few exceptional cases (notably around new year 2017/2018 and in 2021) several weeks or even months have passed without any free capacity. The original transaction may eventually be forgotten by the network. Some wallets will then offer to create a new transaction, Mycelium will offer to delete the old transaction, and with some luck a \"double spend\" will be possible - though this is very unreliable as the original transaction may be purposely or accidentally rebroadcast both by the sender, receiver and any third-party. 0c) From some wallets, the most intuitive panic action is to actively rebroadcast the transaction. This probably won't help at all, and it's the exact opposite of 0b, so it's probably not a good idea 1) Double spend with a higher fee (RBF) . 1a) Using the \"Replace by Fee\"-protocol - this probably does not apply to you, but it's arguably the best way to \"unstick\" transactions. If the original transaction is marked up with \"RBF allowed\", most of the network will accept a replacement transaction with a higher fee. Not all wallets supports setting this flag, and even fewer has RBF turned on by default - for a good reason, the RBF protocol allows an unconfirmed transaction to be reverted, so using the RBF-flag is a terrible idea if you want someone to trust a zero-conf transaction. (the RBF-feature has been removed from most Bitcoin Cash software, as they deem it both \"harmful\" and \"not needed\"). 1b) Doing RBF/\"Double spend\" even if the original transaction was not marked as RBF. Miners (and nodes) are supposed to ignore the double spend transaction - but you may be lucky. You may need to use specialized software to perform such a double spend. It may work, either because the original transaction has ended up in a \"ghost-like\" state where it's known by some nodes but not others - maybe some miners are unaware that you're doing a double-spend - or it may work because some miners deliberately accepts double-spent transactions as they can earn more fees on it. 2) Child Pays for Parent (CPFP). if a new transaction is made with a high fee, building on top of the old transaction, most of the miners will include the whole chain of transaction in the block they're mining at. 2a) Get the receiver of the funds to spend the funds they received on a new transaction, with high fee. This may of course not always be possible, but ... 2b) If not all the money in the wallet was spent, the transaction will typically include two outputs, one \"change UTXO\" that goes back to the wallet. If you can spend this one with a higher fee, the transaction may go through faster. Some wallets have a menu option for \"accelerating\" the transaction through \"CPFP\". In some wallets one can manually decide what UTXOs to include in the transaction. One can also send all the funds in the wallet i.e. back to an address belonging to the same wallet, but the fee for that may become excessive as the wallet may be filled up with \"dust\" making such a transaction big and costly. Electrum does support spending some specific UTXO, and Mycelium has the \"CPFP\" acceleration button. If you can take out a backup seed phrase from your wallet, it can most likely be used in Electrum or Mycelium. 3) Ask the pools for help. viabtc has their \"transaction accelerator\" at https://pool.viabtc.com/tools/txaccelerator/ , antpool.com also has some similar service, there even exists services where one can pay by credit card to get the transaction prioritized.",
      "It looks like your transaction finally went through. I've had a transaction take longer than 24 hours due to not including a large enough miner's fee And currently there's no way to cancel a transaction after it's already sent, even if it's still unconfirmed. So it's a good idea to triple check the amount you're sending, the transaction fee and that it's going to the correct address. I think it would be helpful if bitcoin had this feature in the future: cancelling transactions while they're still unconfirmed"
    ]
  },
  {
    "question": "How can I keep my wallet secure?The standard Bitcoin client does not encrypt wallet files, so any malicious user that gains access to this file will be able to transfer all the coins to their own wallet. Furthermore, if I lose the wallet file then I lose access to those coins. What steps must I take to prevent loss of coins like this?",
    "answers": [
      "One method commonly in use is an \"offline wallet.\" To generate an offline wallet, launch a bitcoin client on a known clean computer, virtual machine, or use a bootable Linux distribution like LinuxCoin. Make sure this system is NOT connected to the internet for this process. When the bitcoin client is first launched, it generates a brand new wallet.dat file with one address. Save that wallet.dat file to a thumb drive along with a text file containing your new bitcoin address. Delete the wallet.dat from the machine once you've copied it. Any coins sent to that address are only accessible to someone holding the wallet.dat file on your thumb drive and since the computer which generated that thumb drive has never seen the internet so it's a pretty fair bet that your copy is the only copy. Send any coins you want to secure to your \"offline\" wallet's address and use your thumb drive to recover the coins when needed. Remember that once you've used the wallet on the thumb drive, it is now \"burned\" and a new one must be generated. Edit: There is an excellent resource for wallet-securing techniques available on the Bitcoin wiki which also covers backup methods, encryption and many other topics at far too great a length to cover in a single answer.",
      "The \"offline wallet\" method described by David Perry is a good way to securely generate a bitcoin address/wallet.dat but in order to be secure from both loss and theft the first thing you will want to do is encrypt that wallet, and then make many different copies of it. One easy way to do this is using the program TrueCrypt as explained here . To summarise the contents of the link, you will use the default options in the software to create an encrypted volume, then move your \"wallet.dat\" file into it as soon as you create it on the trusted, offline computer. This will create an encrypted copy that can be placed on a thumbdrive and then saved in multiple locations such as gmail , dropbox , a physical safe, etc. I would also highly recommend testing the file once with a small amount before copying any substantial sum of bitcoins to your newly created address. If you are satisfied with both the test and all the precautions you have taken, then transfer the rest. You can keep your wallet secure by not accessing it frequently, so this should be used as a savings wallet and not for regular transactions. Hope this helps! Also, you can find an excellent overview of good wallet practices and security methods at https://en.bitcoin.it/wiki/Securing_your_wallet"
    ]
  },
  {
    "question": "What do the different .dat files contain?What data do different Bitcoin .dat files contain? How about the other files in the same folder? The wallet.dat file is somewhat documented and there are some ways to convert it to human-readable form, but I don't think the same can be said about the other files. What data do they store and how is it encoded?",
    "answers": [
      "wallet.dat , addr.dat and blkindex.dat are Berkeley Database files. They can be read using standard tools, but aren't human readable by themselves. blk0001.dat (and additional blk000n.dat blocks) contain the blockchain itself, that's just a binary concatenation of the blocks. wallet.dat contains your private keys, your address book, a copy of the transactions that send coins from or to one of your addresses, accounts, reserve keys, personal settings, and a pointer to the current best block. addr.dat contains IP addresses of peers, both those you've connected to yourself or those you've only heard about. It has been replaced by peers.dat since 0.7.0 peers.dat contains the same information as addr.dat, but using an efficient custom format. blkindex.dat contains an index of the blocks and transactions that can be found in all the blk000n.dat files. I don't know about any standalone tools that convert addr.dat and blkindex.dat to human-readable form, although blockexplorer.com can be used to inspect the blockchain, and addr.dat just contains IP addresses. Update : the data above is only valid before v0.8.0. As of v0.8.0, a new database structure (with associated filesystem layout) is used for blocks and indexes. See also: Bitcoin.stackexchange.com Migration from Berkeley DB to LevelDB What is the database for? What information does a wallet contain? Stackoverflow.com How to open local bitcoin database"
    ]
  },
  {
    "question": "How can I export the private key for an address from the satoshi client?If I want to transfer an address from the satoshi client into a different client, how can I find its private key to do so?",
    "answers": [
      "To export a private key from your Satoshi bitcoin-qt client: launch your bitcoin client as usual and wait for it to load the blockchain and start up click on 'help' in the menu bar (top right) click on 'debug window' select the 'console' tab type: walletpassphrase \"your walletpassphrase here\" 600 type: dumpprivkey [your Bitcoin address here] this will return the private key, you can copy it now; ensure you clear your clipboard/history afterwards type: walletlock",
      "Note: Recent versions of the satoshi client offer a 'debug window' which can be used to export private keys. This is described in Miguel Moreno's answer to this question , and is easier than the steps I describe below. To export a private key from your satoshi client: run: bitcoin-qt -server and wait for it to load the blockchain and start up if your wallet is encrypted, run: read -s x; bitcoin-cli walletpassphrase \"$x\" 600; unset x to unlock it for 600 seconds (type your passphrase after hitting return, then hit return again; this 'read; ...; unset' prevents the password being written to your shell's history file on disk, and the '-s' in read prevents your password being displayed as you type it, and improves protection from screen-loggers and the shell log) run this command using bitcoin-cli: bitcoin-cli dumpprivkey 1my1bitcoin1addres11111 (replace 1my... with the bitcoin address of which you want the private key) if your wallet is encrypted and you want to re-lock your wallet, run bitcoin-cli walletlock"
    ]
  },
  {
    "question": "What is a Finney attack?What is a Finney attack? Extra points for explaining its purpose, the prerequisites for it to be possible, how the attack can be performed and the origin of the name \"Finney attack\".",
    "answers": [
      "The Finney attack is named after Hal Finney , who suggested it in this comment . (Hal happens to be the first recipient of a Bitcoin transaction, and the first person to comment on the release of the Bitcoin source code.) It is a double spending attack with the following features: It only works if the merchant accepts unconfirmed transactions. It still works, however, if the merchant waits a few seconds to verify that everyone in the network agrees he was paid. It requires the attacker to be mining and controlling the content of his blocks; however, he can in theory do this with any hashrate, in particular significantly less than 50% of the network hashrate. It proceeds as follows: The attacker mines blocks normally; in the block he is trying to find, he includes a transaction which sends some of his coins back to himself, without broadcasting this transaction. When he finds a block, he does not broadcast it; instead, he sends the same coins to a merchant for some goods or service. After the merchants accepts the payment and irreversibly provides the service, the attacker broadcasts his block; the transaction that sends the coins to himself, included in this block, will override the unconfirmed payment to the merchant. If the time from finding the block until the attacker sends payment and the merchant accepts it is t, and the average time to find a block is T, there is a probability of t/T that another block will be found on the network in this time; in this case the attack will fail, and the attacker will lose the block reward of B. This means that the average cost of attempting the attack is about (t/T) * B; as a rule of thumb the merchant should wait at least t=V*T/B (V is the value of the transaction), to make sure that trying to carry out this attack against him isn't profitable; this may not be sufficient though, as a nimble attacker can use the same block for multiple attacks, potentially gaining the total of their value. Clearly, the lower the attacker's hashrate, the less opportunities he has to carry out the attack. If the attack is for obtaining some illiquid good, it is difficult to make the need for this good coincide with finding a block. If the attack is for obtaining something liquid (e.g. exchanging bitcoins for other money), an opportunity is ever-present but the merchant is likely to require a few confirmations. This makes the attack difficult to use in practice.",
      "The Finney attack is a variation of a double-spend attack. The attacker creates two transactions - one crediting the victim and one crediting themselves. They keep the first transaction for now and proceed to try mining the second one into a block. When they succeed (this may take awhile), they quickly make a purchase with the first transaction, get the goods they purchased, and then release the pre-mined block. This way the first transaction will become invalidated, even if it is propagated through the whole network. This variant of double-spend attack is harder to execute (mining a block by oneself hasn't been easy for a long while), but is undetectable until it has been fully executed. The only way to protect oneself against such an attack is to require at least one confirmation for transaction before giving out purchased goods, and requiring more confirmations for transactions worth more."
    ]
  },
  {
    "question": "How to safely shutdown bitcoind ?Surprised this one hasn't been asked yet. But how / what is the recommended best practice for shutting down bitcoind ? Right now I'm manually killing the process with either sudo kill {pid} or if this is failing (like just now) using sudo pkill -9 -f bitcoind",
    "answers": [
      "I'm not sure if bitcoind stop still works as RPC with newer releases, since somewhere in help sections it says RPC funcionality removed from bitcoind. Try bitcoin-cli stop .",
      "EDIT: This answer is deprecated, it applied to an old version of the bitcoind client. Apparently RPC functionality is now removed. Please look at the other answers instead. I guess using bitcoind stop . I recommend this approach as killing the process could end you up with a corrupted database, from what I have experienced. Use bitcoind --help for all options and bitcoind help for all JSON-RPC commands."
    ]
  },
  {
    "question": "Why doesn't Bitcoin migrate to proof-of-stake?After reading a little bit about different consensus algorithms, I am just trying to understand why Bitcoin still uses proof-of-work. This consensus algorithm being exponentially expensive, and resource intensive, doesn't it make more sense for Bitcoin --the most expensive cryptocurrency out there-- to migrate to proof-of-stake? Currently, Bitcoin transactions are so expensive that day-to-day transactions, like buying a cup of coffee, can be more expensive than the good/service itself in some parts of the world, which fails to deliver one of the original goals of Bitcoin. That is to be the common person's every-day money. Why does Bitcoin stick to the proof-of-work consensus algorithm?",
    "answers": [
      "Proof of Stake is basically a case of having your cake and eating it, too. PoW is a simple work-around to a coordination problem that was previously thought to be unsolvable. It sort of \"cheats\" by providing an economic solution to a distributed systems challenge, by introducing a real cost as a disincentive to unwanted behavior as well as using a reward system both to bootstrap itself and to incentivize security. The advantages of Bitcoin's PoW system include that the group of block authors is truly open to anyone with computational resources, that the system converges on one ground-truth because there is a real cost in producing a competing chaintip, and that it is simple enough for its security model to be well understood. PoS is more similar to the approaches that were pursued before the publication of Bitcoin. PoS is naturally divergent as there is no real cost in staking. The \"Nothing at Stake problem\" allows stakers to work on multiple chaintips and only publish the next block from the chain most favorable to them. There are different ways of approaching the vastly different security model of PoS. Source: Bram Cohen describing ETH's PoS research For example, ETH's effort to switch to PoS has been in research since at least 2015. The latest I've read, ETH's current PoS proposal piles multiple layers of complexity on top of the staking to achieve convergence. Stakers have to register as \"Validators\" of which there are a limited number, put up a sizeable collateral that can be slashed in retaliation for misbehavior, and additionally maintain frozen capital to stake in the first place. More mitigations are in place to punish validator malfunction and recover the system from such breakdowns. Other approaches to and issues with PoS include: Some systems introduce a central party that rubberstamps the latest block (e.g. Peercoin). A central coordinating party costs the system its censorship resistance. It's difficult to fairly launch a PoS system since stakers have to hold funds in the system to author blocks. Many PoS systems get either started as airdrops, Initial Coin Offerings (ICOs), or a proof of burn auction. Staking requires some representation of the private key to be online at all times, which may mean that it is easier to redirect some of the staking power (in early PoS systems it had to be the actual private key, so not only staking power but actual funds could get stolen). Not participating in staking means that your share in the monetary supply is being inflated away. Some systems require coins to have a certain amount of confirmations before being allowed to be used for staking, so spending funds interrupts your staking revenue. Some people expect that staking revenue will be taxed differently than mining revenue . Some PoS systems can be gamed for profit by trying a vast number of block candidates to cause the staker to get blocks more often than their stake should qualify them for. Such an incentive may turn such PoS systems just into PoW schemes under the hood. Some researchers argue that \"by depending only on resources within the system, proof of stake cannot be used to form a distributed consensus, since it depends on the very history it is trying to form to enforce loss of value\" . So, while the Ethereum Foundation keeps giving (and missing) new delivery dates for an incomplete research project, there seems to be less interest among Bitcoin contributors to discuss Rube Goldberg contraptions. And then, beyond the general skepsis for PoS, it wouldn't be feasible to just switch to it: \"Even if there somehow was a workable solution that had desirable properties and security proofs, it would be working under a vastly different security model than PoW… and nobody can just decide to make such a change without enormous community consensus for such an invasive change.\" –Pieter Wuille",
      "I think there are at least four reasons: The miners are stakeholders in the bitcoin ecosystem. Mining solves a problem for them. Taking away PoW mining would make bitcoin no longer work for one of its most important group of stakeholders. Non-miners are in bitcoin because they like what bitcoin is. If they want some other consensus scheme, they know where to find it. There is certainly room in the market for at least one PoW chain and that's what bitcoin is. Major changes impose costs on every participant in the ecosystem. Every implementation has to implement the new rules. Everyone has to test that the new stuff doesn't break anything they're relying on. There isn't a consensus in the community that PoS can provide the same level of security as PoW at lower cost. That's the claim PoS advocates make, but it's far from an accepted truth."
    ]
  },
  {
    "question": "Is CPU mining even worth it?I would like to start mining, but my GPU isn't the greatest and I don't really want to spend the money on a dedicated rig. Is mining from my CPU (in a Linux environment) still worth it? Or will I not be able to keep up?",
    "answers": [
      "For the amount of time you would spend setting up a CPU miner, at minimum wage in the US you would be at a loss. Even GPU mining is barely profitable for most people right now. It would definitely be more profitable to speculate, and even more profitable to operate a Bitcoin business. There are a great deal of people who want to use their Bitcoins for purchases. At the current exchange of under $10:1BTC, the most efficient graphics cards are taking months to pay off their initial investment (with free electricity).",
      "It depends on your specific valuation of \"worth it.\" By most valuations (i.e. value of BTC produced > electricity costs) it is not, but if you don't pay for electricity it might be. It might also be worth it to you to mine at a loss if you truly believe that 1 BTC might be worth thousands someday. Realistically, though, it is probably more worthwhile to simply purchase BTC at an exchange or from another user."
    ]
  },
  {
    "question": "What are stale shares and what can I do to avoid them?When I mine at a pool, only a part of my shares are accepted. There is a small percentage which is marked as stale. As far as I know I only get paid for accepted shares, so what are these stale shares and how can I avoid them?",
    "answers": [
      "Stale shares are the shares that were sent after a block was already solved, that is to say, they were sent late and were no longer valid. To avoid stale shares, best to have a reasonably fast mining rig (so you won't take too long to calculate a share, probably not a problem for most machines), reliable internet connection (stable, not necessarily fast), but also an up-to-date mining software (if you are mining with some really old miner it might not communicate in the most efficient manner with the pool). In short - update your miner every now and then, make sure your internet is running okay, and don't mine on really weak rigs.",
      "A stale share occurs when you find a share and submit it to the mining pool after the pool has already moved on to the next block. The percentage of stale shares should be very low if everything's working correct, around 2 out of 1,000 shares or so. Several factors affect the stale share rate. The three most important are long polling, pool load, and miner-to-pool latency. Any shares found based on old work units after the pool controller receives a new block will be stale. Long polling is a technique that allows the pool to notify all of its miners when there's a change in the block chain so they can immediately request new work units. If your pool or mining software doesn't support long polling, you will finish out the old work units, generating stale shares. When the long polling notification goes out, all miners that support long polling request new work units at about the same time. This generates a massive burst of load as the pool has to manages lots of network traffic and do several SHA-256 operations for each share it issues. If the pool is slow to issue you a new work unit, the window in which you can generate stale shares increases. The long polling and subsequent share request process requires a few network operations. Latency between the miner and the pool can slow this process down. Picking a pool with a controller near you (network wise) can reduce this part of the stale share window as well. In addition, some pools have had bugs in their software that produced stale shares. The pool checks if the share is stale by seeing if it has a record of the work unit and clearing all work unit records when the chain changes. So if something goes wrong with the work unit tracking process, that will result in a stale share being reported. For example, if the pool erroneously issues the same work unit to two miners, the first one to submit the share will get credit. The pool will remove the record when the share is found because otherwise you could submit the same share more than once. This will result in you getting a stale share report. I probably shouldn't admit it, but I was actually responsible for one such bug. My first implementation of long polling in the Bitcoin client rushed as quickly as possible to send out the notifications of a new block being discovered to miners -- so quickly that some miners could request new work units before the client had finished processing the new block and they got work units based on the old block. Any shares they submitted based on those work units would be reported as stale."
    ]
  },
  {
    "question": "What is a share? Can I find it while mining solo, or only when pool mining?In mining, what is \"a share\"? When mining solo, do I \"find shares\"?",
    "answers": [
      "A share is a hash smaller than the target for difficulty of 1* (see clarification at end). Every hash created has a 1 in ~4 billion (2^32) chance of being a valid share. In comparison if the difficulty of network is 2,000,000 then a share is 2 million times \"easier\" to find than a valid hash for the block, and on average it will take 2 million shares (8 quadrillion hashes) to find a valid hash for the block. Shares have no actual \"value\". To the bitcoin network they are worthless. The only hash with any value is the one that is smaller than the target (determined by difficulty). Since a miner has no control over when he will generate a share (they occur randomly roughly once per 2^32 hashes) he can't cheat the pool. When one miner in the pool finds the solution hash (the only hash worth anything) rewards can then be split by number of shares submitted. There are multiple reward methods (Proportional, PPLNS, SMPSS, PPS, etc) that calculate the \"fair share\" of the reward but all use a share as a proxy for work completed by the miner. It is important to emphasize that a share has no actual value. The only hash with value is the one that solves a block. A share is merely an accounting method to keep the miners honest and fairly divide any rewards earned by the pool. There is no need to keep track of shares in solo mining because you will not split the reward and can't cheat yourself. Usually pools use a difficulty of 1 as the target for a share. Technically any difficulty (less than network difficulty) could be used. Each miner's share of the reward would remain the same regardless of what difficulty is used.",
      "1% of 12.5BTC is not 1.25BTC 12.5 × .01 = .125BTC. But yes, your reward would be proportional to the total amount of work done. If you only did 1% of the shares, you get 1% of the reward."
    ]
  },
  {
    "question": "How is Bitcoin supposed to serve as currency when it is all but impossible to spend at the moment (12/2017)?It seems Bitcoin is not standing up to the test of use as currency (that is to say heavy use). I tried to pay someone 0.009BTC (about $150) for some goods which I need in a fairly timely manner. As if I was ordering some supplies from a crafts store. It has been 5 days and the transaction has not been verified. From what I read it may never be verified, i.e. there is no guarantee by design for the transaction to ever be mined, not to mentioned mined in a timely manner. say what you want about the banks, but when I spend fiat currency the transaction goes through immediately and the party I send the funds to can use the funds immediately. And I get my purchased goods in a timely manner. Not so with BTC. As the transaction volume is growing the system is breaking down to the point of being useless as currency. I am not even talking about being able to spend $5 for a hot dog (I am likely die of starvation before the $5 transaction becomes verified). I am all for crypto currency and bypassing the banks, but this model is simply dysfunctional. Am I wrong? Am I missing something? Is it just growing pains? I think it's like that by design, which is not good.",
    "answers": [
      "You were probably trying to pay on the blockchain itself. That's like trying to pay for lunch by moving dollars through the Federal Reserve. You should use some system designed to move small quantities of bitcoins cheaply such as Coinbase. We don't yet have good decentralized payment systems for bitcoin, so currently bitcoin is primarily being used as a store of value. Think of bitcoin as more like gold than dollars. The Lightning Network is one proposal to provide a way to move small amounts of bitcoin at high speed with low cost.",
      "You basically have two theories nowadays, in a hot debate: Bitcoin is not like dollar; it is like gold (i.e. a store of value). Bitcoin is not made for everyday transactions for a cafe or a pizza. To allow such transactions with low fees, we would have to increase block size, allowing a lot of transactions to be stored forever in the blockchain. This idea can be expressed more or less by: \"We do not want every cafe or every pizza sold in the world today to be stored forever in the blockchain\" The blockchain bytes are expensive (and thus the fees today), because the blockchain has to stay small . Why? Because if blockchain's size increases a lot faster than the average \"hard disk\" available to consumers, then fewer people will be able to host a node (at home or in their VPS). And then only big companies will be able to host a Bitcoin node, this would be the end of the decentralization paradigm . We don't want this, so writing a transaction (=bytes) in the blockchain has to stay expensive. To solve this problem, everyday transactions have to done be off-chain, using Lightning channels for example (technology not available yet, as of 2017). Bitcoin should not be a store of value, but really an everyday-usable currency, even for small payements. To solve the fee problem, let's increase a lot the block size, i.e. less competition to be in a block, i.e. lower fees. Then all transactions will be on-chain, but with a gigantic blockchain , growing much faster than what an average citizen could host at home or on his server. Then only a few big companies will be able to host a node. That could be seen as the end of (truly) \"decentralized\" model. But on the other hand, it helps to keep everything saved in the blockchain. I don't know which one of these two theories (Bitcoin vs Bitcoin cash) will eventually become dominant, but this makes the Bitcoin history exciting! Anyway, we can sum up the problem like this: “Is the blockchain (i.e. gigabytes of data replicated on servers around the world - and soon terabytes) the right place to store the history of every cafe and pizza sold in the world for the future of mankind?” If no, then we lose the \"currency\" aspect of Bitcoin. If yes, then we lose a little bit of the \"decentralized\" aspect of Bitcoin."
    ]
  },
  {
    "question": "What happens if I mistype the address when making a payment?I sent bitcoins to an address, but I think I made a typo when I copied it. Where did these bitcoins go. Can I get them back?",
    "answers": [
      "Bitcoin is very resistant to typos because the addresses contain a built-in check code . So if you had simply mistyped a few of the letters or numbers in the address, it's unlikely the client would have let you send them. If, however, you pasted in a different and valid address, the coins are already transferred to it permanently. In this scenario, Bitcoin works pretty much like cash --there is no way to get it back after giving it away.",
      "It is highly unlikely, you made a typo and were still able to send coins. There is a difference between an invalid address and an incorrect address. All bitcoin wallets/clients check if addresses are valid. Bitcoin addresses are the PubKeyHash encoded in Base58 with a version value and a checksum. The checksum is the leftmost 32 bits of a double hash of the PubKeyHash. The format of the address is often referred to as Base58Checked in technical documents. Since the checksum is 32 bits the probability of entering an incorrect address that will still decode to an incorrect but valid PubKeyHash is roughly 1 in 4.3 billion. So, on average, 4,294,967,295 out of 4,294,967,296 times a typo will produce an address that is incorrect AND invalid. When decoded the PubKeyHash will not produce the proper checksum, the error will be detected by the client/wallet, and the transaction won't be created. To actually lose coins to a typo you would need to produce not just any invalid address, but one that is valid but incorrect and the odds of that happening are almost zero. In that extremely unlikely event (1 in 4.3 billion is 10x less likely than winning the US PowerBall lottery), the transaction will be irreversible and only spendable by the person who has the private key for the incorrect address/pubkey. Given how many private keys are possible, it is almost certain that nobody ever has or ever will have that private keys and the funds will remain forever unspendable."
    ]
  },
  {
    "question": "How are transaction hashes calculated?I'm trying to calculate the hash of transactions in bitcoin blocks, but I'm not getting the right answers. For example, the genesis block has a single transaction . Here's how I'm attempting to calculate its hash... Transactions are encoded as: a 32 bit 'nVersion' a list of input transactions, vin a list of output transactions, vout a 32 bit 'nLockTime' For the transaction in the genesis block, these are: nVersion: 01000000 inputs count: 01 1st input: prevout_hash: 0000000000000000000000000000000000000000000000000000000000000000 prevout_n: ffffffff scriptSig: 4d : 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73 sequence: ffffffff outputs count: 01 1st output: value: 00f2052a01000000 (hex(50*10^8) is 0000012a05f200, and bitcoin puts the bytes in reverse order) scriptPubKey: 43 : 4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac nLockTime: 00000000 If I string all those together end to end, I get 204 bytes: 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000 Taking the sha256 hash of this gives 27362e66e032c731c1c8519f43063fe0e5d070db1c0c3552bb04afa18a31c6bf . Taking the sha256 hash of that hash gives 3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a . But the real transaction hash according to blockexplorer.com is 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b . What am I doing wrong? How can I get to the correct transaction hash? Here's my working in Python: >>> import Crypto.Hash.SHA256 as hash, binascii >>> tx = '01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000' >>> len(binascii.unhexlify(tx)) 204 >>> hash.new(binascii.unhexlify(tx)).digest().encode('hex_codec') '27362e66e032c731c1c8519f43063fe0e5d070db1c0c3552bb04afa18a31c6bf' >>> hash.new(hash.new(binascii.unhexlify(tx)).digest()).digest().encode('hex_codec') '3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'",
    "answers": [
      "Taking the sha256 hash of that hash gives 3b a3 ed fd 7a 7b .............. But the real transaction hash according to blockexplorer.com is .............. 7b 7a fd ed a3 3b The answer I was getting was correct, but bytewise reversed. I need to get used to Bitcoin using little-endian storage.",
      "I've come across this several times when trying to come up with an easy way to calculate a txid, and I finally decided to try and write a little script to do the same. I used built-in libraries and figured this would be a good place to share the script: #!/usr/bin/env python3 import hashlib import sys inhex = sys.argv[1] tx = bytes.fromhex(inhex) h1 = hashlib.sha256(tx).hexdigest() b1 = bytes.fromhex(h1) h2 = hashlib.sha256(b1).hexdigest() ba = bytearray.fromhex(h2) ba.reverse() id = ''.join(format(x, '02x') for x in ba) print(id) I called the script txhash.py . For validation's sake, running ./txhash.py 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000 returns 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b as expected in the original question."
    ]
  },
  {
    "question": "Where is the data folder for Bitcoin-Qt?Where can I find the blockchain, wallet.dat, etc. on each of the operating systems Bitcoin-Qt supports?",
    "answers": [
      "It is the same data folder as the non-QT version of the standard client used to use: Linux: ~/.bitcoin/ MacOS: ~/Library/Application Support/Bitcoin/ Windows: %APPDATA%\\Bitcoin (This defaults to C:\\Documents and Settings\\YourUserName\\Application data\\Bitcoin on Windows XP and to C:\\Users\\YourUserName\\Appdata\\Roaming\\Bitcoin on Windows Vista, 7, 8, and 10.)",
      "On the new Mac OS X you can't see the Bitcoin folder in the library under /application support/. You have to use Finder and in the menu look for GO and then GO TO type ~/Library in the box. After that you can see the Bitcoin folder under /application support/. Or you can hold down the Option key while selecting the Go menu and Library will become an option."
    ]
  },
  {
    "question": "Can bitcoin exist without miners?In the past year only, the bitcoin mining difficulty has increased fivefold. If in the coming years the difficulty increases so much that mining is no longer profitable (i.e. consumes more power than money is earned), can the bitcoin network exist without miners? Can bitcoin supporters or governments have data centers that handle transactions only and do not spend computational resources on mining new bitcoins?",
    "answers": [
      "if in the coming years the difficulty increases so much that mining is no longer profitable That's not really possible. The mining power is set so that the miners need 10 minutes in average to mine a block. If 50% of the miners would disappear because it's not profitable any more, the difficulty would decrease so that it's profitable again. Can the bitcoin network exist without miners? Yes and no. There is still the decentralized blockchain, so you can still check who has how many bitcoins, and you can view the whole history of transactions (they do still exist), but you could not spend them if nobody would mine the transactions. Can bitcoin supporters, or governments have data centers that handle transactions only and do not spend computational resources on mining new bitcoins? Transactions can't be confirmed if nobody spends the necessary processing power to mine blocks. Confirming transactions requires mining.",
      "This is an excellent question. I think when the last bitcoin is mined a century from now, it is conceivable that mining could be replaced by higher transaction fees. So the blockchains can keep growing and cryptocurrencies could live on forever. Some interesting articles on the topic: https://news.bitcoin.com/what-happens-bitcoin-miners-all-coins-mined/ https://cryptocoinmastery.com/what-happens-when-all-bitcoins-have-been-mined/"
    ]
  },
  {
    "question": "Can I use my wallet on different computers?I'm used to synchronize my data on different machines. Depending on the data I use SVN, Dropbox or SSH (Unison). Is this possible with the bitcoin wallet, too?",
    "answers": [
      "It is, with three provisos. Never run the same wallet on more than one computer at a time. Never run an older copy of a wallet when a newer version exists. If you send any funds, make sure to keep the newer copy of the wallet. Make sure all client programs are linked to the same version of BerkeleyDB. Overall, I think it's just not a good idea. The client software wasn't designed to cleanly handle the many things that can go wrong.",
      "Yes. The only file you need to worry about is wallet.dat (location dependent on operating system). If you copy that one file to another computer (or to a secure backup), you will have access to your money and address book. Conversely, that is the only file you need to protect -- all of the other files should be safe to share without worrying about anyone getting their hands on your money. This only applies to your money and address book . If you only copy wallet.dat , you will need to re-download the entire block chain on the other computer (so you may want to copy the other files too, but it is not necessary). There is no point in backing up the other files, because if you need to, you can redownload everything else. Finally, you should not leave your cleartext wallet in any server that you don't control (such as DropBox). Make sure you encrypt it before backing it up."
    ]
  },
  {
    "question": "What will happen to mining after the 20 999 999th Bitcoin?After the 21 millionth bitcoin or 20,999,999th bitcoin is mined, what will happen to bitcoin mining? - will it just stop, or will we make a further division of the satoshi thanks to Bitcoin's infinite divisibility? Or maybe miners could mine a share of the Bitcoin transaction fee... Any suggestions/mathematical answers are appreciated.",
    "answers": [
      "Assuming Bitcoin is still active at that point in time, mining will continue, because transaction fees will make it worthwhile to do so . This topic has been discussed heavily in other answers, including: What happens once the mining reward gets cut in half? How many bitcoins will there eventually be? How much will transaction fees eventually be? The last link has suggestions that the fee mechanism of Bitcoin may need changing, though that's yet to be proven whether or not it will be a real problem.",
      "Every block has exactly one \"coinbase transaction\", the one transaction which doesn't have actual inputs, but gets all the fees and mining subsidy. Every 210000 blocks, this subsidy halves. Right now, each block is allowed (not required!) to bring 50.00000000 BTC into circulation. Very soon, this will become 25.00000000. Four years later, 12.50000000. And this will continue: 6.25, 3.125, 1.5625, and so on. There are only 8 decimals though, and at some point the subsidy will only be 0.00000001. Four years after that, it will effectively become zero. This will not happen this century, though. This doesn't mean that there won't be any blocks produced anymore. Assuming Bitcoin is still alive, we'll still have blocks being produced every 10 minutes. Miners will just get all their income from fees, without any subsidy."
    ]
  },
  {
    "question": "What is the difference between the rpc port 8332 and port 8333?What is the difference between the protocol and commands used on default ports 8332 and port 8333? From what I gather, port 8332 is the RPC port, it's \"sensitive\", only allowed by local host by default, and it has one username & password. On the other hand port 8333 is some kind of P2P port that is used with Bitcoin transaction replication. Can anyone clarify the official names, purposes, and security of each of these ports? Which one uses JSON, and which is Binary?",
    "answers": [
      "The Bitcoin.org client will try to communicate to other nodes via port 8333 and those communications follow the Bitcoin protocol . If an explicit connection is given (IP address and port) the port setting can be overridden to use any port. The bitcoin.org client can be configured to accept JSON-RPC communications , and when that is enabled will, by default, be on port 8332. Earlier versions of Bitcoin Core permitted this to be secured with SSL communications using the same port or a different port, however that capability has since been removed."
    ]
  },
  {
    "question": "Why are hashes in the bitcoin protocol typically computed twice (double computed)?According to the wiki specification of the bitcoin protocol , hashes are typically \"computed twice\". For example : hello 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824 (first round of sha-256) 9595c9df90075148eb06860365df33584b75bff782a510c6cd4883a419833d50 (second round of sha-256) What is the reasoning for this? I imagine it somehow provides additional security, or protection against potential attack vectors, but I can't reason what those attacks might be.",
    "answers": [
      "We don't know for sure, but the most popular theory is that a double hash was chosen to protect against length extension attacks .",
      "The wiki claim that this is to prevent birthday attacks is wrong. If you can successfully execute a birthday attack on a single call to the hash function, you get a successful birthday attack on the second call. This is easy to see as having hash(x) == hash(y) implies hash(hash(x)) == hash(hash(y)) . If you really wanted to guard against this, you would do something like hash(x||hash(x)) . Finding a collision in a single call to hash in this case would not directly yield a collision in the double call."
    ]
  },
  {
    "question": "Who gets Bitcoin transaction fees?Whenever I send bitcoins from one wallet or one exchange to the next there is always a fee. This makes sense with the exchange sites, they are just collecting the fee so they can make a living. What about the open source wallets that I've installed on my computer? Surely, nobody is collecting my bitcoins because my transactions are too long! So, is the \"fee\" part of the Bitcoin algorithm? Do the coins that are confiscated in the fee go to Bitcoin miners? Also, when does the fee start? I noticed, if I send like 0.05 bitcoins there is no fee, but if I send 0.1 bitcoins there is a fee. What if I just sent 0.05 bit coins twice? Or is it if they are in the same block I will get a fee, so I'd have to send them twice (and 10 minutes apart)?",
    "answers": [
      "The fee goes to the miner who mines the block that includes your transaction. The fee is based on the size (in bytes) of the transaction and the age of its inputs (how long ago the coins spent were received). Transactions get big if they have to \"pull in\" a lot of outputs from previous transactions and that raises the fee. So if you got a lot of small payments and then try to make a large payment, the transaction will be expensive because it needs to gather all those small payments.",
      "From the Bitcoin.it wiki: Transaction fees are voluntary on the part of the person making the bitcoin transaction, as the person attempting to make a transaction can include any fee or none at all in the transaction. On the other hand, nobody mining new bitcoins necessarily needs to accept the transactions and include them in the new block being created. The transaction fee is therefore an incentive on the part of the bitcoin user to make sure that a particular transaction will get included into the next block which is generated. http://en.bitcoin.it/wiki/Transaction_fees The client might send one transaction for free but then for the next transaction (even if it is for a smaller amount) the client might show that a fee is required. This is likely due to the makeup of the remaining coins in the wallet. After your first transaction, any change that was made gets sent back to you but that becomes a \"newly received\" coin. To the network, if that second transaction includes this newly received coin that would look the same as a transaction made by someone trying to harm the network. That type of harmful action tries to re-spend the same funds over and over but without paying a fee. So just like how there might be a candy dish on a receptionists desk and you are free to take one doesn't mean you are free to take all the candy from the dish. That's the same approach here. The client will let you spend coins that have some time passed (i.e., were not just received) without having to pay a fee. If your coins are instead being re-spent within a short amount of time (i.e,. same day), then the presumption is that you could be harming the network therefore a fee is required to prevent that activity. If it was a transaction being made without the intent to harm the network, then requiring a small fee shouldn't be that much of a restriction."
    ]
  },
  {
    "question": "I am new to Bitcoin, how can I get started?I am new to both StackExchange and to the new online currency called Bitcoin. I understand what Bitcoin is and how it works, but I was wondering: how do you actually get started with Bitcoin? I have read some articles about mining and the different things you can do to actually get some money in profit, but none of the articles actually go into depth with how to actually do all these things. I was wondering if anyone in the community could help me and make any suggestions to me and those who want to get started in the new currency.",
    "answers": [
      "We get a lot of questions revolving around the questions and problems faced by new users of Bitcoin. While some of this is beyond your question, this answer might work as a potential lightning rod for some of the questions that get asked anew here almost daily. In the following you find a few hand-picked questions that are likely of interest for new users. What is Bitcoin? What is a good way to concisely explain Bitcoin? What are some good resources for understanding Bitcoin? What's the difference between a wallet and an address? The Bitcoin.it wiki says addresses do not carry balances...but all info suggests otherwise Where to get a wallet? In order to receive and send Bitcoin you need a wallet. What is a good resource to help newbies choose their first wallet/s? How many addresses does my wallet.dat contain? Do I need to make a new backup every time I make a transaction? How do I get Bitcoin? How do you obtain bitcoins? What's a good resource explaining the best ways to buy Bitcoin (noob friendly)? What gives Bitcoins value? Where do bitcoins come from and what gives them their value? How is the exchange rate for Bitcoin established? Where can I spend Bitcoin? Where can I go to find a list of merchants who accept bitcoins? What skills are necessary to use Bitcoin? What's the minimum age to join or use Bitcoin? What software and skills do I need? What is mining? How does it work? What exactly is Mining? What is the rationale behind Bitcoin mining? Can someone explain how the Bitcoin Blockchain works? Is Mining profitable? How can I get started? How much Bitcoin will I mine right now with hardware X? How can I start mining Bitcoin? Why does mining profitability tend towards zero? In the ASIC-age, is it worth starting mining Bitcoin at home? How do I get started with Bitcoin.Stackexchange? Check out our Tour for a quick overview. Some pointers on asking questions: How to Ask More helpful info can be found in the Help Center If you are looking for some interesting reads, check out the most frequently asked questions Swing by our chat: Bitcoin Lounge",
      "Not sure if this is a proper question for this site. But in case it doesn't get deleted: Stay away from scams. Imagine Nigerian princes everywhere but with internet money instead of email. Assume anything except Bitcoin is a scam (and convince yourself of even that fact before investing) until you know enough to judge for yourself or 2 years have passed (whichever takes longer). And then even within Bitcoin: assume everything is a scam. Get proper software or the fake wallets will steal your money. Make your own local private keys, preferably on an offline device (old laptop, dice, Trezor) and store them offline. Never leave coins on an exchange or on a webwallet. If you don't own the private keys you don't own the coins. If you let anyone else generate/hold/steal your keys: you don't own the coins. Cloud mining is a scam and many things related to mining too. Don't get involved in mining unless you are serious and did your homework. Don't believe anyone trying to make things sound simple. Don't believe anyone promising you good things (profit). Bitcoin isn't simple so they probably don't have any clue what they're talking about and/or are lying to you. Never invest more than you can afford to lose (completely). If you don't get scammed out of your money (see above) or lose the keys, the Bitcoin price could go to (near) 0 for other reasons. If you're still reading after the above, read it again, it's quite serious. Here's a list of people and places to follow to get you started on your journey: Gregory Maxwell, Blockstream, alias: nullc on reddit.com/r/bitcoin, on bitcointalk.com and IRC #bitcoin Adam Back, Blockstream Peter Todd www.bitcoin.org (note NOT bitcoin.com) for very good introductory content as well as to pick the right wallet software (consider the Core wallet as it's the only truely trustless method of using Bitcoin). Despite all that, the journey is actually worth it! Enjoy!"
    ]
  },
  {
    "question": "What are the keys used in the blockchain levelDB (ie what are the key:value pairs)?I am wondering if I can use node.js and levelup to access a copy of the blockchain database directly. But from what I can see, I need to know the name of the key(s) before I can get any data, as this is used in the get method of levelup. However, I have not been able to find out anything about the possible key(s) associated with the values in the key value pairs, so I'm at a loss as to how I might retrieve the data. Firstly, what are the keys in the key value pairs, and secondly is it possible just to select the first n records?",
    "answers": [
      "Bitcoind since 0.8 maintains two databases, the block index (in $DATADIR/blocks/index) and the chainstate (in $DATADIR/chainstate). The block index maintains information for every block, and where it is stored on disk. The chain state maintains information about the resulting state of validation as a result of the currently best known chain. Inside the block index, the used key/value pairs are: 'b' + 32-byte block hash -> block index record. Each record stores: The block header. The height. The number of transactions. To what extent this block is validated. In which file, and where in that file, the block data is stored. In which file, and where in that file, the undo data is stored. 'f' + 4-byte file number -> file information record. Each record stores: The number of blocks stored in the block file with that number. The size of the block file with that number ($DATADIR/blocks/blkNNNNN.dat). The size of the undo file with that number ($DATADIR/blocks/revNNNNN.dat). The lowest and highest height of blocks stored in the block file with that number. The lowest and highest timestamp of blocks stored in the block file with that number. 'l' -> 4-byte file number: the last block file number used. 'R' -> 1-byte boolean ('1' if true): whether we're in the process of reindexing. 'F' + 1-byte flag name length + flag name string -> 1 byte boolean ('1' if true, '0' if false): various flags that can be on or off. Currently defined flags include: 'txindex': Whether the transaction index is enabled. 't' + 32-byte transaction hash -> transaction index record. These are optional and only exist if 'txindex' is enabled (see above). Each record stores: Which block file number the transaction is stored in. Which offset into that file the block the transaction is part of is stored at. The offset from the start of that block to the position where that transaction itself is stored. Inside the chain state database, the following key/value pairs are stored: 'C'+ 32-byte transaction hash + output index length + output index (v0.15 onwards) -> A single unspent transaction output (UTXO) record. Each record contains information about the UTXO at the specified output index of the given transaction. This information consists of: Whether the transaction was a coinbase or not. Which height block contains the transaction. The scriptPubKey and amount for this unspent output. 'c' + 32-byte transaction hash (pre-v0.14) -> unspent transaction output record for that transaction. Unlike 'C', this entry represents all UTXOs from a single transaction. These records are only present for transactions that have at least one unspent output left. Each record stores: The version of the transaction. Whether the transaction was a coinbase or not. Which height block contains the transaction. Which outputs of that transaction are unspent. The scriptPubKey and amount for those unspent outputs. 'B' -> 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs. Latest version of bitcoind(please add version compatibility) uses obfuscation of the value in key/value pair . So you need to XOR with the obfuscation key to get the real value. I won't go into the specific serialization details of the particular records. They're often specially designed to be compact on disk, and not really intended to be easily usable by other applications (LevelDB doesn't support concurrent access from multiple applications anyway). There are several RPC methods for querying data from the databases ( getblock , gettxoutsetinfo , gettxout ) without needing direct access. As you can see, only headers are stored inside this database. The actual blocks and transactions are stored in the block files, which are not databases, but just raw append-only files that contain the blocks in network format. As to your second question: what is n ? If you just want to access some records, sure, iterate over the keys and stop when you've read enough.",
      "OK I know I shouldn't really answer my own question but... in the absence of a response to this question, I did a bit of hunting. Github provided the answer in a file found in the bitcoin-leveldb repository. The path to a text file containing the information leveldb->doc->table_format.txt In short, there is no easily describable table like structure. There are several, shall I call them \"nested\" structures in the database including the fact that the database physically stores the data in seperate logical files. Here is the table_format.txt file contents as of this post. File format [data block 1] [data block 2] ... [data block N] [meta block 1] ... [meta block K] [metaindex block] [index block] [Footer] (fixed size; starts at file_size - sizeof(Footer)) The file contains internal pointers. Each such pointer is called a BlockHandle and contains the following information: offset: varint64 size: varint64 See https://developers.google.com/protocol-buffers/docs/encoding#varints for an explanation of varint64 format. (1) The sequence of key/value pairs in the file are stored in sorted order and partitioned into a sequence of data blocks. These blocks come one after another at the beginning of the file. Each data block is formatted according to the code in block_builder.cc, and then optionally compressed. (2) After the data blocks we store a bunch of meta blocks. The supported meta block types are described below. More meta block types may be added in the future. Each meta block is again formatted using block_builder.cc and then optionally compressed. (3) A \"metaindex\" block. It contains one entry for every other meta block where the key is the name of the meta block and the value is a BlockHandle pointing to that meta block. (4) An \"index\" block. This block contains one entry per data block, where the key is a string >= last key in that data block and before the first key in the successive data block. The value is the BlockHandle for the data block. (6) At the very end of the file is a fixed length footer that contains the BlockHandle of the metaindex and index blocks as well as a magic number. metaindex_handle: char[p]; // Block handle for metaindex index_handle: char[q]; // Block handle for index padding: char[40-p-q]; // zeroed bytes to make fixed length // (40==2*BlockHandle::kMaxEncodedLength) magic: fixed64; // == 0xdb4775248b80fb57 (little-endian) \"filter\" Meta Block If a \"FilterPolicy\" was specified when the database was opened, a filter block is stored in each table. The \"metaindex\" block contains an entry that maps from \"filter. \" to the BlockHandle for the filter block where \" \" is the string returned by the filter policy's \"Name()\" method. The filter block stores a sequence of filters, where filter i contains the output of FilterPolicy::CreateFilter() on all keys that are stored in a block whose file offset falls within the range [ i*base ... (i+1)*base-1 ] Currently, \"base\" is 2KB. So for example, if blocks X and Y start in the range [ 0KB .. 2KB-1 ], all of the keys in X and Y will be converted to a filter by calling FilterPolicy::CreateFilter(), and the resulting filter will be stored as the first filter in the filter block. The filter block is formatted as follows: [filter 0] [filter 1] [filter 2] ... [filter N-1] [offset of filter 0] : 4 bytes [offset of filter 1] : 4 bytes [offset of filter 2] : 4 bytes ... [offset of filter N-1] : 4 bytes [offset of beginning of offset array] : 4 bytes lg(base) : 1 byte The offset array at the end of the filter block allows efficient mapping from a data block offset to the corresponding filter. \"stats\" Meta Block This meta block contains a bunch of stats. The key is the name of the statistic. The value contains the statistic. TODO(postrelease): record following stats. data size index size key size (uncompressed) value size (uncompressed) number of entries number of data blocks"
    ]
  },
  {
    "question": "Cryptocurrency Arbitrage - What do I need to know?I'm curious as how one would go about arbitraging crypto currencies - How does it work? what do I need to look out for? What are the risks and caveats?",
    "answers": [
      "Arbitrage - What it is and how it works Arbitrage refers to the process of instantly trading one or more pairs of currencies or odds for a nigh risk-free profit. Usually, this involves two exchanges (this is then called a two-legged arbitrage); although more are, of course, possible. There are several steps when executing an arbitrage: Find a suitable opportunity Execute trades Rebalance accounts Step 1: Find a suitable opportunity This step is relatively easy. Simply check the order books of as many exchanges as you like, compare bids vs asks , and check if you can find a negative spread . A small discourse into what a spread is I will assume you're familiar with bids , asks and what an order book is - if not, you should definitely look up those first. As for the negative spread, I'll elaborate a bit more on that. The spread is what is used to refer to the difference between bids and asks - lowest ask - highest bid = spread . This should be (and typically is) a positive value, since the best bid at an exchange must be lower than the lowest ask of an exchange - otherwise the matching engine of the exchange would settle these orders automatically. In a perfect world, all markets and all market participants would have the same information, hence all top bids and all top asks of all exchanges would be the exact same, after fees were applied. If you've seen the recent US elections, however, you're probably aware that the world isn't perfect, though. Hence, not all participants of a market know the same thing as the others, resulting in bids at exchanges which are higher than the asks at other exchanges - and this is what is called a negative spread . Step 2: Execute trades Let's assume you've found an amazing opportunity at exchange A and exchange B - a negative spread of 100$! Exchange A: Ask 1BTC@450$ Exchange B: Bid 1BTC@550$ Luckily, you have proper funding at both to match these instantly - but how do you go about doing that? Easy! Just place an order on the opposite side at each exchange with the quote's prices! Exchange A: Place Bid of 1BTC@450$ Exchange B: Place Ask of 1BTC@550$ Since your placed order match an order on the opposite side of the book, the trading engine matches them and the trade is settled, leaving you with a theoretical profit of a smooth 100$! Why theoretically, you ask? I'll get to that point further below. Step 3: Rebalance Accounts Unfortunately, you were only able to trade once today, but hey! Tomorrow's another day - but in order to be able to properly trade, you need to even out your balances. Right now, your accounts look like this: Exchange A: 2 BTC | 50$ Exchange B: 0 BTC | 1050$ Hence, you go about and send 1 BTC from Exchange A to Exchange B, and 550$ dollars to Exchange A from Exchange B. No magic here - all accounts are re-balanced and you're ready to make a fortune again, tomorrow. Exchange A: 1 BTC | 550$ Exchange B: 1 BTC | 550$ Arbitrage - Why everyone's not doing it This all sounded wonderful? That's exactly what I thought when I first set out with my own arbitrage bot. However, there a some technical aspects that can really turn a sunny day into a poopy rain on your parade. Caveats and risks 1. It needs to be as close to real-time as possible This is possibly one of the hardest things to get right, and also the most underestimated aspect of arbitrage in crypto currency. The markets, compared to ForEx trading, are ridiculously slow - at busy exchanges, there may be a couple of dozen trades executed. Which gives the illusion, that polling data for bots via the most common API type, RESTful, is enough to trade risk-free. This is a misconception. Maybe for today this may appear to be enough - but what if markets picked up the pace? just 1 trade (or simply a placed order) within one second can change your opportunity from profit to loss. 2. Always trade limits, never market orders Under the aspect of being the fastest, it might seem like a good idea to use market orders in order to be settled asap - you'd be terribly wrong. As discussed above, your data could be as old as 1 second (with above mentioned one order messing up your opportunity) - perhaps someone cleared the entire top level and all you're left with is a bid for twice the price you intended. Yikes. 2. REST API call rates make your life hard Many exchanges employ a API call rate limit - that is, you're allowed to query data at the exchange X times every Y seconds. The differences are wide and nearly every exchange does its own little thing when it comes to limits. The problem with them is, they severely limit your actions. If you don't constantly keep an eye on how often you send a request, you might run into the limit when it seriously counts - for example when you have to cancel an order, because you couldn't place its counter part at another exchange. Unfortunately, websocket APIs are still rare and their brother on steroids, FIX sockets, even rarer - leaving you stuck with the turtle of programmable interfaces. 3. Integration with APIs can be a nightmare There is no unified, standard definition for what an exchange API can do, or what data it returns. Which technically wouldn't be a problem, if they were documented properly. Incidentally, the exchanges with seemingly many opportunities also have the worst documentation (take btc-e.com's Documentation for example - heresy!). Of course, also the opposite is true - GDAX, Kraken, Bitfinex all have excellent documentation. But nonetheless you have to dig through them to understand how they work, what their rates are, how they handle data types, authentication and so forth. That is, if they even mention anything about that. 4. Fees will minimize, if not eliminate your profits In my above step-by-step guide, I purposely omitted fees of all kind. But of course, they're essential to successfully arbitraging. The most commonly known fees, are trade commission fees - these range anywhere from 0.1% to 0.6% and need to be considered in Step 1: Find a suitable Opportunity . On top come fees for deposits and withdrawals during Step 3: Rebalancing Accounts . Depending on your preferred pair, these may range from feasible (transferring crypto currencies usually is cheap enough) to quite steep. For example, a deposit / withdrawal at Bitfinex entails the following fees: Bank wire withdrawal & Deposit: 0.1% of amount deposited/withdrawn, 20$ minimum And this does not include processing fees of your house bank - for me, for example, that's an additional 10€ for deposits, plus a 1% conversion fee. If you do the math you'll quickly realize that you don't even have to bother starting to trade at Bitfinex, unless you have a really big stack to trade with. But this does not just apply to BTC-Fiat pairs. Alt-coins suffer a similar fate. In order to make arbitraging worthwhile, you will have to have enough funds at as many exchanges to make trades AND re-balancing worthwhile. And this quickly gets to a point where you realize your last month's savings aren't equipped to get the job done. To give you a further example on how fees affect your profits, let's take a look back at the example from step 2, this time factoring in all fees. I'll walk you through it. For the argument's sake, we'll pretend to be a european trading BTCUSD at Bitfinex (Exchange A) and Kraken (Exchange B). Bitfinex: Ask 1BTC@450$ Kraken: Bid 1BTC@550$ These prices are raw- they do not include trade commission fees, not transaction fees. Let's add those. We'll define a taker fee of 0.25% at both exchange - the taker fee applies whenever you remove liquidity from the order book. Next, let's add deposit & withdrawal fees to the mix. At Bitfinex, we pay a minimum of 20$ for each fiat withdrawal & deposit, or 0.1% of the moved amount (if its more than 500$). At Kraken, we pay 0.09€ per fiat withdrawal, deposits are free. In addition, btc withdrawals cost 0.0005 BTC at kraken, while Bitfinex charges no fees for this. Deposits cost nothing at both exchanges. Furthermore, we can't transfer fiat directly from exchange to exchange - an additional 10€ fee per sent out transaction needs to be facotred in, as well as 1% conversion fee whenever we receive or send fiat from our bank account (2 times total). Let's list these fees to try and maintain an overview Profit from arbitrage (bid - fee - ask + fee ) Withdrawal Fee Bitfinex (20$) Deposit Fee Kraken (0.0$) Miner Fee for withdrawal at Kraken (0.0005BTC) Transaction Cost of our house bank (10€) (Bank to Bitfinex) Conversion Fee of our house Bank (1% of transfer amount x 2) Let's put some numbers to these: (550 - 550*0.0025) - (450 + 450 * 0.0025) = 97.5$ Move ~497$ to House bank = 20$ 0.0$ 0.0005BTC * 500$ = 0.25$ # Assuming this is the end of day price of the coin 10€ * 1.05 = 10.05$ (497 * 0.02) = 9.94$ Which brings us to net profit of: 57.26$ This translates to 42.74% reduction of your originally seen profit. This is neither a worst, nor a best case scenario - it's merely designed to show you how many hidden fees are involved in an arbitrage. Also, keep in mind that a 22% arbitrage opportunity is practically non-existant. As a matter of fact, had the spread been anything less than 40$, the fixed fees of our house bank and Bitfinex alone would have made our supposed arbirtrage opportunity a loss. 5. Volatility of coins is your enemy \"No matter where the market goes, arbitrage makes a profit anyway!\" This is true - if your currencies don't tend to drop or rise by 50% within 24 hours. Ideally, both currencies you trade in should be relatively stable, while still showing a certain volatility - no volatility would mean the chart is a flat line, resulting in no opportunities for you. The problem with pure crypto currency arbitrage (LTCBTC), however, is that Alt-coins can go completely fubar - as opposed to a fiat-based crypto arbitrage (i.e. BTCUSD). A personal anecdote: When ZEC launched, I was instantly fascinated at the terrible market efficiency and arbitrage opportunities of almost 5% regularly. Hence, I bought in at 1ZEC@1.2BTC, thinking this is probably where market will stay at (at least it's not as bad as the guy who bought a ZEC for 3k BTC). I started arbitraging and immediately increased the amount of ZEC I was holding - completely oblivious to the fact that since I started trading, the price had fallen to 1ZEC@0.1BTC. My ZEC was worth 90% less, and I lost almost half a bitcoin worth of money. Some volatility is great for arbitrage - too much volatility isn't. 6. Exchanges aren't as technically robust as they ought to be Most of the time, you will find that smaller exchanges offer opportunities more often than big exchanges. This is in part due to the previously mentioned slow movement of information, but also their (often significantly lower) trading volume. Initially, this may appear like a steal - but there's usually a reason that particular exchange only has the low volume it currently does. In a time where any one in the world can open up an exchange running on his Raspberry Pi and Ethereum, trading on the more alternative exchanges can be a serious risk to your investment. From things like DDOS attacks and overloaded matching engines not matching your orders, to more serious issues like stuck withdrawals due to too low miner fees, or even theft - and the latter is a very real issue not exclusively affecting small exchanges, as the Bitfinex Heist has shown summer 2016; the list of potential technical failures is long and you should be aware of these at all times. Conclusion I'm aware this answer is overtly negative - this was intentional. Arbitrage, as well as crypto currency in general, is not the quick buck everyone on forums and dubious sites advertising trading bots make you believe. While its inner mechanisms and workings are still quite cryptic* to even the most professional traders (sorry for the pun), even the fabled cryptocurrencies adhere to some basic principles, afterall. The 'quick way to wealth' usually will just end up quickly making you wealthless. (*) Another great myth is that the chinese dictate the BTCUSD market. There is no empirical proven correlation between chinese and american markets. The only defacto correlation that has been found was that of google searches for bitcoin to btc trading volume - but whether this was positive or negative was inclonclusive. Please feel free to add, comment or make improvement suggestions!"
    ]
  },
  {
    "question": "My raw transaction destroyed 0.0284377 BTC. What did I do wrong?Years ago I designed a .NET module which facilitates the transmission of BTC to my customers. It creates a binary representation of the desired transaction based on the material presented here and here : The binary representation is then converted to hex and pushed out through various free services like BlockExplorer, BlockCypher, etc. The system has been running flawlessly for years. Until yesterday. A customer requested that 0.0284377 BTC to be sent to 38MRMGjMBMp4k7vZhKLHhcM9Pm8AMLy18v . He never received it. Sure enough, he was right. It was never sent. I looked through all of my logs and saw that my software did in fact submit a transaction with the following inputs and outputs: input: 13P38hMYJXFdxDJJn8TtPUJZFXmcpf2J99 output #1: 38MRMGjMBMp4k7vZhKLHhcM9Pm8AMLy18v (my customer) output #2: 1Ny3CV3rAsNMWpLfpxhXW3Fh71YmMEXXU7 (my change address) Everything looked fine on my side but sure enough, when I looked on block explorer, what I saw shocked me. Consider transaction 9a138b14dcc8ae740073c06933ae04e3b08fe6be6ada0dc175e6484250dfe269 and look at the inputs and outputs: As you can see, my input is correct. My change address XU7 is also correct. But now look at my customer's address. It says 17fQRjEudTVgexE8aDfhGyzDFEqSnnJJCA (which I'll refer to as JCA) instead of the expected 38MRMGjMBMp4k7vZhKLHhcM9Pm8AMLy18v (which I'll refer to as 18v). What the heck? The JCA address is known neither to me nor to my customer. It's a completely unknown address. Clearly the problem is in my code somewhere so I dug deeper to find out what made this particular transaction unique. I identified that his desired address (18v) begins with a '3' whereas every other outbound transaction I've completed throughout the history of my app has targeted addresses beginning with '1'. My stopgap measure was to force users to only specify addresses that begin with a 1. But that's a temporary solution. I need to find out what I'm doing wrong. I turned to Google. Research indicated that addresses beginning with '3' are typically SegWit addresses where as those beginning with '1' are traditional, old-school addresses. I remember all the talk about SegWit a few months back but I figured it didn't affect me and my legacy transactions would still clear properly. Obviously that was a bad judgement call on my part so now I have to figure out what I did incorrectly and where the bogus JCA address came from. That's where I'm stuck. I think my problem might have to do with uncompressed vs. compressed public keys based upon discussions here and here : Here's what I do know: When it comes time to create the outputs for my transaction, my code does the following (explanation follows): Func makeOutScript=(btcAddrHex)=>{ byte[] addrBytes=BTCUtils.Base58Decode(btcAddrHex); byte[] pubKeyBytes=addrBytes.Take(addrBytes.Length-4).Skip(1).ToArray(); using(MemoryStream ms=new MemoryStream()){ using(BinaryWriter bw=new BinaryWriter(ms)){ bw.Write((byte)0x76); //op_dup bw.Write((byte)0xa9); //op_hash160 bw.Write((byte)20); //size of public key bw.Write(pubKeyBytes); //public key bw.Write((byte)0x88); //op_equalverify bw.Write((byte)0xac); //op_checksig bw.Flush(); return ms.ToArray(); } } }; What I'm doing here is: Converting the output address to bytes by Base58 decoding it. I strip off the last four bytes, which are the checksum, and the first byte, which is always 0x00 (apparently a network indicator of some sort). That leaves me with the raw public key. Actually, looking at my internal notes, it's not actually the public key but rather 0x04 prepended to the public key and then passed through SHA256 and then RIPEMD160. But I'll refer to this blob as the public key. From there the byte sequence is 0x76, 0xa9, 20 (the size of the public key blob), the public key blob itself, 0x88, and 0xac. I don't pretend to understand what all those single-byte entries mean but the blog posts above said to include them so that's what I did, and until now it's worked just fine. The question is: How on earth did the 18v address get transformed into the JCA address when it was submitted to the network? Is my \"size of public key\" value (20) incorrect, perhaps? At a gut level, it does seem odd that a compressed (18v) and uncompressed (JCA) public key would both have a constant size of 20. But maybe I'm on the wrong track entirely and compression has nothing to do with it. I don't have to tell you how awful it would be if this transaction were 100 BTC instead of 0.0284377. I lucked out that my bug was triggered on a low value transaction. But I really want to solve this. Can you point me down the right path?",
    "answers": [
      "Addresses that start with 3... are P2SH addresses , and they've been around for almost 6 years now. Historically they saw limited use - used by multisig wallets like Copay and GreenAddress. The compatibility mode of SegWit however also uses P2SH, making their use more common recently. The main issue is that your code for converting an address to a scriptPubKey does not look at the version byte. After Base58 decoding the address, you should get <1-byte version> <20-byte hash> <4-byte checksum> structure. If that version is 0, which it is for 1... addressses, that hash is a public key hash, and you correctly construct the corresponding scriptPubKey. However, if that version number is 5, it is a P2SH address, which was specified in BIP13 , which uses a corresponding scriptPubKey specified in BIP16 . While SegWit initially just used the old P2SH format, A new address format is being introduced for SegWit as well (which gives slightly better performance, flexibility, and error detection capabilities), described in BIP173 . (disclaimer: I'm an author of BIP173). These addresses will start with bc1... . I advise you to stop your service, and at the very least implement verification that the version number is expected, together with a test set you can find in many implementations. If you feel like it, you can also implement BIP13 and BIP173 addresses, both of which will likely become more prevalent soon."
    ]
  },
  {
    "question": "How do I accept bitcoin payments at a real world store?From what I understand, there are some requirements for using bitcoins at a physical store: Both the store owner and the client must have Internet access The client must have a cellphone or a laptop to issue the payment The seller must have a way to confirm that the coins were sent. The biggest problem is the confirmation. Since it is risky to accept transactions with 0 confirmations, it will take around 10 minutes before a single confirmation occurs and allows the real world transaction to be completed. The more confirmations that occur, the less risky it is. That said, what is the best way for a store owner to securely accept bitcoins?",
    "answers": [
      "Green address technique from Instawallet. System sends bitcoins from well known address called Green Address and if recipient trusts Instawallet or any other major organization that uses same technique, then he or she can accept payment without waiting for confirmations. This is what already implemented but it solves only the third problem. Instant TX for established business relationships is in early development stage but it can solve all three of the problems, with an exception that only retailer needs to have internet access. For example, transaction could be printed by customer on a piece of paper, handed over and accepted instantly by retailer, and it still would be secure. The idea is very promising because such transaction could be sent over internet or by any other way directly from buyer to seller and won't use any of Bitcoin Network resources, and it would be economically fisible to make automatic payments for a service that costs several micro bitcoins.",
      "One thing people fail to realize when saying \"0 confirms are risky\" is that risk is all relative. A lot depends on how valuable the goods are. While 0 confirmation may have some risk it is very low for low value transactions and likely far less than credit card fraud. Say you are selling a sandwich for whatever $5 is worth in BTC. When you get a 0 confirm it has indicated that your client sees that address has sufficient value to complete the transaction. The risk is simply that before confirmed someone else could purchase something with the same address, a hypothetical \"double spend\". Still remember the window of attack is very small. The AVERAGE block completion time is 10 minutes but ~50% of blocks are completed in less than 6 minutes. That means if two attackers timed it so they started their attack right after a block was discovered they have roughly 50% chance of getting both transactions completed prior to next block verification. To be defrauded BOTH transactions would have to be fully completed and the attacker gone within that window. For low value transaction especially in the real world that is incredibly unlikely. No attacker is guaranteed any sort of \"minimum window\" the next block might be verified in 10 minutes or in 9 seconds. Now if you are selling $100K worth of gold then maybe you should wait for 6 confirmations but a customer moving $100K worth of gold likely would understand the need for security. Unless your physical world business involves both fast transactions AND high street value I wouldn't worry. A bitcoin ATM however would be a good target for double spending thus some other mechanism would be needed to verify the transfer."
    ]
  },
  {
    "question": "What are checkpoints?I often read that checkpoints protect the network from a 51% attack because an attacker cannot reverse transactions made before the last checkpoint. How exactly does this checkpoint mechanism work? And who creates the checkpoints?",
    "answers": [
      "The checkpoints are hard coded into the standard client. The concept is, that the standard client will accept all transactions up to the checkpoint as valid and irreversible. If anyone tries to fork the blockchain starting from a block before the checkpoint, the client will not accept the fork. This makes those blocks \"set in stone\".",
      "Update on this as of time of writing, just to clarify more specifically upon the other answer: dependence on checkpoints in the security model has been significantly reduced, they are only used in one very specific case now. That case is just to ignore forks from the chain early on, before the most recently seen checkpoint. When a node has seen a block it recognises as a checkpoint, any further blocks received below that height will be ignored. You can see this here: https://github.com/bitcoin/bitcoin/blob/0dfc25f82a01d9fec26380d95915df31e1fe2c02/src/validation.cpp#L3107 It is a long term goal of removing the checkpoints entirely, because they are a source of confusion over the security model and power the developers have. But currently the role they serve is to prevent low difficulty header flooding attacks, and there has been no alternative solution proposed yet (that I know of)."
    ]
  },
  {
    "question": "What are orphaned and stale blocks?If I understand it right, a stale block is a block for which an earlier confirmation has been found and was accepted by majority of people. This block is considered invalid and is later never used. But what is a orphaned block. How is it created? How is it verified that it is orphaned and what is done to the orphaned block?",
    "answers": [
      "There are several definitions with overlapping meanings. The first is perhaps best called extinct blocks. These are blocks that were produced by building on a block that is no longer the active tip of the chain. Some nodes may have considered it to be the best block at some point, but they switched to another chain which does not contain the relevant block anymore. They are valid, verified, and their ancestry up to the genesis block is fully known - they're just not currently 'active'. They are sometimes called stale blocks (typically in the context of mining software realizing it built on old data) or orphan blocks. The latter name originates from the fact that payouts from extinct blocks are denoted as \"orphaned\" in the reference client (referring to the fact that their coinbase transactions are now orphaned). However, there also exist real orphan blocks, with orphan in its original meaning of \"having no parent\". These are blocks received by a node that does not have its entire ancestry (yet) and thus cannot be validated. Nodes keep such blocks in memory, while asking their peers to fill in the gap of their history. The client does not show these, so when people talk about orphan blocks, they are most likely referring to extinct blocks. Note that since Bitcoin Core v0.10, there are no such orphan blocks anymore, due to a significant change in the download mechanism. Terminology is confusing here :)",
      "Stale blocks : At any second, a block may be \"solved.\" This means that everyone else in the world working on that block must stop, and restart their work. Continuing to work after that point is known as working on a \"stale block\" because it is old data, and old transactions. My understanding is the term stale is much more commonly applied to shares when mining in a pool, so you're more likely to hear about stale shares than stale blocks. In this case, the pool probably wouldn't even bother checking whether the share actually solved a block or not. Orphaned blocks : Detached or Orphaned blocks are valid blocks which are not part of the main chain. They can occur naturally when two miners produce blocks at similar times or they can be caused by an attacker (with enough hashing power) attempting to reverse transactions. My own understanding is that orphaned blocks are initially accepted by the majority of the network, but are later rejected when proof of a longer blockchain is received that doesn't include that particular block. This means that a user could see a transaction as having one confirmation and then, if a longer blockchain was received that didn't include the transaction, it could change back to 0 confirmations."
    ]
  },
  {
    "question": "How does Ripple solve the double-spend problem?How does the Ripple system solve the double-spend problem? Does it also use some block-chain-like entity that officially dictates which transactions are confirmed and which are not, or does it use some other clever mechanism?",
    "answers": [
      "The details are very complex, but the core concept is fairly simple. Ripple solves the double-spend problem by consensus. The analogy I use is an \"agreement room\". To walk into the room, you have to agree with everyone who is already in there. If you want to disagree, you have to leave and form your own room. Everyone who is honest wants to get into the biggest room they can with the most people in it. In the room, people constantly agree on the current state of the system. It's implemented as a hash tree, so that's just one 256-bit number. To perform a transaction, you walk into the big room and read out the transaction. Everyone checks the transaction against their ledger. Assuming there's no conflicting transaction or other problem, everyone agrees that the transaction is valid and they include it in the set of transactions they believe should be applied. They then work on any disagreements they have by an avalanche process. Essentially, if someone is voting yes on a transaction that doesn't have overwhelming majority support, they just change their vote to no. This ensures there's a quick agreement on a set of transactions. Once a set of candidate transactions is agreed upon, those transaction are applied and everyone computes the next ledger according to a set of deterministic rules. They all sign it, publish those signatures, and now clients know which transactions have been accepted by the consensus process. If a transaction doesn't get in for some reason, but it's still valid, every honest person in the room will say yes to that transaction in the next round. So, back to the double spend problem. A double spend is essentially two transactions, each of which is valid if and only if it's applied before the other. Thus solving the double spend problem \"merely\" requires agreeing on an order for the two transactions. If everyone agrees which comes first, the problem is solved -- the one that comes first is applied and thus the other is invalid. In the Ripple system, if two transactions are a double spend, one of three things can happen: One transaction will get voted into a consensus set before the other. In this case, that transaction will be in a ledger signed by all the people in the room, forever invalidating the other. Both get into the same consensus set (this should almost never happen). In this case, a deterministic rule when the consensus set is applied determines which gets into the ledger, forever blocking the other. Neither gets into a consensus set because neither gets a majority and both transactions are at around 50%. In this case, every node that sees both transactions (which will quickly be the vast majority of nodes) will vote yes on the transaction that wins by a deterministic rule and no on the transaction that loses by that rule. The one that wins by that deterministic rule will get in the consensus set, be applied to the ledger, and forever block the other. That's a gross oversimplification, but it's inherently fairly complex.",
      "@David's answer essentially doesn't talk about an attack scenario where the room is full of dishonest nodes. This is essentially what the proof-of-work was designed to fix. If you get a hold of a lot of IPs (nodes in the Ripple network) you could become a majority in the room. The difference is that it's really easy to get an IP, but extremely hard to prove you work in a proof-of-work system (like Bitcoin's). For my understanding, Ripple doesn't solve the double-spending problem mathematically, as Bitcoin does (assuming honest nodes are overpowering the network). It solves it using a distributed consensus system that can easily be overthrown if you can obtain the majority of the IPs and you act honestly for a while, making other nodes trust you. In conclusion double-spending is possible with both Bitcoin and Ripple, but with Bitcoin it's much harder to double-spend because the system is based on a mathematical race against the proof-of-work system, whilst Ripple relies on consensus of a number of nodes that can be more easily reproduced by an attacker."
    ]
  },
  {
    "question": "Do unconfirmed transactions expire?Do they just sit there unconfirmed (e.g. when you be evil and don't pay a tx fee) forever? Or do they get deleted after a few days?",
    "answers": [
      "Most clients on the network have a transaction pool in their memory. The same basically applies to miners: they just dump the top 500KB (or some other value) transactions into a block, sorted by transaction fee (descending, of course). When there aren't many transactions, maybe because of a series of block in a short amount of time, it will be confirmed anyway. But to answer your actual question: yes, transactions (sort of) expire. When you send a transaction, it sends a tx frame to all connected peers. These peers store the transaction in their memory pools and tell all their connections that they have a new transaction. When those connections don't have it yet, they ask for it, and that's how a transaction spreads over the network. At some point every node in the network will have the transaction in their memory pool, and at that point it will no longer be sent over the network. Now when a user restarts their client, the memory pool is wiped, and the transaction is deleted from that computer. (Plus a few other ways to delete transactions from the pool) Because of that it's very unlikely for the transaction to be gone from the entire network, but in case it does happen: the reference client will automatically re-send the transaction every x hours(/minutes?) when it's still not confirmed. Oh, and I forgot the most important part: transactions on Bitcoin ( tx frames in the protocol) don't have a 'time' field, which means that transaction expiration can't be a feature of Bitcoin. To summarize: yes, the transaction can expire, but that is really unlikely.",
      "I recently sent 0.03 BTC to Satoshi Dice without a tx fee from a blockchain.info wallet. It stayed for about 3 days without being confirmed and it finally expired. At some moments while the tx was unconfirmed the network propagation was dropping to 2 nodes and then going back up to about 50 nodes. After it expired the sum of the transaction was added back to my balance. Any details of the transaction disappeared from my wallet and from the block explorer... Several hours after the expiry a new transaction has been issued automatically with the same amount to the same Satoshi Dice address."
    ]
  },
  {
    "question": "What is a stealth address?Stealth addresses are mentioned in the context of privacy of bitcoin transactions. What are they and how would they work? Can they provide 100% anonymity?",
    "answers": [
      "As I understand it, the \"stealth address\" is intended to address a very specific problem. If you wish to solicit payments from the public, say by posting a donation address on your website, then everyone can see on the block chain that all those payments went to you, and perhaps try to track how you spend them. With a stealth address, you ask payers to generate a unique address in such a way that you (using some additional data which is attached to the transaction) can deduce the corresponding private key. So although you publish a single \"stealth address\" on your website, the block chain sees all your incoming payments as going to separate addresses and has no way to correlate them. (Of course, any individual payer knows their payment went to you, and can trace how you spend it, but they don't learn anything about other people's payments to you.) But you can get the same effect another way: just give each payer a unique address. Rather than posting a single public donation address on your website, have a button that generates a new unique address and saves the private key, or selects the next address from a long list of pre-generated addresses (whose private keys you hold somewhere safe). Just as before, the payments all go to separate addresses and there is no way to correlate them, nor for one payer to see that other payments went to you. So the only difference with stealth addresses is essentially to move the chore of producing a unique address from the server to the client. Indeed, in some ways stealth addresses may be worse, since very few people use them, and if you are known to be one of them, it will be easier to connect stealth transactions with you. It doesn't provide \"100% anonymity\". The fundamental anonymity weakness of Bitcoin remains - that everyone can follow the chain of payments, and if you know something about one transaction or the parties to it, you can deduce something about where those coins came from or where they went.",
      "This page on the bitcoin wiki explains the exact procedure for generating and using a stealth address. It's not very user friendly at this point in time and is considered experimental. Simply: Receiver generates a an address and a private secret and then sends this address to someone who he wants payment from. Sender uses the address and a \"nonce\" to generate the address he/she can send funds to. Sender communicates the nonce to the receiver and by using this nonce and the secret key generated earlier he/she can unlock the address with the funds. The stealth addresses are based on the Elliptic curve Diffie-Hellman protocol and in theory this method is anonymous. As this code is relatively new however there may possibly be bugs."
    ]
  },
  {
    "question": "What is a deterministic wallet?It sounds as if it's a process that enables a wallet to be rebuilt from a passphrase, or from several fragments scattered about. Could someone provide a detailed technical explanation?",
    "answers": [
      "You've hit the nail on the head. A deterministic wallet is any system which uses a passphrase or other snippet of data to build a keypair in a repeatable manner. So long as you remember the passphrase, the keypair can be re-generated from it, so storage is no longer a security concern. There are several methods for generating deterministic wallets, but my favorite is Casascius' Bitcoin-Address generator (C#, Windows, binaries here )",
      "Normally, when you send money you also generate a new private/public key for the \"change\" to return. therefore every time you send money your wallet.dat grows a little bit. The Basic Idea of the deterministic wallet: instead of a database with lots of private/public keys you start with a single private key, from which all future keys can be calculated. This has many advantages. It is trivial to back up and transferable. it could be used from multiple computers. afaik, webcoin.ch uses this concept. The current \"official\" client not."
    ]
  },
  {
    "question": "What are Green Addresses?What are Green Addresses? Is it true that they can solve the \"confirmation delay\" problem, and how does that work? Are there any drawbacks?",
    "answers": [
      "The green address is a third party trust trick and can help resolve most problems related to the need to wait for confirmations (slow transactions). To make it very simple : Service A publishes its green address, service B decides to trust service A. When someone send bitcoins from service A to service B, he will send from the service A green address. The service B knows he can trust the service A, he knows A won't double spend, so B can credit the sent bitcoins immediately, without waiting for confirmations ( or waiting for just one confirmation, which is probably wiser ). This is mostly useful for transferring bitcoins b2b (business to business), typically it would help making arbitrage easier and faster between 2 bitcoin exchanges, if both decide to trust each other's green address. This can also be useful to allow for POS (Point of sales) with instant transactions if the POS can trust the green address of your bitcoin bank (or online wallet) As an individual, I could also negotiate with my local supermarket to trust my green address (providing them my IRL address, ID number and more if needed). Once they decide to trust my green address, I can pay immediately with bitcoins at my local supermarket (they trust me and won't need to wait for confirmations). The green address is just a bitcoin address, but it's a \"from\" address people decide to trust and accept transactions from this address without waiting for confirmations. Possible drawbacks are : Less anonymity, or even no anonimity at all ( always using the same public from address), which is not a problem for a business, and its even great for public accounting/auditing ( yes bitcoin can also help fighting corruption ! ) Blockchain spam (more transactions for the bitcoin network), which is a good thing if the blockchain can scale. Encourages people to use trusted wallet providers (some kind of bitcoin banks). Here too, this have good and bad sides. It's not enough to create a green address, you still need to be trusted so that your green address is useful For now, afaik, only mtgox.com , btcpak.com and instawallet.org support the idea. To be useful, green address system needs to be widely adopted by bitcoin pools, exchanges, online wallets, businesses, etc. See also https://en.bitcoin.it/wiki/Green_address ( edit 11 years ago, october 2020 , this reference is no more very relevant, some people completely rewrote the wiki page years later,for obscure reasons . . . they even replaced the first line with a blockstream ad . . . but you can still go and check the earliest versions of this page, around 2011-2012 , by clicking the \"history\" tab of the wiki page )",
      "As a few have suggested, Green Addresses '1.0' had issues. Some improvements that were suggested as early as in 2011 which you can see implemented in GreenAddress prevents users from double spending transactions via multisignature thus allowing zero confirmation for third parties that trust the GreenAddress provider, yet preventing users from risking their funds in someone else's online wallet. See also this blog post about 0 confirmations or the design/'whitepaper'"
    ]
  },
  {
    "question": "How to check if the block chain is up to date using bitcoind or json-rpc?I read the full api method list and did not seem to find one. I suppose there is no command specifically for that purpose, so what is the general way of doing this? I would consider checking the time stamp of the last generated block, but the getblock method is not really explained in much detail. EDIT: Some people answer that I should compare the block count with one of an online block chain monitor. That is not really a practical solution. The Bitcoin-Qt client has a way of knowing when syncing is done (the V-sign vs the syncing icon), so why doesn't bitcoind? How does the Bitcoin-Qt get this information?",
    "answers": [
      "I use a python script that grabs http://blockchain.info/q/getblockcount and compares it to the output of bitcoind getblockcount . As others have said, there is no absolute way of telling if your blockchain is up to date. Anyway, here is my script: import httplib2 from bitcoinrpc.authproxy import AuthServiceProxy access = AuthServiceProxy('#########') try: blockCount = access.getblockcount() except Exception as e: print \"Problems connecting to bitcoin wallet:\" else: try: response, trueBlockCount = httplib2.Http().request(\"http://blockexplorer.com/q/getblockcount/\") except Exception as e: print \"Unable to get true blockcount from blockexplorer:\"+str(e) else: if (int(trueBlockCount) - 5) > blockCount : print \"blockchain not up to date: true block count is: \"+str(trueBlockCount)+\", while bitcoind is at: \"+str(blockCount)",
      "There is no way for checking whether syncing is done, simply because it isn't known . Slightly abstractly, and probably not useful in your case, the client is always syncing: there is no real difference between \"having all blocks\" and \"not having all blocks\" - it always has all blocks that it knows about, and doesn't know whether there are blocks which it misses. What the GUI shows you is a guess. It checks the age of the last known block, and if it is (IIRC) more than 90 minutes ago, it assumes it's out of sync. This is usually a good indicator, but it will rarely yet certainly randomly fail from time to time. The core code has another heuristic built-in, which uses block heights reported by other nodes (without verifying that information in any way, so it's easily cheated). This information is used to determine whether it should optimize cache behaviour for many fast operations, or reliability. It's not exposed directly either, but the getwork() and getblocktemplate() RPCs will fail in this mode."
    ]
  },
  {
    "question": "How to fork Bitcoin and build own cryptocurrencyIs there any step-by-step tutorial about how to build own cryptocurrency based on Bitcoin code?",
    "answers": [
      "To start a new chain, use a genesis generator , apply the new genesis to the source , and remove the checkpoints . If you want to apply new/different rules, be prepared for a difficult task. Changing even the slightest protocol rule will most likely affect all other rules because of the complexity of PoW. If the only thing you want to alter is the maximum coins, this should be relatively easy to alter in the source .",
      "There is a Complete Guide on How to Create a New Alt Coin on Bitcoin Talk."
    ]
  },
  {
    "question": "How are transactions broadcast to the rest of the network?If a person sends a transaction to another person, and Bitcoin is a peer-to-peer application, how will the transaction get to the rest of the Bitcoin community? How does everyone have the same blockchain? Does every system know about every other system in the network? If so, how?",
    "answers": [
      "If a person sends a transaction to another person, and Bitcoin is a peer-to-peer application, how will the transaction get to the rest of the Bitcoin community? Think of it like how gossip would spread. There are a bunch of people (nodes), and when one of them knows something, they tell it to the few (8 or so) people they are near (connected with), and then those people tell a few more people the message that was told to them, and then... Eventually everyone knows about the original information (transaction). So when we say bitcoin is peer-to-peer, we mean it's just nodes that have internet connections (on port 8333 usually) with other peers. Not even necessarily the one you're sending the coins to! How does everyone have the same blockchain? After peers exchange their information (and validate that all transactions and blocks follow the protocol rules), they store it. Since all of the bitcoin transactions from the beginning of the bitcoin block chain are needed to validate everything that has taken place, essentially all full nodes store the same data (about 27.5 GB of pure block chain data as of now). Does every system know about every other system in the network? If so, how? No need to know about every other system on the network, each node just knows about the 8 or so nodes that it is connected to!",
      "According to https://en.bitcoin.it/wiki/Satoshi_Client_Node_Discovery DNS Addresses Upon startup, if peer node discovery is needed, the client then issues DNS requests to learn about the addresses of other peer nodes. The client includes a list of host names for DNS services that are seeded. As of December, 2017 the list (from chainparams.cpp[1]) includes: seed.bitcoin.sipa.be dnsseed.bluematt.me dnsseed.bitcoin.dashjr.org seed.bitcoinstats.com seed.bitcoin.jonasschnelli.ch seed.btc.petertodd.org A DNS reply can contain multiple IP addresses for a requested name. Addresses discovered via DNS are initially given a zero timestamp, therefore they are not advertised in response to a \"getaddr\" request. Hard Coded \"Seed\" Addresses The client contains hard coded IP addresses that represent bitcoin nodes. These addresses are only used as a last resort, if no other method has produced any addresses at all. When the loop in the connection handling thread ThreadOpenConnections2() sees an empty address map, it uses the \"seed\" IP addresses as backup. There is code is move away from seed nodes when possible. The presumption is that this is to avoid overloading those nodes. Once the local node has enough addresses (presumably learned from the seed nodes), the connection thread will close seed node connections. Seed Addresses are initially given a zero timestamp, therefore they are not advertised in response to a \"getaddr\" request."
    ]
  },
  {
    "question": "Who runs www.bitcoin.org?The original client that can be downloaded from www.bitcoin.org is often referred to as the \"official client\". Similarly many regard www.bitcoin.org as the \"official homepage\" of the project. So, who runs it? Is it the core developers? Some Bitcoin association? Or just a private person?",
    "answers": [
      "Collecting some of the publicly available information that I found. Martti Malmi ( aka Sirius ), a student of Aalto University in Finland, was one of the core developers early on in the project. Satoshi attributed some of the new features of version 0.2 to him here and he was the one making the first commits to the Sourceforge repository back in August 2009. He was removed from the list of project developers on bitcoin.org in June 2011. As Andrew points out in his answer, both bitcoin.org and bitcointalk.org is owned by Martti. He is the administrator of the bitcointalk.org forums, still active there, and could most likely be contacted using the PM feature on the forums. Both Martti and Gavin Andresen (lead developer) have access to the bitcoin.org website. Edit September 25th, 2011 : The code for the bitcoin.org website is now hosted under the Bitcoin project on GitHub . This means that you can post issues/suggestions there or make a pull request if you wanna add or change something.",
      "As pointed out by theymos on Bitcoin Talk, both bitcoin.org and bitcointalk.org are owned by Sirius ."
    ]
  },
  {
    "question": "What is TxIn's sequence?I'm currently trying to generate the genesis block with my code and I've stumbled upon the TxIn sequence field that is not explained in the Protocol Specification wiki page, nor does it seem to appear in the block explorer . What is the way the value of this field is calculated, and what was its value for the genesis block?",
    "answers": [
      "Sequence numbers aren't shown on the Bitcoin Block Explorer HTML pages because they are not used by the network currently. Non-default sequence numbers would be shown on raw block/tx pages, but I'm not sure whether this has ever happened. Sequence numbers are intended to be used for replacement. Replacement is currently disabled, but how it would work is: You send a transaction with a LockTime in the future and a sequence number of 0. The transaction is then not considered by the network to be \"final\", and it can't be included in a block until the specified LockTime is reached. Before LockTime expires, you can replace the transaction with as many new versions as you want. Newer versions have higher sequence numbers. If you ever want to lock the transaction permanently, you can set the sequence number to UINT_MAX. Then the transaction is considered to be final, even if LockTime has not been reached. This is useful in several cases. For example, two parties can use it to set up a \"prepared transaction\". Once the prepared transaction is created, the parties can move money between each other instantly, securely, and without fees. So you could set one of these up with an exchange and withdraw and deposit without waiting for confirmations. Since replacement is not used currently, all transactions Bitcoin creates have LockTime = 0 and Sequence = UINT_MAX. This is the case with the genesis block's generation transaction.",
      "Note that the accepted answer is outdated. Currently, sequence numbers are mainly used for signaling RBF - replace-by-fee - that allows you to resend a transaction with a higher fee. See https://bitcoincore.org/en/faq/optin_rbf/ , https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki"
    ]
  },
  {
    "question": "What is the coinbase?I searched the bitcoin wiki and found references to coinbase, but no clear cut explanation of what exactly it is. I know that miners can tag their coinbases (that is how some sites tell who mined a block).",
    "answers": [
      "The term \"coinbase\" is used to mean many different things. But the two you're probably asking about are: The \"coinbase transaction\" is the transaction inside a block that pays the miner his block reward. Inside the coinbase transaction is a field that is called the \"coinbase\". It's the generation transaction's equivalent of a scriptsig. Since it doesn't claim any existing outputs, it needs no normal scriptsig. It's basically just a random value that the miner can use as an additional nonce. BIP 34 changes this a bit.",
      "David has already given a good explanation of the term coinbase, but I'd like to give further details on the coinbase transaction . The coinbase transaction is a special type of transaction. Every block must have a coinbase transaction, other transactions are optional . The coinbase transaction must be the first transaction of the block (it follows that there can only be one per block). The coinbase's output is used to send the block reward, i.e. block subsidy plus transaction fees, to the miner's address. The coinbase transaction can have an arbitrary input of 100 byte size. E.g. this was where the genesis block famously contained \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\". This is also the field that may be used for the extranonce ."
    ]
  },
  {
    "question": "How is it possible to launder bitcoins?Some services, such as bitcoinlaundry.com , claim that they can launder your bitcoins. Since all bitcoin transactions are publicly logged, how is this done? Wouldn't it be possible to trace back the transactions and find out the initial address?",
    "answers": [
      "Say I received 10 bitcoins on a Bitcoin address I publicly advertise for donations. Anyone looking at the blockchain can put that address in a search engine and find me. Now say I want to use those 10 bitcoins to buy drugs. If the drug dealer's bitcoins are traced, they'll point right back to me. Now I can create a lot of accounts if I want. And I can pass the 10 bitcoins I received through those accounts and then to the drug dealer. But likely because those accounts aren't used anywhere else, the trail would still lead right from the drug dealer to me. Now suppose I put my 10 bitcoins in an account created just for me by a Bitcoin laundering service. And you and Fred do the same thing. Then the service sends my coins to Fred and your coins to me. Then I spend the coins I got on drugs. Now the trail looks exactly the same as in the non-laundering example, except the trail leads straight to you instead of me -- a pretty good deal for me, not so much for you.",
      "If you purchase a bunch of Bitcoins with dirty money, and then sell the Bitcoins for clean money - you have essentially laundered your money with Bitcoins. You can then claim that your income came from Bitcoin mining, and it would be difficult to investigate. It is exceedingly difficult to anonymize your Bitcoin transactions. I think the appeal is that it adds an extra hoop for the IRS to jump through. Not only is it possible and proven that people can trace transaction origins, but it will likely be easier to do in the future if the Bitcoin core remains unchanged in this respect. Bitcoin anonymity is a fallacy."
    ]
  },
  {
    "question": "How to save bitcoins as paper?I would like to save some of my bitcoins on a piece of paper with QR code printed on it. What would be the easiest way to do it without using Mt Gox. or similar. Just bitcoins (I'm not afraid of some programming if it's needed).",
    "answers": [
      "Currently the most popular method is to use something like pywallet to export your public/private keys and simply generate a text QR code for them. Typically separate QR codes are generated for the public key and private key so that one code may be used to receive payment without giving away the private key which allows spending from the account. There are some alternatives, however, depending on your paper wallet needs. Casascius' Bitcoin Address Tool is an excellent way of saving bitcoins in an easy to recover format. Though it doesn't yet support QR codes it does have the ability to generate a paper wallet from any passphrase. Once generated you could store the public and private keys as QR codes using any of a number of applications or online generators. Additionally, you could store the passphrase in a QR code and use it to recover your addresses at any time. I specifically suggest this as opposed to simply exporting keys with pywallet and QR-ing them because this method would let you store more than one wallet address using a single QR code since any passphrase can generate up to 999 addresses deterministically in such a manner. Of course having a simple public key in QR code form also lets you scan the address with a smartphone or computer to send coins, so ultimately the solution depends on your usage.",
      "Use bitaddress.org . It is a single HTML file so you can save it and generate addresses offline for extra security."
    ]
  },
  {
    "question": "Is there any point to casual mining?Is there any point to casual mining anymore? I recently discovered bitcoin and was wondering if there was any point to running mining software on my laptop while I work on essays or other non-computationally intensive task. I tried looking around, but answers seem conflicted on if casual mining is possible. I mean will I get any bitcoins from it, not is it profitable per unit cost of electricity. Will I get anything in a reasonable timeframe or is that now a thing of the past? By anything I mean, the silly 0.1BTC I see stuff put up for on http://forbitcoin.com and such, not hundreds of dollars to supplement my income.",
    "answers": [
      "TLDR: Rough estimate of electricity cost needed to produce one bitcoin on a laptop with 5 Mhash/s equals to 61 dollar, and would take 339 days with current difficulty. A standard laptop CPU provides around 2-8 Mhash/sec and consumes 25 to 75 watts, which on average gives us 1 Mhash/sec per 10 watts of power. An ATI 5870 video card, which has one the best efficiency/cost ratios, mines at about 400 Mhash/sec and consumes about 216 watts. Which gives us about 2 Mhash/sec per 1 watt of power. In other words mining with ATI video card about 20 times more cost effective then mining with CPU. According to pi.uk.com/bitcoin , mining with ATI video cards at 1000 Mhash/sec will cost 650 watts or 9.75 cents (15 cent per kilowatt hour), and the operation profit margin would be 19.07%. Therefore I doubt it would be cost effective to mine on laptop considering that power consumption changes dramatically from computing intensive task. You can get better estimate yourself by using Bitcoin mining profitability calculator and Electricity Prices by State .",
      "Mining in your work/home computer has some side effects, namely: Heat - could damage your hardware if you don't handle it properly Noise Slowdowns - if you use your computer while you mine you should reduce the miner's load Power consumption - if you don't pay for electricity this may not be an issue So I would say that there is a point in casual mining as long as your earnings compensate for these disadvantages. It is really up to you to decide if you want to stress your hardware to earn a few coins. Speaking of a more concrete scenario, casual miners usually fall into two categories: You have a good GPU for mining in your PC - a recent medium/high end ATI card. You don't have a good GPU so you want to mine with your CPU/low end GPU. Check this question to find out where do you stand. If you have a good GPU, you might get around 8 bitcoins per month at current difficulty. If you don't, you will probably not earn more than 1 or 2 coins per month. My personal opinion is that if you fit into the first category, you could give it a shot. If not, I wouldn't do it just for a few dollars (and I do not recommend mining with your CPU at all). As a final note, bear in mind that these numbers are always changing: new hardware is coming out all the time and new miners are joining while others are leaving. This influences the amount of bitcoins you will earn with your hardware so be sure to check an updated hardware list for your calculations."
    ]
  },
  {
    "question": "How can I start mining Bitcoin?Ok. I don't care if I make only a small amount of bitcoins mining. I want to mine. How do I setup my machine (amd x64 4.6Ghz 6GB/RAM with GeForce Nvidia 7300, LinuxMint 10) to start mining? Is it damn simple, or it's a damn-high-geek-setup? Can I set up to use both CPU and GPU? How much should I expect in this simple system per month with my machine on all time?",
    "answers": [
      "Please check this question first : How much Bitcoin will I mine right now with hardware X? Before you go through all this work, it is important to know what to expect from your hardware. There are two options: solo mining or pool mining. Unless you have a lot of computing power (several ASICs), you should probably mine at a pool. So the first thing to do is to sign up at a bitcoin pool. The stickies in this bitcointalk section have links for the top 10 pools. The main differences between them are the payout models and the fees. If you just want to try things out, choose one of the most popular pools like Deepbit or BTC Guild . You can then try others, according to your needs. Now you need to install a miner. It has a simple interface, a drop down menu with a list of pre-configured pools and it is not difficult to setup. After you install the miner, you need to point it towards your pool. So select device you want to mine with (probably your FPGA/ASIC), enter the pool URL (if you don't know what it is, check the FAQ/help section of your pool's website) and your username/password. That's it. You can now see your progress at the pool's website. Useful links: What is a Mining Pool, what is it good for? Is CPU mining even worth it? What is a good mining pool/payout model for infrequent mining? In your specific case, you have no ASICs or FPGAs, so you will earn less than a penny of Bitcoin.",
      "There are several options for Mining Bitcoins some of these are no longer profitable, but for the sake of being thorough here they are in order of efficiency lowest to highest: Methods CPU Mining (minerd) GPU Mining (cgminer, bfgminer) FPGA Mining (Custom software - https://github.com/fpgaminer/Open-Source-FPGA-Bitcoin-Miner ) ASIC Mining (cgminer, bfgminer, also some custom software that ships with various ASIC's) Currently the most efficient method is to use ASIC miners as with the difficulty always increasing, it becomes harder and harder to gain returns on lower spec hardware. Some Example Hardware Setups GPU - https://en.bitcoin.it/wiki/Mining_rig Hardware Comparison - https://en.bitcoin.it/wiki/Mining_rig ASIS's: -- Avalon - http://avalon-asics.com/ -- Bit Fury - http://www.bitfurystrikesback.com/ -- KNC - https://www.kncminer.com/ -- CoinTerra - http://cointerra.com/ -- Butterfly Labs - http://www.butterflylabs.com/ Most ASICS work out the box and have built in web interfaces to control and monitor the hashing of the device, where as other forms of mining normally require a bit getting down and dirty in the command line. Also as its mostly ineffective to mine in any other way this is generally the way most people choose to go although there is normally a high barrier to entry due to the high cost of entry e.g. the new Cointerra TerraMiner can achieve 2TH/s and is priced at USD $5,999 making it an expensive device to purchase. Monitoring When mining you want to ensure maximum possible up time as whenever you have hardware not hashing you are loosing money, So its pretty important to setup some kind of monitoring for your devices. Some mining software comes with this built in however there are also some other options out there. CGWatcher - http://manotechnology.blogspot.co.uk/p/cgwatcher.html CGRemote (Donation Only) - http://manotechnology.blogspot.co.uk/p/cgremote.html Miner.php (cgminer builtin) - https://github.com/ckolivas/cgminer/blob/master/miner.php MinePeon (Dedicated Mining OS with Web Interface) - http://mineforeman.com/minepeon/ Anubis (CGMiner Web Front End) - https://github.com/pshep/ANUBIS Pools / Stratum Proxy The Final piece in the puzzle is the pool, now obviously you can choose one of the many pools already out there or you can run your own pool. Running your own pool can be a daunting task for beginners, but it is well worthwhile with the knowledge you learn while building and maintaining it. Build Your Own Pool: P2Pool -- https://p2pool.org/ ‎ -- https://en.bitcoin.it/wiki/P2Pool -- https://github.com/forrestv/p2pool -- Complete P2Pool setup Guide (MERGED MINING) - https://bitcointalk.org/index.php?topic=62842.0 -- Maximizing P2Pool Efficency - https://bitcointalk.org/index.php?topic=153232.0 -Eloi Pool -- https://bitcointalk.org/index.php?topic=158105.0 -- https://github.com/ZeroASIC/eloipool-server Stratum Proxy - http://mining.bitcoin.cz/mining-proxy-howto Some of My Favorite Pools https://www.multipool.us/ - Automatically Mines the most profitable SHA-256 and or scrypt coin. https://ghash.io/ - This is the mining pool backend for cex.io and they offer merged mining with Namecoin, Devcoin, Ixcoin https://hashco.ws/ - Like multipool but offer ability to recieve all payout in BTC I Hope this very brief overview of mining helps you get started :)"
    ]
  },
  {
    "question": "How to generate a valid bitcoin address for destroying bitcoins?(Following up to this question .) In order to put a bitcoin beyond use, the answer was to select a made up address. As this isn't a formal destruction of bitcoins, there's a risk that the private keys could be found to spend those \"destroyed\" bitcoins. If someone suggests an address, people might suspect that this address was selected because that person painstakingly looked for an address that looked like a made up address. How can an address for bitcoin destruction be selected that everyone can be reasonably sure no-one's going to know the private keys to spend the destroyed bitcoins?",
    "answers": [
      "Start with an invalid public key Bitcoin addresses are the pubkeyhash (not pubkey) plus version and checksum information, encoded in base 58. Bitcoin address = version + RIPEMD-160(SHA-256( Public Key )) + checksum The steps for converting a public key to an address can be found here: https://en.bitcoin.it/wiki/Address Since the address uses the pubkeyhash not the actual pubkey we can exploit this by hashing an invalid pubkey (one which can't possibly exist) and thus produce a valid address from an invalid pubkey. So to start we find an invalid public key. All valid public keys begin with 0x04 if uncompressed and 0x02 or 0x03 if compressed. A pubkey beginning with any other value is undefined and thus there is no possible signature that can be created to satisfy that key requirement. Since spending coins requires signing the transaction with the correct private key, an address which has no known private key is unspendable. By using a public key which is known to not have a private key others can confirm that no private key exists. A valid Bitcoin public key (not address): 04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f An invalid public key 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 There are other ways to produce a known invalid public key. ECDSA keys must be exactly 65 bytes if uncompressed or 33 bytes if compressed so a key with a different length will also be invalid. For uncompressed keys the y value must be correctly produced from the x value. The point must also lie on the curve. It also can't be above the modulus for the curve. So there are a lot of ways to produce provably invalid keys but it best to choose one which is obviously invalid. This is probably the simplest obviously invalid public key. 0x00 This public key is invalid for a number of reasons (not produced by private key multiplied by the generator, not located on the curve, not a valid point, but even simpler it doesn't have a valid prefix and is not the correct length). The important thing is this isn't just some probably invalid key it is a provably invalid key. You should test your invalid public key against the reference client to ensure the client reports it as invalid as well. The validity of keys is a consensus issue so this will not change short of a hard fork. Produce a valid (but unspendable) address from your invalid public key You may wonder why we want the address to be valid. All clients should validate addresses given by users to avoid accidental loss of funds. So an invalid address is also unspendable but most users will find it impossible to send funds to the address. A P2PkH address is the pubkeyhash with version and checksum information encoded in base58. When you provide an address to a Bitcoin client it decodes the address back down to the 'raw' pubkeyhash. So producing a valid address means starting with a valid pubkeyhash. This isn't a problem because the hash of anything is a valid hash. Clients don't know what pubkey is hashed to produce the pubkeyhash as the underlying pubkey is not provided and hashing functions are one way. The Bitcoin network only verifies that an address is in the right form, length, and has the right checksum when \"validating it\". Producing an address from a pubkey is beyond the scope of this question but there are utilities and the link above provides the steps. The resulting pubkeyhash and encoded address will be seen as valid by the network and client but it requires a provably impossible private key to spend funds sent to that address. Now with just the address (and decoded pubkeyhash) a user can't verify that the underlying pubkey is invalid so you should publish the raw pubkey along with the address. Users can recreate the address using any bitcoin client or tool and will produce the same address you provide. Users now have a trustless way to verify that the coins indeed are unspendable. Any coins sent to the address can never be spent and are effectively destroyed. Hash collision Technically it is possible but improbable for more than one public key to have the same Bitcoin address. This is called a hash collision. If public key p1 and public key p2 both hash to the same address A then privates keys for either of these public keys can spend the funds. However the likely of this happening is very low. Unless RIPEMD hash algorithm is broken the probability of finding two public keys which generate the same hash (Bitcoin address) is 1 in 2^160 which is far beyond our computational power to locate. A few words on why you should use a 'Nothing Up My Sleeve' number: Using a \"nothing up my sleeve number\" (such as a single zero, all zeroes, single repeating digit, sequential numbers, digits of pi, etc) is not required as any invalid public key is equally unspendable but it would improve public confidence that you haven't already found a collision (as improbable as that is). If you just take a random invalid key like say: 00000fdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f Some may question why you chose this specific key. The fear would be that you choose this key not randomly but because you have stumbled upon a collision between this key and a valid key. There is no way to prove the key is random thus the fear will always remain. Cryptographic functions (like RIPEMD or SHA-256) often use \"nothing up my sleeve values\" to provide security that a constant was not chosen to enable some cryptographic flaw or \"backdoor\" in the algorithm. For example SHA-256 uses constants for the initial values of the block segments. Technically these could be any random number but that would lead to concern that the 'random' number isn't actually random. So SHA-256 uses first 32 bits of the fraction portion of the cube root of the first 8 prime numbers. This allows verification when a pseudo random number is needed. It is very unlikely there is some magical property between the fractional portion of the cube root of sequential prime numbers that undermines SHA-256. http://en.wikipedia.org/wiki/Nothing_up_my_sleeve_number Update (03/31/2015) It is easier to do this now by using an OP_RETURN (null data) output and it doesn't bloat the UTXO with outputs that can't be spent but the network is unaware they can't be spent. Any funds sent to an output which contains OP_RETURN are provably unspendable and the network will drop the output from the UTXO. The UTXO (unspent tx output set) is a critical resources which is necessary for validating new transactions and blocks so destroying/burning coins using UTXO is a more responsible use of this shared resource.",
      "There are four basic ways, and they all work: Come up with an address that passes the basic sanity checks but is internally invalid. You can know for sure that no key could possibly match this address. Put strings of characters in the address that are way beyond what anyone could generate in a vanity address. For example, if the Bitcoin address has \"FourScoreAndSevenYearsAgo\" in it, it's clearly beyond anyone's capability to find a corresponding private key. Use a public key that's obviously made up, such as one that consists only of zero bytes or that contains all consecutive digits of Pi. It's clearly beyond anyone's capability to find a corresponding private key. (For this one to work, you need to disclose the public key.) Use a hash of the public key that's obviously made up. This works the same as the option above, but the difficulty would be in even finding a public key with such a hash, much less finding the corresponding private key."
    ]
  },
  {
    "question": "How does one attain 1,000+ connections like blockchain.info?At this moment, blockchain.info has over 1,900 nodes connected to their bitcoin client. I have been running an m1.small ubuntu 12.04 server and bitcoind for ~4 days straight now with no reboots. My bitcoind client still only shows ~60 connections maximum when performing a \"./bitcoind getinfo\" command. How can I achieve 1,000+ connections to my bitcoind client? And is it \"worth it\" in your opinion? EDIT: I have re-started my bitcoind client with the -maxconnections=1000 and -timeout=15000 parameters but after ~12 hours of running bitcoind, the number of connections is only up to ~40. And I don't seem to be maxing out my CPU, RAM, or bandwidth just yet. EDIT 2: I have not seen a \"connected time\" over 8 hours in the list provided by blockchain.info so that tells me they must restart their server every 8 hours or so. Either that, or connections drop and refresh after 8 hours? I am beginning to think that blockchain.info keeps track of IP addresses running bitcoin in a database of sorts... and forefully connects to them every time their bitcoind reboots. Am I right?",
    "answers": [
      "Bitcoin by default will not make more than 8 outgoing connections, and -maxconnections only controls how many incoming connections you allow. Feel free to set this higher, but it will take time before others connect to you in large numbers. Please don't change this, as there is no need. Connectable peers on the network are a scarce resource, and essential to the decentralization. If people go try connect to all of them like some sites do, we'll very quickly run out. In case you're a merchant or miner, you perhaps want to set up a few fixed connections to trusted others (see the -addnode command line/config option), but having more connections does not mean stronger verification (the reference client always verifies everything) or even faster relaying (as you'll slow down by distributing new blocks and transactions to all your peers). It is mostly a matter of providing a service to the network.",
      "The given answers don't answer the question. Even though it might not makes sense to achieve a thousand connections, here's how to do that on Debian. You want to make some slightly changes in the code and recompile bitcoind: Get required packages for compiling: $ aptitude install git make build-essential libssl-dev libboost-all-dev libdb-dev libdb++-dev libminiupnpc-dev Clone the git repository (make sure the version is the most recent branch ): $ cd /usr/src $ sudo git clone -b 0.8.4 https://github.com/bitcoin/bitcoin $ cd bitcoin/src Edit the net.cpp file: @@ -27,7 +27,7 @@ using namespace std; using namespace boost; -static const int MAX_OUTBOUND_CONNECTIONS = 8; +static const int MAX_OUTBOUND_CONNECTIONS = 1000; bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false); @@ -1533,7 +1533,7 @@ OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant); MilliSleep(500); } - MilliSleep(120000); // Retry every 2 minutes + MilliSleep(5000); // Retry every 5 seconds } } 1.) By changing MAX_OUTBOUND_CONNECTIONS, the client will go on connecting until it reaches 1000 proactive connections. 2.) By changing the sleep timeout new connections are tried more frequently. Compile and install bitcoind: $ sudo make -f makefile.unix $ sudo mv bitcoind /usr/bin Don't forget to set the maxconnections in bitcoin.conf: maxconnections=1000 Start bitcoind and your done. The client will make lots of connections really fast. Disclaimer: As Pieter Wuille pointed out, it can harm the network to run a modified client like this one. Please use this solution for research purposes only and not as a permanent solution."
    ]
  },
  {
    "question": "How to get an address's balance with the bitcoin client?I want to see the balance of some address using bitcoind. I set txindex=1 and did a -reindex to get all transactions indexed. But still, there doesn't seem to be a way to get balances of an address. getreceivedbyaddress doesn't work with addresses out of your own wallet (I hoped it would after a -txindex=1 -reindex , but it didn't). I'm wondering why blockexplorer.com's getreceivedbyaddress can do this for any address but the default client cannot. If you download and sync the whole blockchain, you should be able to query it for any information, right?",
    "answers": [
      "By default, what is maintained by the 0.8 blockchain engine is: All blocks A database with all block headers, and the positions on disk for each block A database that represents all unspent transaction outputs (UTXOs), indexed by txid, at the current tip of the block chain Undo files that allow rewinding the effects of blocks on this set of UTXOs. Nothing related to addresses or balances exists at this level. That is just a client-side representation of the data. The balance of a wallet is the sum of the values of the UTXOs that are spendable with the set of keys in the wallet. You could define the balance of an address as the sum of the values of the UTXOs assigned to a script matching a given address (and this is what several sites do), but presenting it this way is quite confusing - it makes many people think that Bitcoin transactions transfer value from one address to another. This is not true, they consume specific outputs of a previous transaction, and merge and split those into new outputs. The -txindex option you mention, adds one more thing that is maintained by the validation engine: A database with the positions on disk for each transaction , indexed by txid. This was added to make the getrawtransaction command work with historical transactions, but again, this has nothing to do with addresses. A database that indexes the UTXO set by address, or even the entire block chain history by address would be possible, but it would be relatively expensive to maintain, and shouldn't be necessary for normal operations (though it is quite useful for debugging...). Where such things do belong, is in the wallet. The wallet as presented by the reference client does not use \"balance of an address\" - it rather sees addresses as entry points into the wallet, but manages the coins in the entire wallet together, regardless of what address they were last sent to. This also confuses people who are used to look at blockexplorer-like websites, when they realize that for example change is always sent to a fresh address. So, to give a real answer: if you really want to track a balance, you need the wallet interface. Right now, this is quite unflexible, but there are plans to improve this situation soon. We'll hopefully soon get support for multiple wallets, and watch-only wallets, where you can just add addresses you'd like to track, without having their keys.",
      "import all address using \"importaddress\" you can get balance using \"listunspent\", but you must sum all unspent amount per an address."
    ]
  },
  {
    "question": "What is Gas Limit in Ethereum?What is the function of Gas Limit parameter in Ethereum? Is it involved in mining or something else?",
    "answers": [
      "In Ethereum, gas is a measure of computational effort. To each operation, a fixed amount of gas is assigned (e.g. adding two numbers costs 3 gas, calculating a hash costs 30 gas, sending a transaction costs 21000 gas [1]). Since computation is expensive (mind that it has to be done by every full node in the network), excessive consumption of gas needs to be discouraged. Therefore, each unit of gas must be paid for (in Ether) by the sender of the transaction that triggered the computation. Unfortunately, it is often not easy and in general even impossible to know in advance how much gas a transaction will need eventually. Therefore, transactions have a gas limit field to specify the maximum amount of gas the sender is willing to buy. If the gas used exceeds this limit during execution, processing is stopped. The sender still has to pay for the performed computation, but they are protected from running completely out of funds. The transaction gas limit also protects full nodes from attackers, who could, without a gas limit, make them execute effective infinity loops. If such a transaction would take longer than one block to process, it could never be included in a block, and, thus, the attacker wouldn't need to pay for it. [2] Additionally, blocks, too, have a field called gas limit . It defines the maximum amount of gas all transactions in the whole block combined are allowed to consume. Similar to the maximum block size in Bitcoin (measured in bytes), its purpose is to keep block propagation and processing time low, thereby allowing for a sufficiently decentralized network. In contrast to Bitcoin, it is however not a constant. Instead, miners have the option to increase or decrease it every block by a certain factor. [3] [1] See the Yellow Paper for a breakdown of operations and the respective gas costs (Appendices G and H) [2] https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees [3] See the Yellow Paper Equations 40 to 42 for the exact rules",
      "The current gas limit can be checked on the network stats page . It's currently 3,141,592 (pi million). The gas limit per block is not fixed, though. The number of contract calls and standard transactions is limited by the gas limit, which is 1.2x of the exponential moving average. So there's only so much gas that can be expended per block, even though it can grow, of course. Note that each call to the contract to the caller cost an amount of Ether defined by (gas sent to contract)*(price of gas as defined by caller) so sending 10 thousend transactions per block could end up quite a pricey endeavour."
    ]
  },
  {
    "question": "What are the bandwidth requirements of a mining rig?How much bandwidth consumption can I expect per 900 Mhash/s rig (for instance) for both pooled and solo scenarios? I'm looking for a ballpark number for the on going requirements, after the initial blockchain download.",
    "answers": [
      "With pooled mining, at 900Mhash/s, you'll need a new work unit every 3 seconds or so. Each work unit requires about 256 bytes out and about 768 bytes back. So that's 700 bits per second out and about 2,000 bits per second back. Essentially, zero. Solo mining is a bit harder to estimate. You will need to receive and relay all new blocks as they are discovered, you will need to receive all transactions that are relayed by nodes you connect to. You can heavily limit the number of other nodes you are willing to connect to, but this will impact your stale shares level and may reduce your transaction fee income. I measured the bandwidth usage of the client with 60 connections (you can drop down to 8 if you want) and made sure my sample included discovering a block. The inbound average bandwidth was 12Kbps (1.50 KB/s) and the average outbound bandwidth was 9Kbps (1.04 KB/s). So that should give you an idea what solo mining would be like. Notice that the bandwidth usage is basically insignificant in both cases. For multiple rigs, there is no adjustment in the solo mining cases. All the rigs can be configured to query the single client. The client's bandwidth requirements will be the same. However, there is a change in the pool mining case. When a new block is discovered, each miner will need a new work unit immediately since its existing unit is stale. This happens on average about every 10 minutes. Effectively, increase the bandwidth requirements by .5% for every additional mining rig. Note that if you run more than one instance of the mining program on a rig, count it as more than one rig. (This still assumes the rigs total 900Mhash/s.)"
    ]
  },
  {
    "question": "How do I reduce the size of the block chain data on my machine?The block chain file is getting rather large, ~500MB. Is there a way to trim it or clean up, or maybe configure it to be limited in the future? I am using the stock Bitcoin client on Ubuntu.",
    "answers": [
      "For portable devices there are variants of the Bitcoin client often dubbed \"selfish clients\" in that they do not download any portion of the block chain other than what pertains to their own specific addresses and transactions. To my knowledge, none of these variants has been fully developed into a desktop client, but it is likely that such projects are underway. Unless your system is literally lacking the hardware to accommodate these files, however, it is recommended that you use a non-selfish client version. The lightweight versions are called \"selfish\" for a reason - by only holding block chain data which pertains to your own transactions, you cannot pass anything but that data to other nodes and as such your client is of minimal (if any) use to the network.",
      "If you want to use the standard client, currently there is no way to prune the blockchain data. However, you can try using a lightweight client (like MultiBit or Electrum ), which offers similar security to the standard client (wallet.dat is stored on your computer), or an eWallet (like StrongCoin , or even using MtGox if you don't need too much functionality), but then you have to trust that service. The first two would reduce the disk space on your machine, but you'd still need to synchronize with the network; the second two would make you store nothing on computer and you would not need to synchronize. There is work being done on a \"Stratum client\" , which might offer the speed and minimal disk requirements of an eWallet with security of a lightweight client. You can read more about various levels of security provided by different types of clients here ."
    ]
  },
  {
    "question": "What is the block maturation time?I was reading the wiki article about the blockchain and I didn't understand the part in bold: When a block becomes an orphan block, all of its valid transactions are re-added to the pool of queued transactions and will be included in another block. The 50 BTC reward for the orphan block will be lost, which is why a network-enforced 100-block maturation time for generations exists. I don't know the details behind block creation and acceptance, so how does the block maturation time work? Is the block only accepted after a while?",
    "answers": [
      "Generated coins can't be spent until the generation transaction has 101 confirmations. Transactions that try to spend generated coins before this will be rejected. The reason for this is that sometimes the block chain forks, blocks that were valid become invalid, and the mining reward in those blocks is lost. That's just an unavoidable part of how Bitcoin works, and it can sometimes happen even when there is no one attacking the network. If there was no maturation time, then whenever a fork happened, everyone who received coins that were generated on an unlucky fork (possibly through many intermediaries) would have their coins disappear, even without any sort of double-spend or other attack. On long forks, thousands of people could find coins disappearing from their wallets, even though there is no one actually attacking them and they had no reason to be suspicious of the money they were receiving. For example, without a maturation time, a miner might deposit 25 BTC into an EWallet, and if I withdraw money from a completely unrelated account on the same EWallet, my withdrawn money might just disappear if there is a fork and I'm unlucky enough to withdraw coins that have been \"tainted\" by the miner's now-invalid coins. Due to the way this sort of taint tends to \"infect\" transactions, far more than 25 BTC per block would be affected. Each invalidated block could cause transactions collectively worth hundreds of bitcoins to be reversed. The maturation time makes it impossible for anyone to lose coins by accident like this as long as a fork doesn't last longer than 100 blocks. If a fork does last longer than 100 blocks, then the damage caused by invalidated transactions would likely be a huge disaster. (However, something else would have to be seriously wrong with Bitcoin or the Internet for a fork to last this long.)",
      "A block is accepted immediately (assuming it is valid) the maturation time applies to the coinbase reward to the miner found in the block (bock subsidy + tx fees). The purpose is to prevent a form of transaction reversal (most commonly associated with \"double spends\") if the block is orphaned. If a block is orphaned the coinbase reward \"ceases to exist\". The coins are produced from the block and when a block is orphaned it is the replacement blocks version of the coinbase tx which is considered valid by the network. Transactions which use non-coinbase coins as an input are not affected. If a block is orphaned then any tx which was confirmed in the orphaned block and not confirmed in the block which replaced it will return to the memory pool and be included in a future block. Generated coins however cease to exist when the block is orphaned. If the network allowed miners to spend them immediately it would be the recipient of the coins not the miner who would suffer a loss from the miner's block being orpahned. So to avoid that undesirable situation the network requires coinbase tx (rewards to miners) to \"mature\" or wait 100 confirmations (the client makes this 120 confirmations but only 100 is required by the protocol). If a block is orphaned before it gets 100 blocks deep into the chain, then only the miner is affected."
    ]
  },
  {
    "question": "I paid in bitcoin, now I'm owed a refund. Can I demand it in bitcoin too?This is, I suppose, a legal question so I should point out that I'm most interested in US and European law. I made a payment to a company for a product more than a year ago in bitcoin. The amount that I paid then was equivalent to $75. Now the company has failed to provide the product and they and I both agree that I'm owed a refund. However, we disagree on the means. The company wants to refund me - in bitcoin if I wish it - to the value of $75 of today's money. It seems to me though that I should be refunded what I paid: i.e. the same BTC value that I paid. The value of bitcoin has increased substantially since I made my original payment, meaning that the BTC amount I paid then is now worth 5-6 times more. I happen to know (through their blog posts) that the company in question does keep stocks of bitcoin rather than converting them to a fiat currency, so they have benefited from this. That said, I don't think it should matter either way. My logic You can consider bitcoin in one of two ways: a) a currency or b) not a currency. The conclusion is the same either way. Let's explore both: a) BTC is a currency If BTC is a currency then this is an easy question. I should be refunded what I paid, in the currency in which I paid it. b) BTC is not a currency If a bitcoin is not currency then is it unarguably an asset. Surely in this case I have given a valuable asset to the company as my end of an implied contract for them to provide the goods. Given their failure to provide the goods, they must return the asset: not a fraction of it. Fairness I think that, regardless of the legal side, it's fair for me to receive a full refund. Given that bitcoin has increased in value, one of us has to profit from this. It seems very unfair to me that the company should profit from their failure, whilst at the same time preventing me from making that profit myself. I appreciate that I'm not exactly neutral in this, so I'd like to know what others think. Am I being reasonable? If I am, do I have a legal leg to stand on? Edit: Having read through the responses, they seem to have one or both of two themes. \"The price wasn't in BTC, it was in dollars with the option to pay this via bitcoin.\" \"Being able to claim a refund of the original BTC amount would open the door to risk-free speculation.\" For the first, this is open to interpretation. If I was being pernickety, I'd probably say this was down to the wording of the sale. However I agree that - practically - it's pretty obvious that $75 was the price and BTC was a payment method, along with Visa, Paypal etc. The concept of \"legal tender\" is one that was raised too. For something to be \"legal tender'' means that one may not refuse an offer to pay a debt with that currency. It doesn't talk about refunds though: if I'm owed €1000 by someone in the US then I must accept the dollar equivalent even if I'd rather Euros. This is still €1000 though, not \"whatever €1000 was worth when I entered the agreement.'' For the second, that is indisputable and probably represents the biggest flaw in my position. I would point out that the refund is not my doing: I would rather have received my order but the company cancelled it. However, that probably makes no difference ultimately. Thanks for all the opinions. It looks like the overwhelming consensus is that I am being unreasonable, so I'll give up on my demands and accept the refund.",
    "answers": [
      "I am not a lawyer, but... The Coinage Act of 1965, Section 31 U.S.C. 5103, entitled \"Legal tender,\" states: \"United States coins and currency... are legal tender for all debts, public charges, taxes, and dues.\" In the USA all monetary debts can be paid in US dollars. Second, while bitcoin is legally a payment method in the US, it does not have legal status as a currency. In the eyes of the law it's almost certain that the company will only be required to send you the original USD price of the item that you paid, regardless of the method of transfer. Legally speaking, you paid dollars through bitcoin, and the firm will return your USD, using the bitcoin payment method if you so wish. They also won't have to refund any expenses you incurred to get the money to them, like driving money, bid/ask spread you paid to buy BTC, PayPal fees, etc. Btw, the original price was listed in US dollars, right? Not BTC. I'd love to hear a small claims judge berate you for trying to, how can we say this, enjoy risk-free speculative gains through the abuse of company refund policies. Indeed if this unethical method worked, I could always use BTC to buy something with a money back guarantee, and if BTC went up a lot, just ask for my BTC back and cash in! If BTC didn't rise, I'd just keep the goods I'd originally bought, or maybe ask for my refund in US dollars, Swiss francs, gold bullion, IMF special drawing rights, or maybe even hugs...",
      "I made a payment to a company for a product more than a year ago in bitcoin. The amount that I paid then was equivalent to $75. Now the company has failed to provide the product and they and I both agree that I'm owed a refund. However, we disagree on the means. The company wants to refund me - in bitcoin if I wish it - to the value of $75 of today's money. It seems to me though that I should be refunded what I paid: i.e. the same BTC value that I paid. The value of bitcoin has increased substantially since I made my original payment, meaning that the BTC amount I paid then is now worth 5-6 times more. This is at complete odds with what you've just said; you say you paid $75 in Bitcoin. But you want $375-$450 refunded to you because the exchange rate is in your favour. Would you feel the same way if exchange rate was not in your favour? Undoubtedly, no. I appreciate that I'm not exactly neutral in this, so I'd like to know what others think. Am I being reasonable? If I am, do I have a legal leg to stand on? ... I think that, regardless of the legal side, it's fair for me to receive a full refund. I believe so too. Given that bitcoin has increased in value, one of us has to profit from this. It seems very unfair to me that the company should profit from their failure, whilst at the same time preventing me from making that profit myself. Forgive the acerbic response but I'm somewhat taken-aback that a sizable number feels Bitcoin is a currency when it suits, but an investment at other times, and at no time does the rationale stay consistent unless \"someone is making a profit\". That's what businesses do. But let's take Cointerra for example ; they're bankrupt because they took orders when BTC was $750 and now repaying at $350 has destroyed them. So not all businesses are rolling the dice and winning. You paid $75, you're owed $75 in refund. I'm no legal expert, and no one here likely is, so it's certainly an opinion-based question. EDIT: I'm not unsympathetic to customers being given the raw end of the deal in Bitcoin refunds. For example, BFL acted horrendously. I certainly think deliberate exchange tricks in the company's favor are wrong; though it all comes down to the terms agreed, and more opaquely, opinion."
    ]
  },
  {
    "question": "How to understand Bitcoin source codeI am not a C++ pro. I read C++ as a part of my undergrad school course. I am very passionate about the future currency i.e. Bitcoin. But I don't understand the source code structure. How to read the source code? As I already told I am have very basic knowledge of C++. However, I can google on the way if don't understand something(functions, libraries, headers). The actual problem I am facing is inside src/ directory. I don't understand the flow of files and directories in src/ . Which is the first file that I should probably start reading. Can any one explain me all of flow of all the project in some sort of tree like structure? ~/GitHub/bitcoin/src ❯ ls ✔ master Makefile.am coincontrol.h miner.h script Makefile.bench.include coins.cpp net.cpp secp256k1 Makefile.qt.include coins.h net.h serialize.h Makefile.qttest.include compat netbase.cpp streams.h Makefile.test.include compat.h netbase.h support addrman.cpp compressor.cpp noui.cpp sync.cpp addrman.h compressor.h noui.h sync.h alert.cpp config obj test alert.h consensus obj-test threadsafety.h amount.cpp core_io.h policy timedata.cpp amount.h core_memusage.h pow.cpp timedata.h arith_uint256.cpp core_read.cpp pow.h tinyformat.h arith_uint256.h core_write.cpp prevector.h torcontrol.cpp base58.cpp crypto primitives torcontrol.h base58.h dbwrapper.cpp protocol.cpp txdb.cpp bench dbwrapper.h protocol.h txdb.h bitcoin-cli-res.rc hash.cpp pubkey.cpp txmempool.cpp bitcoin-cli.cpp hash.h pubkey.h txmempool.h bitcoin-tx-res.rc httprpc.cpp qt ui_interface.h bitcoin-tx.cpp httprpc.h random.cpp uint256.cpp bitcoind-res.rc httpserver.cpp random.h uint256.h bitcoind.cpp httpserver.h rest.cpp undo.h bloom.cpp init.cpp reverselock.h univalue bloom.h init.h rpcblockchain.cpp util.cpp chain.cpp key.cpp rpcclient.cpp util.h chain.h key.h rpcclient.h utilmoneystr.cpp chainparams.cpp keystore.cpp rpcmining.cpp utilmoneystr.h chainparams.h keystore.h rpcmisc.cpp utilstrencodings.cpp chainparamsbase.cpp leveldb rpcnet.cpp utilstrencodings.h chainparamsbase.h limitedmap.h rpcprotocol.cpp utiltime.cpp chainparamsseeds.h main.cpp rpcprotocol.h utiltime.h checkpoints.cpp main.h rpcrawtransaction.cpp validationinterface.cpp checkpoints.h memusage.h rpcserver.cpp validationinterface.h checkqueue.h merkleblock.cpp rpcserver.h version.h clientversion.cpp merkleblock.h scheduler.cpp wallet clientversion.h miner.cpp scheduler.h zmq",
    "answers": [
      "I'm in my final year of college and I remember being in your exact situation 2 years ago. In my view you can adopt 2 strategies at this stage. You need to understand the protocol first, and reading Satoshi's orginal paper , or any of the easier options is essential. It also helps a lot to understand the conceptual differences between bitcoin and other currencies like Ripple and Peercoin. If your intention is to learn as much about the bitcoin implementation as possible, I would suggest you give up on bitcoin-core and shift to one of the python implementations. Now, there are a few quirks about the python implementations , but your learning would be much faster and you'd be in a much better position to understand the cpp code later. If you want to stick to bitcoin-core, and are willing to tolerate a steep learning curve, there are still a few resources to sweeten it. You need to understand that it's not just cpp that you need to master to understand bitcoin core, but a lot of the GNU build system, the makes and the autoconfs and such stuff . Now to help you understand the structure of the code in src, you could check this out . Edit (7:7:2016):A lot of the new discussions in the bitcoin:core world, revolves around the CPP language itself. CPP itself undergoes considerable change every 4 years and there are many discussions around which CPP language features can be implemented/ incorporated into bitcoin-core. So it is required that you have a thorough understanding of CPP along with new language features that keep getting added, and their relations to the previous features.",
      "I have a different approach to it. You can use this too. Bitcoin uses Doxygen comments to explain the code. You can take the most recent copy of the code, build class hierarchy yourself using Doxygen, and then navigate through the various classes. The next step would be to build it and run it in -regtest mode. Use gdb to add breakpoints, and inspect the flow. You can start with init and util files and then go through others. They have generic code, logging and files. And then get to the net.cpp, validation.cpp to find the more detailed logic. In my opinion, diving into the code, getting messy is a much better approach rather than reading more. Get dirty into the code, write some of it, get errors, and understand on the way."
    ]
  },
  {
    "question": "What would a country adopting Bitcoins as official currency have to reinvent?Let's say that a country decided to ditch their currency and go for Bitcoins. What would this country have to reinvent. The reason why I ask, is because I believe that if a tiny country was to adopt Bitcoins as their official currency, then this would remove all legal issues related to this currency, and hence would enable it to get adopted more widely. Some of the issues that could require reinventing something could be in relation to: Transparency requirements for the government to efficiently tackle Black economy VAT and general taxation fraud Financing of terrorism Ability to peg the currency to other currencies if this is judged as a good idea Have an efficient banking system Ability to fight deflation Any other issues, which I have not thought about. Please note that you do not have to answer all these issues in any one answer, just one of them.",
    "answers": [
      "TL;DR: In the first instance, my belief is that a government would have to create their own brand of Bitcoin (i.e. a new version of the blockchain) and use that to trade against other currencies. This is a useful move because the government retains control over their currency (they set the mining rules) and they don't suffer a wealth drain in the process. In more detail, once a country (our mythical Seashell Island from the earlier draft) has decided that it wants to adopt Bitcoin as it's local currency the following timeline is likely to come into play: Research into Bitcoin At this time the government will need to look into what benefits and drawbacks Bitcoin is likely to bring to their economy. Assuming that they currently have a weak currency, then adopting Bitcoin early could be seen as a smart move since it gives them lower cost of entry into the Bitcoin marketplace. Among the obvious advantages that Bitcoin brings with it are: resistance to counterfeiting resistance to inflation easier to track than cash for traditional transactions types (i.e. not including private sales of high value private keys) Some of the drawbacks are: economy becomes vulnerable to loss of electricity/networking (true of all electronic transactions at present) banks have a reduced regulatory role since transactions become largely anonymous increased potential for anonymous transactions to take place in large amounts This last drawback is perhaps the most serious since it allows for a vast amount of money to be moved in and out of the country without the knowledge of the government. Admittedly, this happens in the present system although due to the large physical size of cash it usually requires laundering of some kind (conversion to something precious). However, government resources are significant and it is very hard to remain anonymous for long. Over time detailed statistics analysing transactions could be used by the police to pinpoint individuals reusing Bitcoin addresses. This process is made much easier by the existence of tools like blockexplorer.com and should be seen as an improvement over the existing traceability processes. Setting up the necessary processes/contracts to obtain some form of Bitcoin By this stage the government researchers will likely have determined that there are only a few feasible options to get hold of bitcoins (note the lowercase here): set up their own mining pool (initially paying for it in their own currency) - unlikely create a suitable contract with a mining pool to buy a large quantity of bitcoins (without including their own soon to be worthless currency - unlikely encourage their citizens to go forth and buy bitcoins themselves and slowly drain the local currency into foreign hands then pull the plug on it (not exactly above board) - unlikely Using any of the above approaches at this stage requires a significant transfer of wealth from the country into bitcoins and is probably the hardest part to get right. The problem is that there is no central authority who can control the supply of bitcoins exposing the country to the influence of the market. In the case of Euros, the exchange rate of the participating currencies was fixed well in advance after significant negotiation. When the time came to switch over nobody lost out because all the old currency was replaced with the new, which could be printed at will by the central bank. It could be argued (by @David Perry for one) that some kind of intermediate value-store could be used, such as gold or silver. However, this still requires all of the country's wealth to be slowly converted to this value-store which will raise eyebrows among those folks selling it in exchange for a soon to be worthless currency. I'd welcome further discussion on this. There is a significant danger that the country could be declared bankrupt in it's own currency before it is able to complete the operation. EDIT to cover the most likely path by a government: if a government made their own blockchain (e.g. SeashellCoin) then they could in theory use scripts to manage trades with Bitcoin . This would permit a staged transition and essentially solves the value-store problem. The value of a Seashell would be fixed against their SeashellCoin equivalent (probably as 1:1). In my opinion, this is probably the most likely mechanism that a government could take. The government could decide upon their own inflation model, select a Version entry and then throw a supercomputer on the job for 5 minutes to generate a few million coins. Once that's done then they can take advantage of the blockchain approach and off they go. Setting up the necessary legislation to make them legal tender locally Once an adequate number of Bitcoins are, somehow, in the government coffers they can then make the announcement that all local debts can be paid in bitcoins and will be accepted by a court of law. This ratifies Bitcoins around the world (assuming the country is a recognised state) leading to a huge increase in the value of Bitcoins. It also opens the door to taxation in bitcoins which would largely operate in the same way as it did before. Value Added Tax (VAT) (aka sales tax) would continue to be added to Bitcoin transactions by merchants who would then transfer the money to the government at regular intervals, overseen by accountants Income tax would also stay the same Accounts would have to be returned along with their transaction IDs to allow verification of truth Standard statistical methods to detect fraud would remain (relies on most folks behaving themselves) Managing the transition among the general population Since it is the government driving this then they are likely to provide all necessary equipment to facilitate the transfer. This would include: recommendations for mobile phone applications (probably not likely to make their own due to \"backdoor\" privacy concerns) provision of Bitcoin Wallet Devices that offer tamperproof private keys and are essentially like smartphones for those that don't have mobile phones (see the original Fred) provision of EPOS systems that are Bitcoin enabled All of the above would probably occur via contracts with private companies. Handled well, the transition to Bitcoin would be like introducing a new contactless payment system. They would still want to maintain a secure location for their bitcoins (most likely a government backed bank) and after a while it would just fade into the background. Reaping the benefits to the economy afterwards Much of the long term benefits would stem from the decreased transaction friction within the existing legal and banking system better fiscal policy since supply is limited leading to improved standards of living and quality of life increased long term wealth as an early adopter to a global currency greater transparency in accounting that can be easily verified immunity to global currency crises Just my 2 BTCs.",
      "A nation State would never adopt Bitcoin willingly because the government would lose control over the ability to inflate the money supply. Inflation is nothing more than a tax. No government will ever willingly give up its primary means of stealing from the public. The inflation tax is the most insidious and the easiest for government to get away with. It is much more difficult to force people to hand over their money than it is to simply print new money. Historical charts of US tax revenue show that no matter what rate the government sets taxes at, revenues always come in at around 20% of GDP. This means that if the government wants to spend above 20% of GDP they must inflate the money supply as people will simply scam the tax system at higher rates. Further, it would be ridiculous for any coercively funded government to implement its own version of Bitcoin that they retain control of, because once people found out that an identical open source currency system existed that had no inflation, they would use that system instead. Once an economy has been restructured to use crypto-currencies, no one in their right mind would chose to use the government issued currency when they could use Bitcoins instead. Thus, a State implementation of crypto-currency will never occur. However, because Bitcoin has so many advantages over State issued currency and the fact that its exchange rates can not be controlled by a State, it is highly likely that over time Bitcoin will become the dominate global currency. This is because taxation can be avoided with Bitcoins, which allows businesses to by-pass legal tender laws. According to Thier's law , in the absence of legal tender laws, good money will drive out bad money."
    ]
  },
  {
    "question": "Do mining pools centralize the Bitcoin network and make it less secure?A mining pool with a significant percentage of the hash rate could allow double spend attacks by the pool manager. There are a number of pools that approach this level. However, most people say that a compromised pool would be easily detected, and the attack would be insignificant. However, isn't this issue not about a single pool but the combined centralizing effect of pools? A moderate-sized attacker could easily compromise more than a few pool managers with a rubber hose attack, or pose as legit pools for a while until they obtain nearly complete control of the block chain. The attacker would be able to double spend a lot of bitcoins (that it generated for itself with its pools in the first place), and regardless of any monetary advantage it could destabilize and destroy confidence in bitcoin. Easily within the capabilities and motivations of a government. A well-planned attack could happen far quicker than anyone could notice and pull their miners from the pools.",
    "answers": [
      "The short answer to your question is \"yes\". Efforts are underway to develop schemes that allow pooled mining without the pool manager being able to control what transactions go into the pool's blocks, leaving that decision (as well as which chain to extend, so long as it is reasonable) to the individual miners. All the pool really needs is proof that the miner is mining for the pool.",
      "Large pools with a significant fraction of total hashing power do represent an increased risk to the security of the Bitcoin network. Pools by themselves are not necessarily a risk as a peer to peer network doesn't necessarily need to consist of invidiual users. A network of pools being the peers is also viable however the pools must be peers and there must be a sufficient number to make collusion between peers infeasible. When one pool is 50x the size of average pool it has no peer. One could encourage miners to support smaller and medium sized pools thus restoring the \"peer\" nature of the network however that is likely a futile effort. The problem is that large pools have an inherent advantage over smaller pools in the form of less reward variance which is a desirable attribute for miners. Due to this advantage there will always be a tendency for hashing power to aggregate. Realisticly we should accept that large even massive pools are an inevitability due to the high variance nature of Bitcoin hashing. However the risk of large pools stems from the fact that miners are \"dumb\". By miners I am referring to the software not the person. Currently the pool server tells the miner what to hash and the miner blindly hashes it. If the pool is compromised or malicious it can tell the miner to hash \"bad data\" such as a forked blockchain, or double spend transaction. The current implementation of mining pools makes it impossible for a miner to ensure they are doing \"good work\" until after the fact. This is an important element because large pools aren't inherently a risk. What makes them a risk is the control they have over a large amount of hashing power. Any reasonable mitigation must address that: Large pools are inevitable. Miners will seek out pools which minimize variance. The pool server is the weak link in an otherwise robust network due to denial of service, corruption, or compromise. The miner must be smart. It must decide for itself what to include in the block to ensure only \"good work\" is done. p2pool (peer-to-peer pool) is one solution to this issue without the unrealistic goal of simply having no pools or only \"small\" pools. p2pool could someday have >51% of the network hashing power and it wouldn't represent a risk to the network. This is because each miner in the pool is working independently which makes subversion of the pool ineffective for the purposes of attacking the block chain. How p2pool creates a network of \"smart\" miners. p2pool creates a \"share chain\" where each miner submits shares to a parallel p2p network that records all the shares completed by the pool. Each miner independently includes transactions, sets up block headers, forwards other miner's transmissions for shares it hashes. When a block is found the reward is split fairly because in generating each block header the miner looks at last x shares in the \"share chain\" and setups the coinbase transaction to split reward based on work over the last x shares. IIRC x is currently set to roughly 1 day of work. So everytime a block is found each miner in the pool is rewarded equal to the % of shares accepted by the pool in the prior 24 hours. https://github.com/forrestv/p2pool https://bitcointalk.org/index.php?topic=18313 https://en.bitcoin.it/wiki/P2Pool"
    ]
  },
  {
    "question": "How can one remain relatively anonymous while using Bitcoin?Bitcoin transactions are pseudo-anonymous . What can an individual that uses Bitcoin do in order to remain as anonymous as possible?",
    "answers": [
      "Don't publicly disclose any address in your wallet, or associate any address with your true identity. Use currency exchanges to break the 'money trail' of bitcoin addresses associated with you.* Use anonymizing services such as TOR when conducting business. Break up your transactions between online and offline (person to person) transactions. Buy bitcoins for cash. Mine bitcoins yourself either directly (solo), or with pools such as Eligius that do not require registration. *If you transfer bitcoins into a large currency exchange or other large private repository of bitcoins, then pay bitcoin back out to a new address that is not associated with you it is difficult (without a warrant) to track the bitcoins.",
      "Use Tor whenever connecting to the Bitcoin network or to exchange sites. Never publish one of your Bitcoin address publically (e.g. in a signature or blog). If you do, and someone actually sends money to this address, you run the risk of them being able to identify your other addresses and monitoring every transaction your make via Block Explorer . Any Bitcoins that you want to keep truely anonymous should be managed via a dedicated account, and never linked on the internet to your name. E.g. if you buy some Bitcoin through Mt. Gox, this can theoretically be traced to you by law enforcement agencies if they can correlate the money transfer you made to Mt. Gox with the funds transfer (assuming they get access to Mt. Gox logs). A simple way to remain truly anonymous is buying bitcoin in exchange for cash (e.g. through Local Bitcoins ) and moving them to an address you will only access through Tor."
    ]
  },
  {
    "question": "Is there a Bitcoin bank, which gives interest on my deposit?Is there any Bitcoin bank I can place my Bitcoins in that will give me a decent interest rate. It should be at least 1% for it to be worth it.",
    "answers": [
      "Please Take Note: Flexcoin has been hacked and is no longer operating. Original Post shown below: Right now, the closest thing you can find to a bank is Flexcoin . If you keep your money there, you will receive a variable interest (they call it discount for legal matters) every month. They also have a user defined cold storage service available for those who want to keep their funds offline. Here is how it works. Every time you withdraw money from Flexcoin, you pay a fee: Fees : Flexcoin to Flexcoin = FREE Bitcoin to Flexcoin = FREE Flexcoin to Bitcoin = 0.01 BTC or one half of one percent of the transaction amount (whichever is greater) Cold Storage Transaction Fee (outbound) = 0.02 BTC or one percent of the transaction amount (whichever is greater) Cold Storage Transaction Fee (inbound) = 0.01 BTC or one half of one percent of the transaction amount (whichever is greater) This fee is used to pay miner fees and keep the service running. The rest of it is distributed among clients: Discount Payout: 70% of the fees collected are disbursed to the account holders as discount payments on any fees already paid or any potential future fees, based on the following formula… (your account balance / total balance of all flexcoin accounts) * ((all fees collected – miner fees) * 0.7) Here are two bitcointalk threads about the discount payments for the first two months. As a final note, I would like to say that I personally think that this kind of service is not very useful right now because the Bitcoin price is too unstable. For example, yesterday the price dropped 15%. Any interest you might earn becomes irrelevant in this scenario.",
      "In theory, such a thing could be created. 10 Bitcoins today is worth more than 10 Bitcoins tomorrow. If you don't see why, just ask yourself this: Would I rather have 10 Bitcoins today or 10 Bitcoins tomorrow. Obviously, you'd rather have the 10 Bitcoins today. Why? Because you can hold them for a day and have the 10 Bitcoins tomorrow. Plus, you have the extra benefit of anything you'd prefer to do with them today rather than holding them until tomorrow. However, to set up such a bank right now, you'd have to use the following method: You convert the Bitcoins to whatever national currency had the highest interest rate. You loan out that money or place it in bonds or other secure investments. At the end of the term, you buy back Bitcoins to pay back the depositor. The problem, of course, is that the value of Bitcoins could shoot up while the currency is loaned out. To protect against that, a bank that used this model would have to offer offsetting shorts to cover that loss . Basically, that means it allows other counter-parties to buy a derivative that goes up if Bitcoins go down and down if Bitcoins go up. This way, if the price of Bitcoins goes down, the bank makes extra money buying back the Bitcoins at a lower price, but it has to pay out on the shorts. If the price of Bitcoins goes up, the bank loses money buying back the Bitcoins, but makes it up on the shorts. If the bank itself offers the shorts, it actually makes extra profit on the shorts either way. It makes some profit on the loan and some on the shorts. (Whether Bitcoins go up or down cancels out. Any extra profit on the loan, due to Bitcoins going down, is made up with a loss on the shorts. Any extra profit on the shorts, due to Bitcoins going up, is made up with a loss on the loans. If Bitcoins stay the same, the bank makes its small commission profit on both the loan and the shorts.) There are definitely people who believe that, long-term, Bitcoins will gradually drop to near-zero value, and they would like to buy shorts on that basis. However, the shorts would likely have to be more short-term unless the loans were long term. So making the details work could be quite a challenge. To my knowledge, nobody offers this yet."
    ]
  },
  {
    "question": "Why are Bitcoin addresses hashes of public keys?Currently, Bitcoin addresses and their checksums are constructed from the public key by a using repeated hashing with SHA256 and RIPEMD160. Now I understand the reasoning behind using hashing for constructing the checksum, but why wasn't just the original public key with a checksum added used? Is it just because of the shorter addresses or are there other privacy/security implications of using hashes of public keys instead of just public keys?",
    "answers": [
      "It's just to get shorter addresses. Regular public keys are 65 bytes long, which is much too long to be convenient. Compressed public keys are 33 bytes and could potentially be used instead of hashes, though these are a little longer than 20-byte hashes. It also seems likely that Satoshi didn't know about compressed public keys or wasn't comfortable with using them when he designed Bitcoin. Hashes seem to help against certain attacks (some attacks against ECDSA, for example), though they also open up the possibility of other attacks (such as attacks against RIPEMD-160). It's not clear to me that they do improve security overall.",
      "They're not. You hash the public address to get the keys. It's a three piece snack from the kyc baby public address to public key private key. 3 pcs. The address is what people pay (when it's hashed and compressed it's called a key)."
    ]
  },
  {
    "question": "Bitcoin Mining ASICs used for cryptographic application? Rainbow tables?What is the potential that the ASICs being developed for mining could be used for other cryptographic applications such as building rainbow tables? I know that for instance those that crack GSM with rainbow tables utilize systems similar to those for mining for building rainbow tables and decrypting GSM packets. Such systems are also used for building MD5, SHA, rainbow tables for traditional password/shadowfile cracking.",
    "answers": [
      "TLDR; forget about it. The ASICs are optimized for bitcoin mining. Not just Sha256(Sha256(x)) hashing, but very specifically bitcoin mining. You can't even use them for the Sha256(Sha256(x)) hashing in the rest of the bitcoin system, like hashing transactions. The ASICs are made for hashing 80 bytes, where you give them the midstate from hashing the first chunk (64 bytes), and 12 bytes from the second chunk. They then try all variations of the last 4 bytes to try and find a hash that starts with 4 zero-bytes. Only values that result in the 4 zero-bytes are reported at all. That's basically what mining is. The ASIC could aid in password cracking if: the hashes are generated with sha256(sha256(x)) salt + password = 80 bytes the hash starts with 4 zero-bytes",
      "ASICs for BTC mining are optimized for one calculation: SHA256(SHA256(x)) . They can not be used to calculate MD5(x) or even SHA256(x) , so unless you use double-SHA256 to hash your passwords, you should not be worried."
    ]
  },
  {
    "question": "How do transactions leave the memory pool?How does my bitcoin core client know when to drop a transaction from the memory pool? Is it as simple as a specific period of time?",
    "answers": [
      "As of Bitcoin Core 0.14.0, these are the ways a transaction can leave the mempool: The transaction was included in a block. The transaction or one of its unconfirmed ancestors conflicts with a transaction that was included in a block. The transaction was replaced by a newer version (see BIP 125 ). The transaction was at the bottom of the mempool (when sorted by fee per size), the mempool had reached its size limit (see the -maxmempool option), and a new higher-fee transaction was accepted, evicting the bottom. The transaction expired by timeout (by default 14 days after entering). Also, transactions that have left the mempool can always enter them again. For example, when they're part of the local wallet and get rebroadcast, or when they're received again over the network. Eviction does not imply a transaction is cancelled. Since Bitcoin Core 0.14.0, the mempool is saved to disk, so it persists across restarts. In earlier versions a restart would also result in a wiped mempool.",
      "There is no fixed expiration time for each node, but the default setting is 72 hours. https://bitcoin.stackexchange.com/a/43165/24926"
    ]
  },
  {
    "question": "What is an \"unspent output\"?What is the meaning of the term \"unspent output\" in the Bitcoin protocol?",
    "answers": [
      "An unspent output is simply an output of a transaction which isn't yet an input of another transaction. To take the example from ripper234's answer (in which generated coins are immediately spendable, and we don't have to wait 100 blocks for them to mature), where: The first block contained 50 mined BTC in address A (A = 50) The second block contained 50 mined BTC in address A, a transaction sending 20 BTC to address B, and putting the change in address C (A = 50, B = 20, C = 30) The third block contained 50 mined BTC in address A, a transaction sending the 20 BTC from address B to address D (A = 50 + 50, C = 30, D = 20) So, after three blocks, there are four unspent outputs: A has two unspent outputs worth 50 BTC each C has a single unspent output worth 30 BTC D has a single unspent output worth 20 BTC And there are two spent outputs: the 50 BTC generated in the first block, spent in the 2nd block the 20 BTC output created in the 2nd block and spent in the 3rd block Note that unspent outputs don't merge together. The two unspent 50 BTC outputs at address A are separate, and will remain separate at least until they are spent in a transaction",
      "It means \"Bitcoins that were not spent\". Imagine the early days, when the blockchain was of length 3 (imaginary chain of events): The first block contained 50 mined BTC in address A The second block contained 50 mined BTC in address A, a TX sending 20 BTC to address B, and putting the change in address C The third block contained 50 mined BTC in address A, a tx sending the 20 BTC from address B to address D So, after 3 blocks, this is the \"sum total\": A has 100 BTC C has 30 BTC D has 20 BTC Total 150 BTC in unspent outputs. These are the \"unspent coins\" - all the generated BTC, without counting transactions that moved BTC twice."
    ]
  },
  {
    "question": "What are tainted coins exactly?I've come across the term of a tainted coin several times now. I understand that coins, or better, the origin of a coin can be traced throughout the blockchain. I've read that bitcoins can be disassociated from an address, by sending it to a sufficiently large enough wallet which handles many transactions, thus making a transactions origin \"untraceable\". This collides with my understanding of the blockchain, where each transaction can be tracked back to its origin. What does the concept of a tainted coin mean in this context and how can a coins taint be measured?",
    "answers": [
      "You can trace the coin back to its origin, the question is whether that information is meaningful. Say I steal 50 bitcoin. I can pass them around between several different Bitcoin accounts, all mine, and you can trace them. The problem is, you don't know whether any of those transactions are real. Say Jack has 50 bitcoins that come from a block reward and are untainted. Now, say Jack and I both deposit our 50 bitcoins in a web-based wallet. And say Jack withdraws his 50 bitcoins from that web-based wallet and he gets my 50 bitcoins. Jack now has 50 bitcoins that you can trace to a theft and are therefore tainted. But Jack has done nothing wrong and it doesn't do any good to be able to track his bitcoins because I, the bad guy, now have untainted bitcoins.",
      "When you send coins to a large shared wallet, chances are that the coins you withdraw won't be the same as the ones you deposited. That's how you can sever the taint trail. The key is that the wallet must not only be large, but also shared between a lot of users. The taint on the original coins would never go away but could be diluted by mixing them with \"clean\" coins. For example, if you sent two coins, one tainted, one clean in the same transaction they would \"mix\" together and both would have 50% taint. The concept of \"mixing\" has therefore two different meanings : swapping tainted coins for clean ones and mixing tainted coins with clean ones in order to \"dilute\" the taint. Remember that the \"taint\" is always relative to some origin, it's not something absolute."
    ]
  },
  {
    "question": "Why does Bitcoin use two hash functions (SHA-256 and RIPEMD-160) to create an address?Why do we use 2 hash functions (both SHA and RIPEMD) to create an address? Why not just use one hash function?",
    "answers": [
      "RIPEMD was used because it produces the shortest hashes whose uniqueness is still sufficiently assured. This allows Bitcoin addresses to be shorter. SHA256 is used as well because Bitcoin's use of a hash of a public key might create unique weaknesses due to unexpected interactions between RIPEMD and ECDSA (the public key signature algorithm). Interposing an additional and very different hash operation between RIPEMD and ECDSA makes it almost inconceivable that there might be a way to find address collisions that is significantly easier than brute force trying a large number of secret keys. Essentially, it was a belt and suspenders approach. Bitcoin had to do something unique and rather than have to hope they got it exactly right, they overdesigned it.",
      "Except from Where is Double hashing performed in Bitcoin? So why does he hash twice? I suspect it's in order to prevent length-extension attacks. SHA-2, like all Merkle-Damgard hashes suffers from a property called \"length-extension\". This allows an attacker who knows H(x) to calculate H(x||y) without knowing x. This is usually not a problem, but there are some uses where it totally breaks the security. The most relevant example is using H(k||m) as MAC, where an attacker can easily calculate a MAC for m||m'. I don't think Bitcoin ever uses hashes in a way that would suffer from length extensions, but I guess Satoshi went with the safe choice of preventing it everywhere. To avoid this property, Ferguson and Schneier suggested using SHA256d = SHA256(SHA256(x)) which avoids length-extension attacks. This construction has some minor weaknesses (not relevant to bitcoin), so I wouldn't recommend it for new protocols, and would use HMAC with constant key, or truncated SHA512 instead. Answered by CodesInChaos"
    ]
  },
  {
    "question": "Why do the price of bitcoins vary wildly between exchanges?▼ mtgoxUSD 95.0000 108.452 -12.404% 2428892 ▼ btc24EUR 67.5047 89.036 -24.183% 348160 ▼ btceUSD 82.9900 106.794 -22.289% 277286 ▼ bitstampUSD 75.9900 109.320 -30.489% 249563 ▼ mtgoxEUR 74.2244 88.579 -16.205% 248525 So at mtgox it's $95 USD. At btceUSD it's 82. Why the spread is so high?",
    "answers": [
      "There are a variety of variables that affect Bitcoin pricing on the exchanges. Some are: Market size Exchange volume Price of entry Market size: Relatively speaking, the market for Bitcoins is small. In April of 2013 it was about 1.2 billion USD, and a few days later dropped to below 750 million USD. That's a small market cap, which means, among other things, that there's less consensus on the price to the BTC. This is the capitalization for all mined bitcoins and includes coins that have been lost, so the real value is something smaller. Each exchange is a subset of the total market, so those markets are even smaller, which allows for greater variation. Exchange Volume: For all the coins that have been mined, the quotes are only from online exchanges, which are a small set of the total coins that have been mined. If only a quarter or less are in play, then the swings can be pretty dramatic. Since the volume is limited, and people don't take full advantage or arbitrage, different prices can and will exist on the different exchanges. This happens with foreign currency exchanges too. However, with professional traders, billions of dollars, and serious automated trading the differences are in fractions of a percent. Price of entry: It's relatively cheap to enter the BTC market and cheap to trade. Furthermore, if you mined BTC when it was trading for fractions of a dollar, or even $30/BTC, there's no issue unloading it. With a low price of entry people are less serious about how the trade their BTC. Fundamentally, BTC is a small, highly speculative, irrational market. Each exchange is a small, highly speculative, irrational market. That's why the spread is so great. As a crude example: Consider two towns in the medieval period separated by twenty miles. They both have markets and people sell apples in both markets. In one market people really like apples. They pay 2 coins for the apples. In another market they aren't as enthusiastic, they only pay 1.5 coins for the apples. The economic thing to do would be to buy the apples in the second market and sell them at the first. But it's hard. It's a twenty mile walk, and all your friends are at the other market. Plus, the price could change by time you get there. It's just easier to stick with your current market, even if you're not maximizing your return.",
      "In a market exchange, price is determined as being where buy and sell orders meet. Buyers not needing bitcoins immediately are then most interested in obtaining bitcoins at the lowest price possible. Sellers not needing cash immediately are then most interested in obtaining the highest price as possible. Because of differences in deposit and withdrawal methods in addition to transaction fee costs and other factors even, exchanges might not be considered equal. Therefore prices between exchanges could vary, significantly. For instance, a seller wanting to unload a large amount of bitcoins would not want to sell on a smaller exchange as that would likely mean dropping the price to meet lower and lower bids. That works against the goal of obtaining a high price. So the price differences between exchanges are due to these exchange-specific attributes working in either the buyer's or seller's favor. For instance, because BTC-E provides domestic cash out methods with banks that Mt. Gox doesn't support, sellers in that country (Russia) may be willing to sell at a lower price than at Mt. Gox. If it was trivially easy to transfer funds to BTC-E the price would not vary much from Mt. Gox's price but since there are differences, the lower price at BTC-E is the result. The prices will generally travel in the same direction and to the same degree, however, they will generally remain different in price between the two pretty much consistently by about the same amount."
    ]
  },
  {
    "question": "How to make a new blockchain from scratchIn the same vein as setting up a private DNS root server and using whatever domain names you want, how do you generate your own blockchain and mine your own coins? P.S. I don't want any answers like \"why would you want to?\" I want to do it because it can be done",
    "answers": [
      "I think I Found it. Someone wrote a C program to generate a genesis block. Code is on github here: https://github.com/Gnaf/GenesisBlockZero The original code was pulled from a discussion on the bitcoin developer forums: https://bitcointalk.org/index.php?topic=187888 . Compile and run the program to generate the initial SHA256 hash, the time and nonce, then plug those into the bitcoin main.cpp source and recompile. I think that's all you have to do to start a new blockchain.",
      "You can do this really easily with MultiChain , and even make your blockchain permissioned, i.e. only accessible to certain entities."
    ]
  },
  {
    "question": "Are there any truly anonymous cryptocurrencies?I've been looking into Bitcoin recently and stumbled upon numerous notes how Bitcoin is not anonymous at all, or how it's only partially anonymous and you can easily trace your funds. So, this brings us to my question: is there any true anonymous cryptocurrencies which I can use and there will be no trace left. I am a fairly new member to the cryptoworld, so please, keep it simple. :)",
    "answers": [
      "The short answer is no. The long answer is split into three parts, each headed by a bold word. I will talk about the existing privacy tools in Bitcoin. I will talk about some pie-in-the-sky theoretical crypto which would achieve full anonymity (but which can't be done feasibly today). I will talk about CryptoNote, its limitations, and feasible ways around it that could be implemented today, specifically those that have already been implemented by Monero. Today, you can do a lot relative to stock Bitcoin in the direction of privacy. Two strategies I should mention are CoinJoin and CoinSwap . CoinJoin works by effectively pasting together transactions. In Bitcoin, each transaction is a list of inputs tied (by digital signature) to a list of outputs. The transaction is valid if the total output value is less than or equal to the total input value (any difference is a \"transaction fee\" claimed by miners), and if every input is a valid (not already spent) output of an old transaction. CoinJoin takes transactions from two or more users, combines the input and output lists, and has both users sign the resulting transaction. The result is that the standard flow analysis idiom of \"all inputs are owned by the same person\" and \"all outputs are owned by the same person, except maybe for a change output\" is broken. CoinJoin is tricky to implement well: output values should be as uniform as possible to avoid grouping them and matching them to input values; the resulting outputs should not be spent at the same time, since this also groups them; the join should involve two distinct parties, neither of whom is some central server participating in every join. Currently there are no good tools out there which satisfy all these requirements, but there are several in development (such as DarkWallet). Keep an eye open. CoinSwap does trustless mixing, even across different blockchains (as long as each has a sufficiently rich scripting system). It is too complex to summarize here, but the result is the same as if two parties switched private keys in person, except that there is no room for cheating. That is, coins are moved between parties but the blockchain does not see this and therefore chain analysis cannot link them — except to the extent that they look funny, so if there are almost no users doing this, their transactions can be linked on this fact alone. To the best of my knowledge, there are no tools which support this. I am developing a Bitcoin wallet for experimental features such as this that will support it, but it may be several months or years away. Total anonymity, in the sense that when you spend money there is no trace of where it came from or where it's going, is theoretically possible by using the cryptographic technique of zero-knowledge proofs . As an extreme example, you could imagine that rather than publishing blocks mapping old outputs to new ones (which is what transactions are in Bitcoin), miners published zero-knowledge proofs that they had a valid set of transactions which, in aggregate, mapped the old set of all outputs to the new set of all outputs. You could further obscure this by having the recipient choose the destination address(es) and pass different ones to every miner. That way, only the miner who gets the block (who is probably different for every block) and the recipient knows where money is going. In what I've described, the values of all coins would still be visible, and perhaps tracking could be done by linking similarly-valued coins. We can fix this with homomorphically-encrypted values , say. The point of this musing is that there are no strong theoretical reasons that what you want is impossible. But I'm going to burst the bubble I just created and talk about practical problems: firstly, to do this kind of general computation is zero-knowledge even remotely feasibly, you need to use a system which has a trusted setup (in cryptographic terms, the scheme is secure only in the CRS (common reference string) model). This means that some party, the scheme's creator probably, has access to secret data which will allow them to produce false proofs, effectively allowing them to undetectably print money for all time. A recent example of such a thing is the paper SNARKs for C by Eli Ben-Sasson et. al., which provides a lot of historical context. Secondly, even with this fatal flaw, these schemes are not all that computationally feasible. Zerocoin, now superceded by Zerocash, took this approach and needed to create serious restrictions: all coins have the same value, there is no scripting (even for multisignature transactions, I believe), and even so some serious work went into special optimizations to do whatever was left (such as hashing) in zero knowledge. For ZeroCash research is going into doing the initial setup in a multi-party computation so that no individual has the secret material needed to print coins; there would be several, and as long as even one securely destroyed their data, the currency would be safe from forgery. However, ZeroCash's trusted setup is orders of magnitude more complex than any other MPC that has ever been done. And the most efficient MPC schemes known depend on a trusted-setup as well, so we haven't gained anything. Having said that, we can get something weaker than total anonymity, and it looks like we can do it in a feasible way. As has been mentioned, CryptoNote -based currencies use ring signatures (contrast group signatures , which involve a trusted party) rather than plain old ECDSA signatures in the proof-of-ownership part of their transaction signature scheme. Arguably the most well-known cryptocurrency that was originally based on CryptoNote is Monero . Whilst Monero has subsequently deviated substantially from its CryptoNote origins, it still implements many of the key concepts below, and additionally improves a lot of the problem areas originally highlighted in this answer. To understand how CryptoNote works we must first recap how Bitcoin transactions work. Essentially, in Bitcoin each transaction output has a public key associated to it (identified, though not revealed, by the Bitcoin address on the output), and to spend that output you need to produce a small script including a digital signature using this key. When everyone sees that transaction, they see that the old output(s) are spent (so they can forget about it, except as far as keeping historical blockchain data for new users) and that new unspent output(s) have been created. Ring signatures, on the other hand, are associated to an arbitrary set of public keys, and knowledge of only one is required to make a signature. CryptoNote uses this by having each transaction input be a set of potential unspent outputs of the same value, signed by a ring signature using all those outputs' associated keys. It is impossible to determine which one is the \"real\" one that the signer is actually spending. You might ask, if it's impossible to determine which outputs are being spent, how can double-spending by prevented? CryptoNote solves this using a special ring signature algorithm (which is a modified version of existing signatures, so this is original cryptography and their security proof should be scrutinized — fortunately it is not too complicated) in which the real signing key has a key image associated to it, which must be published alongside the signature. This key image cannot be reversed to get the original key and deanonymize the sender, but if a double-spend is attempted, users will see that the same key image is used twice and reject the second attempt. This provides good anonymity, but even with the improvements listed presently, this is not a zero-knowledge scheme . This means that linkability is confounded but an adversary with good analysis tools will certainly be able to glean a non-zero (literally, infinity times as much as zero) amount of information. This is a very promising direction, and these signatures are feasible to verify by ordinary computers (though they are more difficult, so scaling will be worse than Bitcoin's), but there are some serious limitations. Fortunately, all are fixable. The following list is the result of conversations between myself, Greg Maxwell, Peter Todd, Mark Friedenbach, Adam Back and several others (who I'm sure will contact me to be listed :)), and to the best of my knowledge hasn't been published anywhere. So aspiring anonymous altcoins developers, here is a wishlist: In Bitcoin, because transaction outputs are incontrovertibly spent, the total list of unspent outputs grows only very slowly. Nodes with limited storage are able to store this, and basically nothing else: when they see a new block, they verify it then update their list of unspent outputs accordingly. In CryptoNote this is impossible since transaction outputs are never definitely spent: there is a giant list of potentially spendable outputs, and a giant list of spent key images, and both of these grow very quickly and never shrink. Current CryptoNote implementations, except for Monero, store this all in RAM, which puts a pretty serious cap on their scalability today. One of Monero's scalability improvements is to store this set on disk in a very fast LMDB database , but the set of mixable outputs is still unbounded and is expected to grow faster than Bitcoin's comparable utxoset. However, this can be further be improved by having users store only the outputs whose keys they own (plus some extras for anonymity) and only a subset of spent key images, which I will describe. The set of outputs would be stored in an insertion-ordered Merkle tree (so a user storing almost none of the tree can easily verifiably append new outputs, but can't detect duplicates, which is fine). The set of images would be stored in a image-ordered Merkle tree (so a user storing almost none of the tree can easily add a new key image and verify that it didn't exist before, given a proof of insertion, which is basically a path from the new node to the root of the tree, along with the siblings of each node along the way). To spend an output, the user provides a ring signature including the output, with appropriate key image and proof-of-new-insertion. Note that to produce a proof of insertion for the new key image, the user needs to store all its neighbors in the key image tree. Since key images are random-looking, how can this be done without storing the whole thing? The answer is prefix-filtering . When a user creates a new key, he creates one whose first 10 bits (say) are a specific ten-bit sequence that all his key images will have. He stores every key image that starts these ten bits so that he can produce proof-of-insertion of such images. The result is a reduction in anonymity (by a factor of $2^{10}$) since everyone will know that nearby key images are more likely to be owned by the same person than are far-away ones, but a corresponding reduction in storage requirements (by a factor of $2^{10}$) and an increase in key generation time (since on average $2^{10}$ keys will need to be generated before one with the right prefix comes along). This is a tradeoff that every user will have to make. Peter Todd has suggested choosing a new prefix every few months or years, and retiring those in which every known key image has been used. This gets more privacy for the storage hit than simply decreasing the prefix length, since two key images in different prefix sets don't reveal their common owner. With ring signatures, the anonymity set is only as large as you make it, probably just two or three potential keys per signature. We can improve this to effectively CoinJoin all transactions in each block (with the caveats that (a) miners can deanonymize the CoinJoin, reducing anonymity to the smaller set provided by the ring signatures, and (b) it is possible to miners to detectably cheat, so there is a small window after mining in which block content might be invalidated by revealing its cheating, which increases complexity) (the complexity hit is because it is important that the block content , not the block itself, be invalidated, since otherwise miners could deliberately cheat then reveal the cheating later, giving them a large window in which everyone else is mining a bad chain). The exact scheme is described at the very top of this IRC log . (The same security can be provided with fancy cryptography, specifically one-way aggregatable signatures (\" just the math \" by Greg Maxwell), which depends on pairing-based cryptography, which is slow and requires new security assumptions that make some people uncomfortable. The exact way these would be used is described from 21:24:58 onward in these IRC logs . It is very cool that we can get the same security with no new crypto.) With ring signatures, your anonymity can be compromised after the fact by others in your anonymity set. For example, if you spend an output using a ring signature along with two other outputs, then those other outputs' owners spend them with a single-signature ring signature (so they are incontrovertibly spent), it is now clear which of the three you used is yours, since each can be spent only once. This can be done long after the fact, which complicates analysis. This can be fixed by requiring a minimum size of anonymity set, as Monero has done on a protocol level since March, 2016. But then we have a new problem — there are only so many outputs of any given size, and since all outputs in an anonymity set must be the same size (so the network knows how much you are spending), this might not be possible. This can be fixed by allowing outputs of any size in the anonymity set, and taking the minimum size to be the spend amount. But then given a ring signature across several outputs' keys, people will know that the output with smallest size will be the \"real\" one. This is because each output can only be spent once, so if you mix it with smaller outputs, you are basically shrinking it to the size of those outputs since the network will only recognize the smaller value. All these problems are addressed in the next point. With ring signatures, you need all potential inputs to have same (or similar) value, which greatly restricts your anonymity set. In fact, Greg Maxwell and I found a way such that every single output can be read as any uniform distribution of outputs (so 1BTC might be spendable as a single 1BTC output, or two 0.5 BTC outputs, or three 0.33 BTC outputs, etc.) There is a single \"real\" distribution, but only the creator of the output knows this, and it is not revealed except in the case of leaked keys. Therefore, literally every single output size can plausibly be claimed to be created by every output, and therefore all outputs can participate in each anonymity set. This scheme is described in this writeup . With this is place, it is feasible to set a minimum anonymity set size, preventing people from using keys with no anonymity set and compromising their own and others' anonymity. They can still do this compromise by revealing their secret key, but it's not clear to me that this is even possible to prevent. Monero has addressed this issue in a similarly powerful manner, by implementing a scheme based on Greg Maxwell's Confidential Transactions . This novel scheme and implementation is called Ring Confidential Transactions . Because the value of outputs is no longer known under this RingCT scheme, you are no longer forced to only mix with a small subset of outputs (ie. those of the same denomination, which in CryptoNote and pre-RingCT Monero are all ^10 denominated outputs). This massively increases the potential anonymity set, and ensures that even large outputs are not \"stuck\" with only a handful of matching, mixable outputs. And by the way, Dash (formerly Darkcoin) does not provide anonymity. They attached a (broken) implementation of CoinJoin to the ordinary Bitcoin client, and at least initially released it as a closed-source software. I haven't looked into Anoncoin, but the best advice I have for folks looking into altcoins is to assume they are uninteresting (and probably dangerously broken ) until someone has demonstrated a concrete technical innovation.",
      "First of, I am a Monero core developer. I'll try to remain as factual and objective as possible, though. Now, for the simple answer: use Monero And for the longer answer: read Andrew Poelstra's very informative reply. I would also add the following: Zero-Knowledge Proof has several of fundamental issues that may not even be fixable (from the less critical to the most critical): trusted accumulator, lack of academic research, obscuring the whole economy means that it is impossible to notice a bug until the economy had already been badly damaged. See our comparison on Monero ANN. The CryptoNote technology is sound, but most actual implementation of it are not -- Boolberry and particularly Monero being the only ones worth considering, on the grounds of market confidence, activity and volume. Monero also works with the i2p initiative to obsfuscate IP (the only thing left visible once CryptoNote is in action)."
    ]
  },
  {
    "question": "How can I restore my wallet?I just purchased a new laptop and I want to decommission my old one. I have a back-up of my wallet.dat file copied to my new PC. What do I need to do to restore it to my Bitcoin (Windows) client? Please note, this is a wallet.dat file that is about 6 months old and I haven't loaded it in at least four months. I'm not sure if that makes a difference or not, contingent on the original version of the client that created the file.",
    "answers": [
      "You need to put the old wallet.dat in your bitcoin data directory. The default for Windows is: C:\\Documents and Settings\\YourUserName\\Application data\\Bitcoin (XP) C:\\Users\\YourUserName\\Appdata\\Roaming\\Bitcoin (Vista and 7) Then run the bitcoin client with the -rescan option. Alternatively you can run the bitcoin client with the -datadir= as well as the -rescan option if you do not want to move/backup the new wallet.dat. The default for Mac OS X is: ~/Library/Application\\Support\\Bitcoin The default for Linux is: ~/.bitcoin"
    ]
  },
  {
    "question": "What is the database for?I see the block chain is stored according to the block chain format specification. But I also see there is a database, which is currently a leveldb database. Why is the block chain stored in two different ways? Seems redundant.",
    "answers": [
      "There are basically four pieces of data that are maintained: blocks/blk*.dat : the actual Bitcoin blocks, in network format, dumped in raw on disk. They are only needed for rescanning missing transactions in a wallet, reorganizing to a different part of the chain, and serving the block data to other nodes that are synchronizing. blocks/index/* : this is a LevelDB database that contains metadata about all known blocks, and where to find them on disk. Without this, finding a block would be very slow. chainstate/* : this is a LevelDB database with a compact representation of all currently unspent transaction outputs and some metadata about the transactions they are from. The data here is necessary for validating new incoming blocks and transactions. It can theoretically be rebuilt from the block data (see the -reindex command line option), but this takes a rather long time. Without it, you could still theoretically do validation indeed, but it would mean a full scan through the blocks (207 GB as of march 2019 - https://www.blockchain.com/charts/blocks-size ) for every output being spent. blocks/rev*.dat : these contain \"undo\" data. You can see blocks as 'patches' to the chain state (they consume some unspent outputs, and produce new ones), and see the undo data as reverse patches. They are necessary for rolling back the chainstate, which is necessary in case of reorganisations. So yes, everything but the block data itself is indeed redundant, as it can be rebuilt from it. But validation and other operations would become intolerably slow without them."
    ]
  },
  {
    "question": "Is there anywhere to get free testnet bitcoins?I'm building a project with bitcoins and want to test it with testnet. However, I don't have any testnet bitcoins, and despite the difficulty being less than 100 usually, I still haven't been able to mine a block on my PC (CPU only) after a day. Is there anywhere I could get just some small amount of testnet bitcoins for testing?",
    "answers": [
      "(Link to faucet URL removed... please see the community wiki answer further down the page for links of faucets.) The term \"faucet\" has been used for quite some time for a site giving away small quantities of coins for free. If all links in this page stop working, a web search for \"bitcoin testnet faucet\" may find a different site.",
      "One more site to get free test bitcoins... http://kuttler.eu/bitcoin/btc/faucet/"
    ]
  },
  {
    "question": "How do I cancel my blockchain transaction (still unconfirmed)?I am using blockchain.info. I have made a bitcoin transaction of 22.00883562 BTC to the address 1A9eUAc78tGx65X3CuC9WfSKXXgxjU8ccC . You can see the transaction at https://blockchain.info/tx/97c1af82111cdcf17f878eb6df20c17c59c1b1fc04e8cdce36b8ac6c6d1c969a I have paid a 0.001 fee but it has been almost 30 hours and it still shows \"Unconfirmed\". What could be the error? Also, more importantly, how do I cancel the unconfirmed transaction and get back my coins?",
    "answers": [
      "Cancelling unconfirmed transactions is easy. Just submit a higher fee double-spend transaction. For example: if you sent a 0-fee transaction, it could take a day before it gets mined onto a block. You can send another transaction with the same inputs that just sends the money back to yourself. On this transaction you put a higher fee. This becomes more likely to be mined and will get included in the blockchain - invalidating the slower-to-confirm original. Some tools to help out: https://github.com/petertodd/replace-by-fee-tools",
      "You cannot cancel an unconfirmed transaction. When a transaction has been transmitted to the chain, it's unstoppable. Luckily everything went well for you I see, and it was probably an error on blockchain.info, as pointed out in the comments."
    ]
  },
  {
    "question": "How is the whitepaper decoded from the blockchain (Tx with ~1000x m of n multisig outputs)The whitepaper is apparently encoded at 54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713 , which is an m of n multisig Tx with 947 outputs (just under the scriptsig limit of 20kB!). Using the Blocktrail Python SDK , I get a list of the outputs as hex using the following Python (2.7) code (NB, the APIKEY , APISECRET parameters are available if required from www.blocktrail.com ): from blocktrail import APIClient bt_client = APIClient(APIKEY, APISECRET, network='BTC') txnObj = bt_client.transaction('54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713') hashes = [(t['script_hex']) for t in (txnObj)['outputs']] The resulting list is available here in full and is essentially all pay-to-pubkey-script Txns. An excerpt: [u'5141e4cf0200067daf13255044462d312e340a25c3a4c3bcc3b6c39f0a322030206f626a0a3c3c2f4c656e6774682033203020522f46696c7465722f466c617465446541636f64653e3e0a73747265616d0a789cad5c4b8b24b911becfafa8b3a1da292925654253d0d55373f06d61c007e39bbd061f0cde8bffbe25c55b5266f61ab3905d419ba54728e28bb76a963777fbcfb77fdf96db7d291f93f3e599f7fafcedefb73fffe1f6aff665fdefb77f7c7bfefce6c2fa166e695bdfd6dbcfbfddfef8c3dd5cf953ae', ..... u'514130206e200a30303030313832353430203030303030206e200a747261696c65720a3c3c2f53697a652036382f526f6f74203636203020520a2f496e666f20363720413020520a2f4944205b203c43413142304134344244353432343533424546393138464643443436444330343e0a3c4341314230413434424435343234353342454641393138464643443436444330343e205d0a2f446f63436865636b73756d202f36463732454137353134444641443233464142434337413535303032314146370a3e53ae', u'51213e0a7374617274787265660a3138323732370a2525454f460a000000000000000051ae', u'76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac', u'76a914031c79236ff3017496cf8d9a883f494458f245f288ac'] QUESTION: How is this array of hex data parsed into the bitcoin.pdf ? Specific Python framed answers would be appreciated!",
    "answers": [
      "This is a fun little puzzle on the blockchain, basically. First, you need to know a little about pdf's and how they're structured, which you can find here . Second, you'll note from section 3.4.1 that all pdf's start with this string: %PDF- In hex, that is 255044462d . And indeed that is in the very first output in the very first bare multisig pubkey: <067daf13>**255044462d**312e340a25c3a4c3bcc3b6c39f0a322030206f626a0a3c3c2f4c656e6774682033203020522f46696c7465722f466c6174654465 I haven't figured out what the first 8 bytes are for (♦ edit : e4cf0200067daf13 = 2x 4byte little Endian \"checksums\", see @WizardOfOzzie comment below ), but the rest of the bare multisig keys (everything in between 1 and 3 OP_CHECKMULTISIG in each output -- note the last one is a 1 of 1, so it's 1 OP_CHECKMULTISIG) are pieces of data for the pdf and they are in order. If you can put all the hex digits of the bare multisig keys into a single file (no whitespaces) called \"fromblockchain.hex\", you can run this very simple program to extract the pdf: contents = open('fromblockchain.hex').read() bytes = contents[16:].decode('hex') f = open(\"bitcoin.pdf\") f.write(bytes) f.close() This should create a bitcoin.pdf which is the actual satoshi whitepaper. I've tested this and indeed it is the whitepaper. Good to know it's literally in the blockchain. Alternatively, if you have bitcoind running on your machine, you can run this python script to grab the bitcoin whitepaper: import subprocess # raw = full hex of raw Tx using Bitcoin-cli raw = subprocess.check_output([\"bitcoin-cli\", \"getrawtransaction\", \"54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713\"]) outputs = raw.split(\"0100000000000000\") pdf = \"\" for output in outputs[1:-2]: # there are 3 65-byte parts in this that we need cur = 6 pdf += output[cur:cur+130].decode('hex') cur += 132 pdf += output[cur:cur+130].decode('hex') cur += 132 pdf += output[cur:cur+130].decode('hex') pdf += outputs[-2][6:-4].decode(\"hex\") f = open(\"bitcoin.pdf\", \"wb\") f.write(pdf[8:-8]) f.close() Finally checking checksum sha256sum bitcoin.pdf b1674191a88ec5cdd733e4240a81803105dc412d6c6708d53ab94fc248f4f553 bitcoin.pdf",
      "This is a bash command that can also give you the file: bitcoin-cli getrawtransaction 54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713 0 00000000000000ecbbff6bafb7efa2f7df05b227d5c73dca8f2635af32a2e949 | sed 's/0100000000000000/\\n/g' | tail -n +2 | cut -c7-136,139-268,271-400 | tr -d '\\n' | cut -c17-368600 | xxd -p -r > bitcoin.pdf It doesn't need -txindex , but it does need a full node, not pruned. I suppose it's possible to make a variant that works with gettxout that works with pruned nodes, but that's left as an exercise for the reader."
    ]
  },
  {
    "question": "Is a private blockchain better in any sense than a database?Since the banks appear to be currently looking into the idea of \"blockchains\" but don't want to be dealing with \"Bitcoin\" , it seems that there is a lot of hype for private blockchains out there like Eris or Hyperledger. However, a lot of people tend to point out that a blockchain without a currency is essentially \"an SQL database\". I'm wondering, does a private blockchain have any advantages over a traditional database solution, or can everything that a private blockchain does be replicated with some effort using a database application?",
    "answers": [
      "It depends on what you mean by \"private\". The word private is not really associated with Eris as far as I can tell. Rather, the word \"permissioned\" is used instead, and therein lies all the difference and your answer. A \"private\" blockchain might imply a blockchain that is not shared with anyone. Such blockchains would effectively amount to slow databases and nobody would have much need for them. Eris' value proposition over traditional databases is simple: integrity through cryptographically signed history. What's stopping twitter from editing my tweets and making it seem like I said something I didn't say? Little to nothing. This is where a blockchain approach comes in. If twitter stored tweets in a blockchain that others could copy, then any modifications that twitter made to this chain would be caught. Blockchains preserve the integrity of the data within a database. They prevent people from cooking the books. This is of extraordinary importance and value. Comparison to git Git does not have a smart contracts system within its protocol. Git is more of a filesystem interface, whereas Eris seems more like a database interface, to be used in environments where databases are sometimes used. Git is rarely used like a database.",
      "Signed commitments with immutable history are all that’s required for proof of integrity. Moreover, assuming commitments are immutable (transactions can only be reversed by adding a new commitment that reverses the actions of the previous commitment), you only need to keep track of the most recent commitment. If the commitment signer is a known entity, a single honest \"auditor\" is all that's required to keep the commitment signer honest. Anyone closely watching the signer will be able to easily prove the signer modified the history. Database transactions needn’t be represented via clunky, inefficiently implemented transition functions (i.e. connecting a block), and the argument that git is more of a filesystem than a database is somewhat irrelevant…the same principles apply to nonhierarchical data structures (i.e. DAGs) subject to arbitrary transition functions (i.e. smart contracts)."
    ]
  },
  {
    "question": "Why don't the timestamps in the block chain always increase?The timestamps starting at block 145044 are: 145044: 2011-09-12 15:46:39 145045: 2011-09-12 16:05:07 145046: 2011-09-12 16:00:05 // ~5 minutes before prior block 145047: 2011-09-12 15:53:36 // ~7 & ~12 minutes before 2 prior blocks 145048: 2011-09-12 16:04:06 // after 2 prior blocks but still before 145045 How does this occur?",
    "answers": [
      "From the wiki : A timestamp is accepted as valid if it is greater than the median timestamp of previous 11 blocks, and less than the network-adjusted time + 2 hours. \"Network-adjusted time\" is the median of the timestamps returned by all nodes connected to you. Whenever a node connects to another node, it gets a UTC timestamp from it, and stores its offset from node-local UTC. The network-adjusted time is then the node-local UTC plus the median offset from all connected nodes. Network time is never adjusted more than 70 minutes from local system time, however. It's not obvious that there aren't any problems with this way of timestamping. See the blog post Timejacking & Bitcoin and the discussion about it here .",
      "The root cause of this is that without a central authority, it's impossible to know for sure what the current time is. The protocol rejects blocks with a timestamp earlier than the median of the timestamps from the previous 11 blocks or later than 2 hours after the current network time. Any other timestamp is acceptable. Note that 'network time' may differ from the actual time, since the bitcoin network attempts to correct for incorrect clock settings by taking the median of the time reported by all connected peers as the network time. You can read about an attack that this makes possible here : By announcing inaccurate timestamps when connecting to a node, an attacker can alter a node's network time counter and deceive it into accepting an alternate block chain. This could significantly increase the chances of a successful double-spend, drain a node's computational resources, or simply slow down the transaction confirmation rate."
    ]
  },
  {
    "question": "How is a wallet's balance computed?I am wondering on how a wallet's balance is computed. Basically, from what I've read I assume that you look back at all transactions involving all the keypairs of a given wallet. Adding up all the transactions' balances (negating a transaction balance when the transaction was outbound) should match the wallet's balance, right? A) Is there Python code available that computes a given wallet's balance? I am not looking for a complete wallet software, just a minimalistic (academic) Python code example. B) If using a web service, e.g. https://blockchain.info/q/addressbalance/$addr , how do I derive the address $addr to query from a given wallet? Any Python code?",
    "answers": [
      "There is no such thing as a transaction \"balance\". I am going to assume if I jump right to the answer it won't make much sense so the first two sections are to make sure we are how Bitcoin \"really works\" (at a very high level abstracted view). We need to speak the same language for the answer to make any sense. For this question the two required concepts in how Bitcoin really works that need to be understood are inputs & outputs, as well as where transactions are recorded. Inputs & Outputs Bitcoin works on the concept of discrete inputs and outputs not spending part of a balance. All transactions have as their input a reference to a previous unspent output. The transaction records one or more new outputs (which are referenced in the inputs of some future transactions). Outputs are \"spent\" when they are referenced in a new transaction. Outputs can only be unspent or spent, they can't be partially spent. Wallet balance (or address balance) is an abstraction to help us humans and make Bitcoin more like conventional payment systems. Balances are not used at the protocol level. When the wallet indicates your confirmed balance is 1.2 BTC it is saying that the sum of the value of all unspent outputs in the blockchain which correspond to public keys it has the private key for total 1.2 BTC. In other words the wallet is computing the total value of the outputs which it can spend which requires a) the output be unspent and b) the client has the private key necessary to spend it. Storing Transactions All confirmed transactions become part of the blockchain. Clients validate transactions and blocks; only valid transactions and blocks are added to the blockchain. For the purposes of validating transactions and computing available balances only part of the blockchain is needed and that portion is called the UTXO (Unspent Transaction Output Set) . This is a subset of JUST the unspent outputs. As all future transactions will reference unspent outputs as their inputs only the unspent outputs are needed for validating new transaction and computing the balance (which is another way of saying the total value of outputs which \"can\" be used in new transactions). The UTXO is much smaller than the entire blockchain (about 15% of total blockchain right now and that will shrink over time). It may not be immediately obvious but the number of Bitcoins in the UTXO is always equal to the number of mined Bitcoins. Unconfirmed transactions are not part of the blockchain (or UTXO). Clients maintain an unordered list of all the unconfirmed transactions they are aware of. This list is called the memory pool . Computing \"Balances\" The creation of the UTXO makes computing balances straightforward. The UTXO contains all unspent outputs however your client can only spend the subset of those outputs which correspond to public keys that it has the private key for (\"your keys\"). This subset has no official name however the RPC call to output this list is listunspent so I will call it the listunspent set. The wallet uses the listunspent set and memory pool to determine the current balance. In reality wallets compute this in \"real time\" as changes to the memory pool or UTXO occur (i.e. when the client learns of new blocks or transactions it records them and then makes changes to its reported balance if any). For the sake of brevity I will just show how to get a \"snapshot\" of the current balance. There is a confirmed balance and an unconfirmed balance, clients often show a reduced-current balance to simplify things for users. Confirmed Balance The confirmed balance is the sum of the value of the \"listunspent\" set. Example: the listunspent (outputs in UTXO which client has keys for) has 20 outputs and combined they have a total value of 1.2 BTC so the confirmed balance is 1.2 BTC. Reduced-Confirmed Balance Client usually do not show the \"real\" confirmed balance because users are more interested in what they have available to spend. Transactions in the memory pool which have inputs that reference outputs in the listunspent set technically have no yet reduced the confirmed balance. In most cases they will eventually confirm so clients will remove these outputs when computing the \"confirmed\" balance. The \"confirmed\" balance in most wallets is actually this reduced-confirmed balance. It is done to abstract the way Bitcoin really works. If it wasn't then the confirmed balance would not reduce until a transaction was confirmed which might seem confusing to a user (they have 100 BTC, spend 1, it still shows 100 BTC). A client could break this down into \"confirmed balance\", \"reserved for unconfirmed transactions\", and \"available balance\". Unconfirmed Balance An unconfirmed tx \"to\" the client will not be in the UTXO yet. It will however be in the memory pool. The sum of all the outputs (which the client has keys for) in the memory pool is the pending balance. Those tx will either be confirmed (the tx and output is removed from memory pool and added to the UTXO) or they will be dropped. Handling Change Due to the way Bitcoin handles \"change\" (outputs can be partially spent so the unused portion is sent back to the user) the simplified example above while accurate would be confusing to the user. Most wallets \"cheat\" and include the unconfirmed change outputs in the \"reduced-confirmed\" balance. This isn't a requirement however not hiding this aspect from users may lead to some unexpected behavior. Imagine a client with a reduced-confirmed balance of 100 BTC and a pending balance of 0 BTC. The user \"spends\" 1 BTC however the outputs referenced in the new tx total 5 BTC. This means the new outputs are actually 1 BTC + 4 BTC \"change\". If balances weren't modified to \"hide\" the change, after the spend the user would see confirmed balance of 95 BTC and a pending balance of 4 BTC."
    ]
  },
  {
    "question": "Redeeming a raw transaction step by step example requiredI am looking, specifically, for a step by step example transaction of sending Bitcoin which uses an actual transaction ( How To Redeem A Basic Txn , from a few years back, does a great job of outlining most steps of sending a raw txn but does not use a real TxID ). I have played around with both the Python pybitcointools library, the SX library and JSON output from the Bitcoin Core client (Bitcoin-QT, Bitcoin-cli, Bitcoin daemon) but have yet to find an actual step by step guide using raw transaction output (single input / single output Bitcoin txn, ie not multisig). Hopefully the bounty will bring a step by step example transaction (with private keys for the sending address) will bring an answer showing how it's done and, specifically: how the ScriptPubKey element fits into the raw txn how the ScriptSig element fits into the raw txn how the txn is signed (with DER encoding). EDIT: I think the best resource is Ken Shirriff's Bitcoins the hard way: Using the raw Bitcoin protocol , but again, there's no single source online that answers my question without skimming past areas like scriptPubKey, signing etc. When I activate the bounty, if you can answer this refer to this Tx as it can serve as the actual example (ie I'll provide ~$1 in BTC and private keys for 1From/1MBngSqZbMydscpzSoehjP8kznMaHAzh9y if interested) EDIT 2: The RoyalFork Blog: Deconstructing Txns provides an unbelievably good reference for interactive Txn creation",
    "answers": [
      "Step-by-step description: We start creating a new transaction which we hash and sign. Add four-byte version field: 01000000 One-byte varint specifying the number of inputs: 01 32-byte hash of the transaction from which we want to redeem an output (reverse order): be66e10da854e7aea9338c1f91cd489768d1d6d7189f586d7a3613f2a24d5396 Four-byte field denoting the output index we want to redeem from the transaction with the above hash (counting from zero): 00000000 Now comes the scriptSig. For the purpose of signing the transaction, this is temporarily filled with the scriptPubKey of the output we want to redeem. First we write a one-byte varint which denotes the length of the scriptSig (0x19 = 25 bytes): 19 Then we write the actual scriptSig (which is the scriptPubKey of the output we want to redeem): 76 a9 14 dd6cce9f255a8cc17bda8ba0373df8e861cb866e 88 ac (look to the bottom line line on https://blockchain.info/tx/96534da2f213367a6d589f18d7d6d1689748cd911f8c33a9aee754a80de166be?show_adv=true ) Then we write a four-byte field denoting the sequence. This is currently always set to 0xffffffff: ffffffff Next comes a one-byte varint containing the number of outputs in our new transaction. We will set this to 1 in this example: 01 We then write an 8-byte field (64 bit integer, little-endian) containing the amount we want to redeem from the specified output. I will set this to the total amount available in the output minus a fee of 0.0001 BTC (128307 - 10000): 23ce010000000000 Then we start writing our transaction's output. We start with a one-byte varint denoting the length of the output script (0x19 or 25 bytes): 19 Then the actual output script: 76 a9 14 a2fd2e039a86dbcf0e1a664729e09e8007f89510 88 ac ( this is transferring funds back to address 1FromKBPAS8MWsk1Yv1Yiu8rJbjfVioBHc ) Then we write the four-byte \"lock time\" field: 00000000 And at last, we write a four-byte \"hash code type\" (1 in our case): 01000000 OK, the result is 01000000 01 be66e10da854e7aea9338c1f91cd489768d1d6d7189f586d7a3613f2a24d5396 00000000 19 76 a9 14 dd6cce9f255a8cc17bda8ba0373df8e861cb866e 88 ac ffffffff 01 23ce010000000000 19 76 a9 14 a2fd2e039a86dbcf0e1a664729e09e8007f89510 88 ac 00000000 01000000 Now we double-SHA256 hash this entire structure, which yields the hash 1cde0239b55717cca8003104abc2ec2673d4f6fabea0b74351940e382e88486f Now we should create ECDSA signature... 1MBngSqZbMydscpzSoehjP8kznMaHAzh9y is a brainwallet of \"mrbubbymrbubbymrbubby!\" , which just happens to encode an address starting in 'MB' (making linking the 2 quite easy; see @WizardOfAussie comment below for phrase origins). Private key in WIF: 5HvofFG7K1e2aeWESm5pbCzRHtCSiZNbfLYXBvxyA57DhKHV4U3 In hex, the private key is 0ecd20654c2e2be708495853e8da35c664247040c00bd10b9b13e5e86e6a808d . There is a sign (key, digest) method in every crypto lib. It will return an array of bytes. This array will be no more than 72 bytes, and start with hex code 30. Lets imagine that the signature is 3046022100cf4d7571dd47a4d47f5cb767d54d6702530a3555726b27b6ac56117f5e7808fe0221008cbb42233bb04d7f28a715cf7c938e238afde90207e9d103dd9018e12cb7180e To this signature we append the one-byte hash code type: 01 . The public key for 1MBngSqZbMydscpzSoehjP8kznMaHAzh9y is: 042daa93315eebbe2cb9b5c3505df4c6fb6caca8b756786098567550d4820c09db988fe9997d049d687292f815ccd6e7fb5c1b1a91137999818d17c73d0f80aef9 We construct the final scriptSig by concatenating: |< The actual DER-encoded signature plus the one-byte hash code type>|< One-byte script OPCODE containing the length of the public key>| scriptSig will be 49 3046022100cf4d7571dd47a4d47f5cb767d54d6702530a3555726b27b6ac56117f5e7808fe0221008cbb42233bb04d7f28a715cf7c938e238afde90207e9d103dd9018e12cb7180e 01 41 042daa93315eebbe2cb9b5c3505df4c6fb6caca8b756786098567550d4820c09db988fe9997d049d687292f815ccd6e7fb5c1b1a91137999818d17c73d0f80aef9 first line is 'push signature concatenated with 01', second line is 'push pubkey'. The length of scriptSig is 140 bytes (0x8c in hex) We then replace the one-byte, varint length-field from step 5 with the length of the data from step 16. The length is 140 bytes, or 0x8C bytes: 8c And we replace the actual scriptSig with the data structure constructed in step 16. We finish off by removing the four-byte hash code type we added in step 13, and we end up with the following stream of bytes, which is the final transaction: 01000000 01 be66e10da854e7aea9338c1f91cd489768d1d6d7189f586d7a3613f2a24d5396 00000000 8c 49 3046022100cf4d7571dd47a4d47f5cb767d54d6702530a3555726b27b6ac56117f5e7808fe0221008cbb42233bb04d7f28a715cf7c938e238afde90207e9d103dd9018e12cb7180e 01 41 042daa93315eebbe2cb9b5c3505df4c6fb6caca8b756786098567550d4820c09db988fe9997d049d687292f815ccd6e7fb5c1b1a91137999818d17c73d0f80aef9 ffffffff 01 23ce010000000000 19 76 a9 14 a2fd2e039a86dbcf0e1a664729e09e8007f89510 88 ac 00000000",
      "This is an excellent answer by amaclin and Wizard of Ozzie. I'd just like to add some more detail for the Wizard of Ozzie's transaction at blockchain.info . The correct input to the signature process for this transaction is 01000000 01 be66e10da854e7aea9338c1f91cd489768d1d6d7189f586d7a3613f2a24d5396 00000000 19 76 a9 14 dd6cce9f255a8cc17bda8ba0373df8e861cb866e 88 ac ffffffff 01 23ce010000000000 19 76 a9 14 2bc89c2702e0e618db7d59eb5ce2f0f147b40754 88 ac 00000000 01000000 The double-SHA256 hash of this is computed by bx as d304448dff517bcf677cd36f3491e9ef2ccfdf40fb63af5782d9b768640af130 but this is written in \"reverse\" order for whatever peculiar historical reason (I've heard it was to be compatible with M*soft CRAPi). So when using this with the sign(key, digest) in most sensible crypto toolkits you may need to reverse the hash value to the \"proper\" order for SHA256(SHA256(m)) 30f10a6468b7d98257af63fb40dfcf2cefe991346fd37c67cf7b51ff8d4404d3 The above input data will indeed validate against the signature given in the actual blockchain transaction 3045022100da43201760bda697222002f56266bf65023fef2094519e13077f777baed553b102205ce35d05eabda58cd50a67977a65706347cc25ef43153e309ff210a134722e9e using the given public key 042daa93315eebbe2cb9b5c3505df4c6fb6caca8b756786098567550d4820c09db988fe9997d049d687292f815ccd6e7fb5c1b1a91137999818d17c73d0f80aef9 To generate a reproducible signature over the same data, the following signature has been made by the deterministic method of RFC6979 . 30450220587ce0cf0252e2db3a7c3c91b355aa8f3385e128227cd8727c5f7777877ad772022100edc508b7c14891ed15ab38c687019d7ebaf5c12908cf21a83e8ae57e8c47e95c using the matching private key provided by Wizard of Ozzie 0ecd20654c2e2be708495853e8da35c664247040c00bd10b9b13e5e86e6a808d This signature also validates over the given data using the public key and should be reproducible."
    ]
  },
  {
    "question": "Why doesn't Bitcoin return lost coins back into the block reward?The idea of putting back lost Bitcoins back onto block rewards seems like a great idea. I acknowledge that there were quite a handful of early adopters who were generating blocks daily, but had no idea what they were doing. Time passes, they forget about Bitcoin and they format their hard drive or whatever. Their coins enter the nether, never to be seen again. I wouldn't be surprised if >5% of the current coins in circulation were lost due to mishandling. My question is, why isn't there something implemented for this? I can't find any disadvantage for this feature, it would simple as invalidating coins that haven't been transferred in x amount of time, which is probable for only sorting lost coins.",
    "answers": [
      "As Stephen points out it would force people to spend coins. Age is not a proper measure of lostness. A common recommendation for savings accounts is to put them on physical backups such as printed QR codes that you add to while the account itself remains offline. People may even will their Bitcoin savings to their children. To force people to shuffle these coins around from time to time to keep them from being taken undoes one of the major safety features of Bitcoin. Namely that transactions can not be reversed, and your accounts can not be frozen or taken from you by any mechanism. Also there is no reason. The entire Bitcoin economy could be run on a single bitcoin because of its divisibility. There simply is no reason to break other important Bitcoin features to regain those coins. It wouldn't even actually increase the miners' rewards because for every extra coin brought back the wealth is distributed over more coins reducing the value of each coin with inflation. A million dollars of value spread over 1000 bitcoins if there are 1000 bitcoins in circulation, is the same one million dollars of value spread over 1 bitcoin if there is only 1 bitcoin in circulation.",
      "To do so would force those with coins to spend them -- even if just sending to themselves. Spending coins lessens privacy. That is a property of bitcoin that should not be diminished through this forceful measure. Incidentally, why this fear of lost coins? So there are lost coins. It happens. And we have fewer as a result. It is not a problem -- except for those who lost them :-)"
    ]
  },
  {
    "question": "How do I build Bitcoin source in Windows 7?I am trying to build the current Bitcoin source in Windows 7x64 - Does anyone know of an idiot-proof tutorial? Some of the steps in the included doc give me errors. When I try to tar openssl with msys, I get symlink errors. Is there a better walk-through?",
    "answers": [
      "Take a look at Windows Build Instructions By Matt Corallo, it's outdated, but has some additional comments to the included doc . Install: MinGW Automated Installer from http://sourceforge.net/projects/mingw/files/OldFiles/mingw-get-inst/mingw-get-inst-20110316/ . Install with the C++ and MSYS options checked. Activestate Perl (for building openssl) from http://www.activestate.com/activeperl/downloads . You don't need anything except ActivePerl and Perl, none of the other fancy crap. You do want to add Perl to your PATH (its an option in the installer). Download: WxWidgets 2.9.1: http://sourceforge.net/projects/wxwindows/files/2.9.1/wxWidgets-2.9.1.zip/download . Unzip to C:\\wxWidgets-2.9.1-mgw OpenSSL 1.0.0d: http://www.openssl.org/source/openssl-1.0.0d.tar.gz . Untar to C:\\openssl-1.0.0c-mgw (yes bitcoin is designed to build with 1.0.0c, but might as well use the latest version since it works right?) Hint: untar using the tar binary which is included in MinGW (do not use 7-zip, it will not handle symlinks correctly ) using cd \\c\\ && tar xvvf\\c\\Users\\Matt\\Downloads\\openssl-1.0.0d.tar.gz && mv openssl-1.0.0d openssl-1.0.0c-mgw in the msys shell Berkeley DB 4.7.25 NC: http://download.oracle.com/berkeley-db/db-4.7.25.NC.zip . Unzip to C:\\db-4.7.25.NC-mgw Boost 1.43.0: http://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.zip/download . Unzip to C:\\boost-1.43.0-mgw Boost Jam: http://sourceforge.net/projects/boost/files/boost-jam/3.1.18/boost-jam-3.1.18-1-ntx86.zip/download . Unzip wherever you like, I used C:\\bjam miniUPnPc binary http://miniupnp.tuxfamily.org/files/download.php?file=upnpc-exe-win32-20110215.zip . Unzip to C:\\upnpc-exe-win32-20110215 miniUPnPc source http://miniupnp.tuxfamily.org/files/download.php?file=miniupnpc-1.5.20110215.tar.gz . Untar to C:\\upnpc-exe-win32-20110215\\miniupnpc (you only need *.h, but the others won't hurt) untar with cd \\c\\upnpc-exe-win32-20110215 && tar xvvf \\c\\Users\\Matt\\Downloads\\miniupnpc-1.5.20110215.tar.gz && mv miniupnpc-1.5.20110215 miniupnpc Note that the reason for using the binary miniupnpc release is that I was unable to get it to build on my system. Add C:\\MinGW\\bin to your PATH environment variable (Google is your friend as it depends on your Windows Version). In the DOS Shell: wxWidgets: cd \\wxWidgets-2.9.1-mgw\\build\\msw mingw32-make -f makefile.gcc Boost: cd \\boost-1.43.0-mgw \\bjam\\bjam.exe toolset=gcc --build-type=complete stage In the msys Shell (MinGW shell in your start folder or C:\\MinGW\\msys\\1.0\\msys.bat): OpenSSL: cd /c/openssl-1.0.0c-mgw ./config make perl util/mkdef.pl 32 libeay enable-static-engine > libeay32.def dllwrap --dllname libeay32.dll --output-lib libeay32.a --def libeay32.def libcrypto.a -lws2_32 -lgdi32 Copy the libeay32.dll file to the folder where you are building/running bitcoin. Berkeley DB: cd /c/db-4.7.25.NC-mgw/build_unix sh ../dist/configure --enable-mingw --enable-cxx make Bitcoin If you wish to use git to pull keep a local repository, you'll have to download msgit from http://code.google.com/p/msysgit/downloads/detail?name=Git-1.7.4-preview20110204.exe&can=2&q= . Otherwise, you can download the latest zip of bitcoin from https://github.com/bitcoin/bitcoin/zipball/master In the msys shell, cd to the unzipped location and make -f makefile.mingw Run with ./bitcoin.exe (make sure you have the libeay32.dll in bitcoin folder)"
    ]
  },
  {
    "question": "How exactly does -rescan work?-rescan is a command line argument that is passed to the bitcoin client after restoring wallet.dat from backup. Which files get recalculated? Which files does the rescan command read? Why is it a good practice to first download all the blocks, then rescan, and not the other way around? (as a comment on this answer suggests )",
    "answers": [
      "The bitcoin client stores, in the wallet, the transactions that affect coins it manages. If it sees a new transaction, it checks to see if that transaction affects any accounts stored in the wallet. If so, the wallet is updated. Similarly, if the chain is reorganized, the wallet is updated. However, the client doesn't check to make sure the wallet is synchronized to the current block chain. To fix this, the rescan command can be used. This causes the client, on startup, to go through every single block it has downloaded, search for transactions affecting accounts in the wallet, and update the wallet's transaction store and balances to reflect that transaction. There are a few cases when you definitely need to rescan. For example: If you restore a backed up wallet, it will be missing any transactions in blocks you downloaded after you backed up the wallet. Since the client won't receive those blocks (since it already has them) the normal wallet update logic won't fix this. You will need to rescan. If you modify your wallet, say by adding keys to it or removing transactions from it, the wallet update logic won't see the transactions. So if you use a program other than the client to modify your wallet, you will need to rescan. Theoretically, it shouldn't matter whether you download all the blocks and then rescan or vice-versa. The client won't download blocks while it's rescanning. And newly-downloaded blocks should update the wallet anyway. The logic is basically that this ensures the rescan process sees the blocks containing any missing transactions, rather than the regular block update logic. (They should both work. But if you need to rescan, we know something's wrong anyway.)",
      "This is also useful if you are importing more than 1 private key into your wallet: bitcoind importprivkey 1zbcvs.... \"My Label\" false bitcoind importprivkey 1zbcvs.... \"My Label\" false bitcoind importprivkey 1zbcvs.... \"My Label\" false bitcoind stop # One of the following bitcoind -rescan bitcoin-qt -rescan"
    ]
  },
  {
    "question": "What would happen if a portion of the Bitcoin network was separated from the rest of the network?Yesterday I asked a question over at SuperUser , so that I could have my facts straight before asking this question. The scenario sets the basis for this question. Regarding bitcoin, what would happen to the Bitcoin system if a portion of the world had it's internet connection severed with the rest of the world. In other words if, say, all outside communication was lost in the region of Armenia , would the Armenian Bitcoin users, who continue to use Bitcoin, ultimately create a forked block chain? If so, what would happen to the blockchain when connection to the severed region of the world is restored, and the segregated network is resolved to the primary network? I imagine the outcome would be similar to a 51% attack. Is that correct?",
    "answers": [
      "When bitcoin client downloads two conflicting blockchains, in other words when fork happened, it chooses the longer blockchain as valid, and the shorter becomes invalid and called \"orphan blocks\". \"Length\" is calculated as total combined difficulty of that chain, not number of blocks. Wiki: Block Chain So in your scenario, Armenia most likely has less hashing power then the rest of world and it would produce shorter fork of blockchain, therefore it would be overrided after connection is restored. 51% attack implies coordinated effort from a small group of people with malicious intent, which is not the case according to your scenarion, therefore I wouldn't call 51% attack. It would be easy to counter any negative outcome because users of isolated network would know instantly about the problem from sudden drop of total network hash power, and would just need to avoid spending bitcoins until connection is restored.",
      "It wouldn't be a fork as both chains would only exists as the longest chain until the network was reconnected. As soon as Armenia was reconnected to the internet every client would via block exchange determine there is a longer block and switch to that chain. The orphaned chain would simply be discarded by all clients and eventually the entire network would be \"re-unified\" under the single longest chain. In a situation like that it would be difficult but not impossible to pull off a double spend. An attacker would need to have wallets in both sub-networks so coins could be spent in both sub-networks during the \"isolation\". A precaution to take when isolated from \"main internet\" is to not process any transactions until the sub-networks have rejoined. For example a store could accept coins, and prepare orders but not ship them until rejoining the main network and ensuring no double-spend occurred. If a double-spend had occurred the merchant would become aware once the larger network began processing the orphaned transactions and they were reported as invalid by the network. If no double spend occurred those transactions would eventually be included in longest blockchain and become confirmed. For those in the \"main network\" there is no risk from a double spend because their chain will remain longest and will survive while overwriting transactions from the smaller sub-network once the networks are rejoined."
    ]
  },
  {
    "question": "What are colored coins?What exactly are colored coins? I've tried understanding, but I don't quite get it yet . . . Do any examples exist?",
    "answers": [
      "Colored coins are a method to track the origin of bitcoins, so that a certain set of coins can be set aside and conserved, allowing a party to acknowledge them in various ways. Such coins can be used to represent arbitrary digital tokens, such as stocks, bonds, smart property and so on. The colored coins protocol is decentralized just like Bitcoin, but the current effort to develop an implementation is done under the BitcoinX project (tentative name), which also aims to provide some related services. As this is still under development, you will not find any existing examples. You can read more about it in Overview of colored coins (work in progress)."
    ]
  },
  {
    "question": "Signing Bitcoin transactionsThere is a part of the Bitcoin protocol that I don't quite understand. When you make a transaction, and spend the output of a previous transaction for say 1 BTC, you provide a signature using the private key matching the public key (or address) that appears in the output of the previous transaction. My first question here is what exactly is signed? Second, when the transaction is broadcast, what prevents a malicious peer to take the input of my transaction with signature, for 1 BTC, and forge a new transaction using that same input going to their own address? To avoid that, the full transaction (including outputs) would need to be signed, I couldn't find a document indicating the whole transaction is signed.",
    "answers": [
      "From what I gather you sign both the input and the output of the transaction, meaning that nobody can alter the content of the transaction without invalidating your signature. I also had some problems with this part of the algorithm, and even asked a similar question earlier , but this one deals with more of the low-level bit operations rather than the high-level concept."
    ]
  },
  {
    "question": "Why are there two transaction outputs when sending to one address?I did a small transaction some days ago: https://www.blockchain.com/btc/tx/4c07a07dfd9d5b79d168ec6835df876c64e82350a8f9211bf586d858a5aeb9ba Some info: 1JFWE8THcAQQRYx99c43DXSGyoPL9Zs62D is my wallet 1PCGNxgheKTaeT6xvTabcY8ZbS3gDpFtb is the wallet I sent 0.22 BTC Questions: Who is 147krm8yWUcVq9Ta25h679TCpsEznzgvRz ? Why there is more than one output?",
    "answers": [
      "147krm8yWUcVq9Ta25h679TCpsEznzgvRz is the change from the transaction. There was more than one output because you didn't have any previous transactions (sometimes thought of as \"coins\") that added up the exact amount of the transaction. So your client picked some coins that added up to at least that amount and then created a new address to receive the leftover amount. So, 147krm8yWUcVq9Ta25h679TCpsEznzgvRz is you. You just don't know it because the client isn't good at disclosing that you. Essentially you wanted to send 22 cents, but only had dollar bills in your wallet. So the 0.78 was the leftover amount and the client created a new address to hold it rather than reusing 1JFWE8THcAQQRYx99c43DXSGyoPL9Zs62D . It seems that this behavior of the Qt client (silently creating new addresses that receive the change from transactions) was created for privacy reasons. I believe the thinking was, why send the change back to the original address when a new address could easily be created? In that way, it's not even obvious whether your transaction was a payment of 0.78 BTC with a change of 0.22, or a payment of 0.22 BTC with a change of 0.78 BTC. But it seems to be causing a lot of confusion for users, based on what I see on this stack exchange. In my opinion, it might be better if the default client sent the change back to the sending address. Or if, at least, it showed that change address and its balance somewhere. Some other wallets do let you manually select which address should receive the change from a transaction.",
      "The whole idea of change is a bit hard to grasp when it comes to bitcoin. With paper currency, its fairly obvious that you need change from a 20 dollar bill if you need to spend only 14 dollars. In theory the Bitcoin protocol could have been set up to just send the exact amount as a transaction, but for the blockchain transaction log, I think it was set up like this for neat traceability. If you didn't have the 'input = output - transaction cost' rule, nodes that verify all the transactions would instead need to calculate/determine the balances of individual addresses to see if they have enough coin to cover the transaction. I guess this would cost more in terms of database querying of the log, harder verification of transactions.."
    ]
  },
  {
    "question": "Do these new ASIC miners really pay for themselves in 5 days?The Bitforce 50GH/s miner costs $2,500 today, and according to the following calculation it would mine enough coins in about 5 days to pay for itself. I am sure I am missing something here. Why would they even sell this hardware at all? Surely it makes more sense to keep the hardware and just set it loose on calculating coins and cash them in.",
    "answers": [
      "There's a factor called Difficulty, the more hashing power exists on the network the more difficulty exists, therefore it's harder to mine coins. Right now The difficulty factor would let you recover your money fast because almost no one has ASIC chips, when they ship in bulk the difficulty factor will rise to 30-120 million during the year. To know by how much the difficulty will rise it's impossible, so it's your call.",
      "Not if you don't have one already. The trouble is that you don't know when you'll receive your device and, as @user3418 says, the difficulty will be rising in the meantime. Butterfly Labs (who manufactures the device you're talking about) has only just started delivering devices, and already has a large number of pre-orders. You probably wouldn't receive your device for at least several months, and there's a possibility the device will never earn enough to pay for itself."
    ]
  },
  {
    "question": "In getrawtransaction, what is the vout integer in the vin list?I'm working on trawling the bitcoin transactions coming in via getrawtransaction. I haven't been able to find the neccessary documentation to describe the vout integer in the vin array: {\"txid\"=>\"0fbf9a6f2172251611a58028bf596c3ace98b19f6f08d2b6581326c58aecda8e\", \"vout\"=>0, <----- THIS \"scriptSig\"=> {\"asm\"=> \"3045022100a9ba4f0b8ff86e91e622f43f9b76944643a807c0f6c8b43490087a169fe7542f0220258eaa36c96faaaeb41052e8d4aa41f74950df1b1c2835cb677f201c1ee0a33901 0393a2770ce81ddd9cd1e6ef71a282261ef8c03648373db209078f7850b9ab1ad1\", \"hex\"=> \"483045022100a9ba4f0b8ff86e91e622f43f9b76944643a807c0f6c8b43490087a169fe7542f0220258eaa36c96faaaeb41052e8d4aa41f74950df1b1c2835cb677f201c1ee0a33901210393a2770ce81ddd9cd1e6ef71a282261ef8c03648373db209078f7850b9ab1ad1\"}, \"sequence\"=>4294967295}, {\"txid\"=>\"4983504e9727a5ea73c4a0915da475faba248d0d8da265e2d270563dc3eabbaf\", \"vout\"=>1, <----- THIS \"scriptSig\"=> {\"asm\"=> \"3045022100ccc460cb0b8777d14f27acb821eacae0b5316de19db03ea707c59364f098d44f0220058a4f9df9a917944299b4c52efe500d50ab28c2fd29bb7b9ff8b75f38abcd4201 03244951ad9d146a635b321816d953e54986c62ce9c92502873335531dada0156c\", \"hex\"=> \"483045022100ccc460cb0b8777d14f27acb821eacae0b5316de19db03ea707c59364f098d44f0220058a4f9df9a917944299b4c52efe500d50ab28c2fd29bb7b9ff8b75f38abcd42012103244951ad9d146a635b321816d953e54986c62ce9c92502873335531dada0156c\"}, \"sequence\"=>4294967295} In the transactions I'm seeing, it tends to vout 0 1 0 1 0 1 in the array. What does this represent in a transaction? Do I need to interpret it in a specific way? Thanks!",
    "answers": [
      "The input of every transaction refers to an output of a prior transaction. An input can't be defined by only the transaction hash. A transaction consists of 1 or more outputs if you only specify the transaction hash there is no way to know which output is being spent.** Since these types of questions often come from a larger misunderstanding of how the network \"really works\" I am going to start with some \"plain english\" rules on transactions (tx): 1. A tx consists of one or more inputs and one or more outputs. 2. All tx inputs refer to an unspent output of a prior transaction. 3. The full value of an input is always spent; a tx can not spend part of the value. 4. Likewise all outputs are either spent or unspent, they can't be partially spent. 5. A tx \"spends\" the outputs which are referenced in the input portion of the tx. 6. A tx creates new spendable \"unspent outputs\" listed in the output portion of the tx. Now that we got that out of the way, to define a tx input you need to refer to the hash of a prior transaction AND the output index . The tx hash identifies the transaction, but the transaction may have more than one output so the index is used to identify which output is being \"spent\" here. This may seem confusing because you will hear statements such as \"I have 20 BTC stored at address 1XYZ...\" or \"My wallet had 100 BTC\", but this is really an abstraction. The client is merely showing you the sum of all the unspent outputs for an address or the entire wallet. The Bitcoin network works on the concept of inputs and outputs The Bitcoin network doesn't consider the \"value\" an address when validating txs. When validating a tx, outputs are considered as independent entities. Spending one output for a particular address has no effect on the other outputs (if any) for that address. A transaction is valid (among other things)if all the inputs refer to valid unspent outputs of prior transactions (can't spend coins twice), the sum of the outputs is less than or equal to the sum of the inputs (can't counterfeit new coins), and the inputs are signed by the correct private key (only the \"owner\" of the private key can spend the coins). Examples To avoid a lot of excess detail we will look at a simplified version of the transactions used in the Bitcoin network. Say an previous transaction exists (tx hash 1234567890). In this transaction you have an input which referenced an unspent output of a previous transaction worth 100 BTC. You send 50 BTC to one address, 10 BTC to another address, and the change (40 BTC) is sent to a new address in your wallet. Remember we can't spend part of an unspent output so the change is necessary because we are spending a 100 BTC input but only need to \"send\" 60 BTC. The simplified pseudo-transaction may look something like this. In[0] Out[0] Bitcoin address=1ABC... Value=50 BTC Out[1] Bitcoin address=1DEF... Value=10 BTC Out[2] Bitcoin address=1XYZ... Value=40 BTC The tx has 1 input, 3 outputs, all in/out indexes are zero based, and the value of the outputs is equal to the value of the input. If the output(s) are less than the input(s) then the difference is the fee paid to the miner. If the outputs are more than the input(s) then the tx is invalid. Now since the \"change\" address is 1XYZ is another address in our wallet we can use it in a new transactions. We will pay a merchant 1 BTC and give the miner a fee of 0.01 for fast inclusion in a block. The change will be sent to yet another new address in the wallet (1ZZZ....). The resulting transaction may look like this: In[0] Tx hash=1234567890 OutputIndex=2 Out[0] Bitcoin Address=1HIJ... Value=1 BTC Out[1] Bitcoin Address=1ZZZ... Value=38.99 BTC The input refers to the 3rd (0 base array) output of the tx above. Looking up the output index 2 of tx 123456789 we can see the value is 40.00 BTC. The sum of the outputs are 39.99 meaning 0.01 BTC will be collected by the miner of the block. Real txs deviate from the simplified version shown above Note this isn't really important unless you want to dive deeper into the workings of the protocol. The output of Bitcoin transactions are actually scripts instead of static addresses and values shown above. Functionally for most outputs they work the same, although to save space the hash of the public key not the address is used in the output. All blocks have a required tx called the coinbase which has no input because the output is the block subsidy and the fees paid to miners. All values in the Bitcoin network are integers in Satoshis (1E-8 BTC) so technically all the numbers in this post would be multiplied by 1E8.",
      "A single Bitcoin transaction can have many outputs. The vout field lets you specify which output you want to spend. Look at this transaction . Suppose you have the 1EZ5 key, but not the 199N key. You need to clarify to the Bitcoin network which output you want to spend."
    ]
  },
  {
    "question": "What's the minimum transaction with bitcoin?What's the minimum transaction with bitcoin - local wallet to local wallet. Can I send for example $20 in bitcoins to another person?",
    "answers": [
      "You can send any number of bitcoins to anyone, even 1 satoshi (see exceptions below), which is 0.00000001 BTC (about 0.00001031 USD) However for such small amounts you may not want to include a transaction fee. There is no minimum transaction fee. However if you send a transaction without any fee you can expect a significant delay in it getting into the blockchain and therefore getting it confirmed. I have tried this recently and it took around 18 hours to get the first confirmation for my transaction. Others have mentioned even higher delays (up to 2 days) in some cases. It is currently the norm to include a fee of 0.0001 to 0.0005 (approximately 10 to 50 US cents at current exchange rates), resulting in a fairly speedy entry into the blockchain (meaning on average 10 to 20 minutes wait for the first confirmation). Please note it doesn't make a difference if the transaction happens on the same LAN or even between 2 of your own addresses in the same wallet. If it needs to go on the blockchain the fee should be included unless you are prepared to wait. So in practice, the smallest amount you want to send is one that makes sense taking into account that fee. In some circumstances, some bitcoin clients will not even allow you to send a transaction without a fee. This is when your transaction size (in bytes, not the BTC amount being transferred) is over a certain limit. In those cases the client will notify you and ask you to confirm the sending of the fee or cancel the transaction. You can bypass this limit with other clients, but for the same reasons explained above is not something I would recommend. Finally, to take your example of $20 USD, at current BTC/USD exchange rate of $1034.52 you would simply send 0.01933264 BTC + 0.0001 fee. Exceptions : As @CoinEnablers mentioned in the comments below, in order to fight transaction spam, some measures have been recently introduced to limit very small transactions (so called \"dust\" transactions). As far as I'm aware these are not changes to the protocol, but simply new default configurations on both clients and miners' software, that makes it fairly hard to get very small amounts accepted. Currently I believe the minimum value accepted by default is set at 5460 satoshi.",
      "Currently, as of Bitcoin Core 0.14.1 the minimum for outputs is: 5460 Satoshi 54.6 μBTC 0.0546 mBTC 0.00005460 BTC 5460/100000000 BTC"
    ]
  },
  {
    "question": "How does proof-of-stake \"mining\" work?I know and understand the concept of proof-of-stake. Instead of requiring users to do a certain amount of power-intensive hashing \"work\", it requires you to own a certain stake of the currency in order for you to mine new coins. But how does the actual mining process work? In PoW mining, people \"find\" blocks by generating a hash that fulfills a certain condition. How can one mine a PoS block? Is a miner required? Or does just anyone holding coins get their share after a certain amount of time? In Peercoin specifically, is PoW and PoS mining done independently or do they interfere or influence one another?",
    "answers": [
      "In Nextcoin, proof of stake is used. So the \"mining\" process there is just about holding coins and leaving your computer on. It doesn't involve powerful CPUs. Each block (every 60 seconds), a random Nextcoin is selected to be the next \"miner\". There are 1 billion coins so the odds of a single wallet being selected is the number of Nxt in that wallet divided by 1 billion. (Also, it's possible to calculate and agree on who that node is so the transactions need only be sent to that particular wallet.) If a node with the selected wallet is running, it will collect the transactions, make a block, and send it to the rest of the network and collect the fees. If the computer is turned off, however, then the entire network will have to select a different nextcoin to make the transaction. This time, the unresponsive wallet will be ignored. The network would suffer in that the time to make a block is decreased, but the thought is that people wouldn't leave their computers off if they have a lot of NXT because they're missing out on all the fees that they could have collected. If you only have a few NXT, you can leave your computer off: You probably wouldn't have collected much fees anyway. But, your odds of being selected were low so it probably won't decrease transaction times much.",
      "For Peercoin specifically, PoW and PoS blocks are independent. Just as you're betting your consumed electricity and CPU-time vs. the possible PoW-blok's reward, in the PoS blocks you're betting your coin-age: the amount oF PPC you own multiplied by the number of days they've sitted idly at your wallet. It must be a minimum of 30 and a maximum of 90 days for your coins to start generating tickets for the PoS raffle. Should your ticket win, you earn 1% interest and lose all your coin-age, so your coins are, from the network POV, as though you had just received them. I.e. you'll need to wait another 30 days for them to be able to pay you interest again. Over time, though, you're just supposed to earn about 1% annually. Since code for PoS and PoW are independent of each other and the concept of PoS so new, there have been a couple bugs to be fixed plus a kind of attack was found that allowed users to generate a lot of PoS raffle-tickets for \"free\" - fortunately Sunny King has been able to fix such problems quickly."
    ]
  },
  {
    "question": "Has there ever been a successful double spend attack on the Bitcoin network? If not, is it really necessary to wait for confirmations?There is a lot of concern about waiting for confirmations to avoid a double spend attack, but has there ever actually been a double spend attack? It seems to be that there are two types of double spend attack. One is perpetrated without a significant fraction of the network's total mining power. In order to successfully perpetrate this the attacker must send both transactions nearly simultaneously. If there is a significant delay between the legitimate transaction and the double spend then almost every miner will receive the legitimate transaction before the double spend. The miners will reject the double spend, and the legitimate transaction will be almost guaranteed to be included in the next block. Thus to successfully perpetrate this kind of double spend, the attacker must send out both transactions simultaneously so that half the network is working on one and half the network is working on the other. However if they do this, then it should be easy for the payee to immediately detect and thus the payee can reject the payment within seconds. Thus a double spend attack without a substantial fraction of the network power would not seem to be a problem--it is easily and immediately detected (or it will fail). Thus, the only kind of double spend that is likely to succeed is one where the attacker controls a substantial fraction of the network power and can catch up from an initial handicap in block creation. However, until such a double spend has been demonstrated it implies that no malicious entity has achieved control over a substantial fraction of the networks computing power. Thus, if a double spend attack has never been perpetrated, everyday users transferring small amounts of bitcoins can be very confident that they will not be victims of a double spend attack (what are the chances of being the first?) and forgo waiting for confirmations. (People conducting very large anonymous transactions on the other hand may be among the first people targeted by an double spender who has achieved a substantial fraction of network computing power) Is that analysis correct?",
    "answers": [
      "For what it's worth, MyBitcoin.com claimed that their closure was precipitated by a series of double-spend attacks: Our programmer was under the assumption that one block was good enough to secure a transaction. Two years ago when the software was written, this single confirm myth was a popular belief. User theymos (an administrator of the bitcointalk.org forums) had publicly warned them that accepting transactions after a single confirmation was \"insane.\" However, there is no way to verify whether or not any double-spend attacks have actually taken place because to my knowledge no one is currently scanning for them on the network (doublespent transactions are normally discarded after the event is resolved to the satisfaction of the block-chain). All we can observe publicly are block-chain reorganisations which also naturally occur from time to time when blocks are found near-simultaneously by different miners or pools. Perhaps a statistical argument could estimate how often these should be occurring (we've had 14 in the past month) and argue for the existence of double-spend attempts on that basis, but I've not personally seen such an analysis. Most critically to your question about whether or not to wait for confirmation, however, is the fact that you have missed a possible attack vector, known as a \"Finney Attack\" after Hal Finney who identified it . In a Finney Attack, a miner includes one \"double\" of the two transactions in their own blocks while mining, but does not broadcast it to the network. When they eventually find a block, they purchase something with a conflicting transaction (the second \"double\" in the double-spend attack), and then immediately broadcast their block, which will invalidate the purchasing transaction in the blockchain. If the merchant hasn't waited for confirmation, the attacker would walk away with both the purchased item (hopefully something cashlike) and their original bitcoins. Since this situation and its variants apply largely to merchants who offer 'on-demand' items delivered instantly, your analysis of \"everyday users transferring small amounts of bitcoins\" remains roughly correct. Keep in mind that if accepting 0-confirmation transactions became the norm, the incentive for the \"send them simultaneously\" attack would rise significantly (requiring even one confirmation prevents this in the vast majority of cases). But for the time being, regular users should be more worried about regular old \"you-pay-first\" fraud on non-escrowed transactions, and man-in-the-middle attacks where an interlocutor passes messages between two trusted parties looking to do business, then walks away with the cash while they both yell that the other person is scamming them (this attack has been executed in the wild). tl;dr Merchants and exchanges definitely need to wait for confirmations any time transactions are of significant value and/or in exchange for cashlike goods. Individuals transferring small amounts need to be more worried about other aspects of trust in the exchange, and can protect themselves quite effectively with just a single confirmation.",
      "This question has been asked several times in several different places, and nobody has yet come forward with evidence of a double-spend attack. It is, of course, possible that nobody is bothering with such an attack because everyone waits for confirmations anyway. Your analysis is correct. You can act on fewer confirmations with the same level of reliability if you monitor the network from multiple points -- ideally as close to as many large mining pools as possible. And if someone ever did succeed in causing such an attack, you would have irrefutable proof -- the conflicting transaction. I wonder if mining pools would be willing to provide a web page that lists the transactions they intend to include in the next block (assuming they mined one just then). If a few of the larger pools did this, that would allow you to be much more certain that there was no conflicting transaction on the network. If the two largest pools have your transactions and none of the pools have a conflicting transaction, you can be nearly certain you are safe even with no confirmations."
    ]
  },
  {
    "question": "Are there algorithms that could have been chosen for mining that balance CPU/GPU?The mining algorithm for Bitcoins (and most alternative but similar currencies as well) is purely computation hard, but not decision hard or memory hard. This caused the unexpected effect that GPUs are insanely good at mining and CPUs are so bad at mining that there's almost no point in using them to mine. This has had many effects, including the concentration of mining into specialized hardware. Suppose that I think that's bad and would prefer that commodity CPUs be optimal for mining and that mining on them be practical. Given the requirements of mining, particularly that it work like a lottery and that valid results be quickly verifiable, are there algorithms that could have been chosen that would have resulted in commodity CPUs being the optimal miners? Are there algorithms that require lots of decisions and/or lots of memory that could serve as the mining algorithm on future crypto-currencies that would make CPU mining practical again and give everyone with a high-end CPU a reasonable chance at mining?",
    "answers": [
      "The scrypt key derivation function was explicitly designed to be resistant to hardware optimization, with an explicit trade-off allowed between memory and cpu usage: The scrypt key derivation function ... is designed to be far more secure against hardware brute-force attacks than alternative functions such as PBKDF2 or bcrypt. This makes it better than SHA-256 or bcrypt if the intent is to give more of an advantage to CPUs. Another option would be to include the same sort of variety of primitives that are provided for general purpose CPUs, e.g. a combination of floating point operations, access to large memories (perhaps including something that would use a large random access memory like a disk), etc. But as Thilo point out, including some sort of anti-botnet feature might also be needed. A CAPTCHA might also make it rather unpopular, but some sort of work load that would indeed be noticed by a regular computer user might make it hard to hide botnet activity.",
      "I suggest bcrypt . It is not a cryptographic hash function per se, but it could replace SHA-256 and add some memory constraints that would make its implementation harder on GPUs. Bcrypt uses blowfish to encrypt a string with a key derived from a password chosen by the user. So given a string and a target, finding a password that encrypts the string below the target works exactly like the Bitcoin lottery. As for the memory constraints, it is possible to implement bcrypt on a GPU, but it is much harder (probably impossible) to get the same kind of performance improvements we see with SHA. Here is an excerpt from a post on crypto stackexchange about implementing bcrypt with cuda: Now bcrypt is a variant of the Blowfish key scheduling, which is defined over a table (a few kilobytes) which is constantly accessed and modified throughout the algorithm. Due to the size of the table, each core will have to store it in the GPU main RAM, and they will compete for usage of the memory bus. So bcrypt will run -- but not with full parallelism. At any time, most cores will be stalled, waiting for the memory bus to become free."
    ]
  },
  {
    "question": "How are public & private keys in an address created?I understand the high level concept I am more interested specific details. How is a private key generated. How exactly is public key generated, how is address generated from public key.",
    "answers": [
      "As is normal when doing Elliptic Curve encryption, a private key is simply a random number. In the case of secp256k1, the elliptic curve used by Bitcoin, it has to be a number between 1 and 115792089237316195423570985008687907852837564279074904382605163141518161494336 (or in hexadecimal, between 0x1 and 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140 ). This private key is converted to a public key by performing an EC point multiplication with the curve's base point. The result is an (x,y) coordinate pair, which constitutes the public key. Finally, RIPEMD160(SHA256(pubkey)) , where pubkey is a serialization of those coordinates, is computed, and encoded in base58, together with a checksum. This becomes the address.",
      "The public and private keys in a Bitcoin address are a normal ECDSA key pair. I haven't poked through this particular bit of Bitcoin's own code but the offshoot products I've had a chance to work with typically use the Bouncy Castle crypto library. Bouncy Castle also has an excellent introduction/tutorial on how to use their library. Their examples are in Java but it's fairly simple and should be easily ported to other languages. There is also an excellent pre-written library for JavaScript key generation available from Tom Wu under the BSD license."
    ]
  },
  {
    "question": "How can I combine all the tiny amounts I've received to minimise transaction fees, and do I need to?Important parts in bold, for those who don't want to read the detail! I've received lots of tiny transactions, in amounts sometimes as low as 0.000003BTC. Even though I've also received (relatively) larger amounts, I'm worried that when I want to spend my bitcoins the transaction fees may be very high thanks to the large number of \"input\" transactions needed to make up the output transaction. As I understand it, the network has an algorithm for determining minimum transaction fees, and the relationship between number of inputs and required transaction fee is non-linear. This means there is likely some optimum way to combine my inputs. This has already been discussed here and here , but neither question asks how it can be done, and how bad the consequences can be. It might be best to somehow include as many tiny inputs with a larger input each time I spend a moderate amount, or perhaps it would be better to somehow combine all the tiny inputs in individual batches of some optimum size and send them to myself to prevent future problems. If I were to combine the tiny amounts, I'd be happy to wait for the newly combined bitcoins to age, so additional fees which would be required by spending young bitcoins won't be a problem. In most, but not all, cases, my tiny amounts have been received to a dedicated tony-amount address. For the sake of the question, let's assume I've received 1000 tiny transactions of 0.001BTC each, and another 100 transactions of 0.1BTC each, all in the same wallet. This would give a total balance of 11BTC. Assume all amounts were received 6 months ago. If I wanted to spend the entire 11BTC at once (with 1100 transaction inputs), how high might the fee be? If I only spent 1BTC at a time, how high might the fee be? How can I actually combine the tiny amounts without affecting the larger ones? I'm running the standard (Satoshi) client, but other clients could be an option.",
    "answers": [
      "I have not actually done this, but here is how I understand it. With many tiny amounts, you probably want to consolidate them because the fees for transactions with lots of inputs will be high. Now you ask, by consolidating, won't I just be paying the fees in advance? The answer is that by planning ahead and consolidating them, you can use the low-fee mining pool Eligius to do it. To estimate the cost of the transaction, I'm going to use only the transaction size (for large transactions, the fee is dominated by or entirely consists of the cost per KB). This is based on the number of inputs and outputs. If all your balances are the same (0.01 BTC), then it doesn't matter how much you spend at at a time, the fee grows linearly with the total BTC amount. Assuming 180 bytes per input, 1000 inputs comes to 175KB, which I'm going to round up to 200KB for a safety margin. With the official client, at the default 0.01 BTC / KB fee [1], that would cost 2 BTC. Eligius will mine transactions for a fee of 0.2 TBC (0.00008192 BTC) per KB [2]. So Eligius's fee would be 0.016384 BTC. Might as well round that up to 0.02 BTC or higher just to be sure. If your coins are old enough (say, 3 months for 10 BTC and a 200KB transaction size) [3], then the official client might not enforce the minimum fee on your transaction. Otherwise you may need to use a modified client that doesn't enforce a minimum fee. In any case you will need to point your client to Lightfoot Hosting's free transaction relay, which will relay any transaction to the network [2], so it can be picked up by Eligius. It may take longer than usual, but Eligius should eventually mine it. As for combining the \"dust\" while leaving larger balances alone -- you would have to find a client that allows you to choose the inputs to your transaction. I don't know which clients can do that. [1] https://en.bitcoin.it/wiki/Transaction_fees (The fee calculations on this page are as of client 0.3, so they may be outdated.) [2] https://en.bitcoin.it/wiki/Free_transaction_relay_policy [3] Wiki link [1] above says that transactions with priority over 57,600,000 aren't subject to the minimum fee calculation. If this is true, then 10 BTC with an average age of 3 months in a 200KB transaction would have a priority of (1000000000 * 144 * 90) / (200 * 1024) = 63,281,250",
      "It is not directly answer for what the question asked but I wanted to give a tip for reducing bitcoin sending fees. Electrum allows to send bitcoin by selecting the inputs separately. Edit: Electrum offers \"Coins\" tab which list all the inputs and their amounts separately. So, when I will send bitcoin, I try to select and spend minimum number of inputs for the transaction."
    ]
  },
  {
    "question": "What does the US government do with seized coins?It was reported today that the US government shut down the web site Silk Road, where people bought and sold things (allegedly including illegal drugs) using Bitcoins. The operator was arrested, and BTC 26000 was seized. (Source: New York Times ). A few months ago, it was also reported that the US Drug Enforcement Agency seized BTC 11.02 from a person suspected of buying or selling illegal drugs. Is anything known about what the US government (or any other government) does with seized coins? Some possibilities: Sell them on an exchange for USD, and turn the proceeds over to the Treasury Sell them at public auction, as is commonly done with other seized property Use them in future sting operations Do not return them to circulation, but hold them indefinitely Destroy them by transferring them to an address with no private key",
    "answers": [
      "Property seized is held until a conviction, then sold at auction. If there is no conviction, property may or may not be returned to the rightful owner.",
      "The bitcoins will be sold, but they haven't said precisely how that will happen. Since there is no bitcoin exchange that is properly legally licensed in the US, they will likely auction them off directly, like seized property. The bitcoins, if you're interested, are sitting in two very large wallets: one with ~144K bitcoins (~US$117.6M right now) and another with ~30K bitcoins (~US$24M), all siezed from Silk Road. The above is based on the news sources Fox News , Forbes , and Wired . What follows is my own opinion. This approach makes sense, since bitcoins aren't inherently illegal (thus only useful in sting operations or to be destroyed, like seized drugs), and aren't US cash (and thus sensible to directly deposit in the Treasury). Like all other valuable property, the best way for the government to liquidate them is at auction. When this sale happens, the price of bitcoin will likely go down, but will probably be lost in the noise of trading. (Edited. At first I said that it'd be driven down fairly drastically.) Update (2014-06-13): The smaller chunk of bitcoins, nearly 30K bitcoins (now ~US$18M) seized from Silk Road (including all of the little transactions people have given to it since then) now have an auction page set up on the U.S. Marshals Service website: they'll be sold in blocks of 3,000 bitcoins (less for the final block). The actual bidding will occur on June 27th, the fiat money will be wired by July 1st, and I'd expect the coins to be transferred via Bitcoin transactions shortly after. See Forbes for a news source talking about this."
    ]
  },
  {
    "question": "Solo mining just for luck, realistic?Just turned my attention to mining and the concepts are quite new to me. First of let me be clear: I realize that my hardware setup is far from ideal for mining. This is also the reason why I do not want to pool, I would simply provide a too small a share. I will be CPU mining at first, ASIC later on. I would however like to test my luck. Mostly just for fun, I'm completely fine with the idea of never actually solving a block. I see it more as a lottery. I just want to confirm my idea so that I am not missing something: Do I have a chance of solving a block? If a block is solved every 10 minutes, and the difficulty goes up continously. Do I even have the time to attempt a solution? I understand that the current work has to be abandoned when a block has been solved, rigth? Is there, for example, a lag here that yields my efforts useless? What are the odds? Are the actually the % of my speed vs the network's?",
    "answers": [
      "Check this page: How soon might I expect to generate a block? So with the current difficulty 510,929,738 , and a 1Ghash/s mining rig (faster than your CPU) you'd do this math: 510929738 * Math.pow(2,32) / Math.pow(10,9) / 60 / 60 / 24 / 365 So to find a block at this difficulty with a 1Ghash mining rig it would take you about 69 years on average. Good Luck! PS: Math.pow(2, 32) is simply the JavaScript version of 2^32",
      "As long as you're in good communication with the network and have a hashrate measured in something better than minutes per hash, yes, you technically do have a chance of successfully mining a block, even if your hashrate is tiny compared to the whole network. Then the question is, what are your chances and should you do it? I think an analogy with a lottery is apt. In one week, a lottery might cost you $2 (for one ticket) and give you a 1 in 175 million chance to win $100 million (ignoring smaller prizes, splitting prizes, etc.; complicates things too much). This gives it a return on investment (ROI) of about 29% , so we'll treat this as our baseline: if it's lower than this, it's worse than the lottery and you shouldn't \"play\". If you buy a $34.52, 5 GH/s ASIC miner that uses 2.5W of power, you might spend about $0.06 in a week to have a 1 in 13,889 chance to win $11,349. Not counting the upfront investment, this is a 1,361% ROI, so it's worth it. If you factor in the cost of the device (split over a year) and a profitability decline (since the rest of the network will be speeding up), I think you're still looking at an ~80% ROI. In one week of CPU mining (assuming 20 MH/s at 70 W), you might spend $1.75 in power to have a 1 in 3,472,222 chance to win $11,349. This is a 0.18% ROI, so CPU mining really makes no sense, even as a lottery (it'd be better to just buy a lottery ticket). (my calculations are at http://pastebin.com/ERJHshFG )"
    ]
  },
  {
    "question": "What are the limits of m and n in m-of-n multisig addresses?This method describes how to create a 2-of-3 multisig. I heard that there is an inherent limit with the number of multisig parts, limiting them to 3. Does the standard method described above of generating and spending multisig addresses work with more than 3 parts? What is the limit? How to work around that and create/spend larger multisigs using bitcoind (practical 'how to' would be appreciated)",
    "answers": [
      "We need to distinguish the limitations for validity and standardness . The first is determined by the consensus rules (which cannot change without a hard fork). The second ones are determined by local relay and mining policies implemented in the reference client, and can change from version to version. In addition, we need to distinguish raw multisig (a simple OP_CHECKMULTISIG based script), and P2SH multisig (where the OP_CHECKMULTISIG script is only revealed upon spending). Finally, because scripts include public keys, their sizes depend on their lengths. Both compressed (33 bytes) and uncompressed (65 bytes) keys exist, depending on which version of a wallet was used to generate them. Raw multisig Every m-of-n combination is valid (up to n=20), but standardness rules only allow up to n=3. This limitation is enforced when sending (i.e., sending to a 2-of-4 multisig will not be considered standard). P2SH multisig validity rules require that the P2SH redeem script is at most 520 bytes. As the redeem script is [m pubkey1 pubkey2 ... n OP_CHECKMULTISIG], it follows that the length of all public keys together plus the number of public keys must not be over 517. For compressed public keys, this means up to n=15 For uncompressed ones, up to n=7. For standardness , it depends on the version. Up to v0.9.*, the reference client required the total spending script to be at most 500 bytes. For compressed keys, this means m*73 + n*34 <= 496 (up to 1-of-12, 2-of-10, 3-of-8 or 4-of-6). For uncompressed keys, this means m*73 + n*66 <= 496 (up to 1-of-6, 2-of-5, 3-of-4). In 0.10, these standardness rules will likely be relaxed, allowing to go up to the validity limits (15-of-15 for compressed keys, 7-of-7 for uncompressed keys). Also, for P2SH, standardness and validity restrictions are only applied when spending (as the spending script is only revealed at that time). This may mean that sending your coins to a P2SH script may make them irrecoverably lost (especially when violating a validity rule).",
      "from 0-of-0 upto 20-of-20 https://blockchain.info/tx/970b435253b69cde8207b3245d7723bb24861fd7ab3cfe361f45ae8de085ac52 is 0-of-0 p2sh redeemption https://blockchain.info/tx/da738e29f64e90ae46dcc3e6b4154041d6324abbe7919e722d486a4a3148b7dc if 20-of-20 bare multisig redeemption https://blockchain.info/tx/552026dade1c9385e4693a4e82f07080d8d1950fc822346f95a0dc1e0a833465 is 15-of-15 p2sh redeemption"
    ]
  },
  {
    "question": "How are paths found in Lightning Network?I understand now how multihop payments can work in LN , but how do we discover payment paths in Lightning Network in the first place? Obviously you'd need to take into account the available capacity of the route, and you'd want to discover the cheapest path. There shouldn't be a payment channel directory, so would it rely on a peer-based search?",
    "answers": [
      "Note: This answer was written in Spring 2016 and has since been overtaken by an actual spec and multiple implementations. I'm hoping to update this answer shortly. Summarizing mostly from r/bitcoin: How are paths found in Lightning Network? , the currently suggested routing would be similar to the Border Gateway Protocol . At intervals, the following process is initiated: A beacon node B is selected via a pseudo-random process. Neighbors of B broadcast their shortest route to B to their neighbors. The neighbors of neighbors of B now become aware of a route to B and in turn broadcast their shortest route to B . This cascades through the network until every reachable node has broadcasted their shortest route to the beacon node B . Whenever a node becomes aware of a new shorter route, it broadcasts this updated shortest route as well. After a short wait, start from top with a new beacon node B1 . Nodes remember their shortest routes to a number of previously selected beacon node. Now, Alice wants to send 0.3BTC to Bob. Alice has shortest routes to B , B1 , and B2 . Bob just came online and only knows B2 . They add together their respective paths to B2 and thus find a path: Alice → N1 → N2 → B2 ← N3 ← Bob If they have multiple common beacons, they can also compare different paths, and check whether any earlier nodes in their routes match. If they instead had found: Alice → N1 → N2 → B2 ← N2 ← Bob They could shorten the route to: Alice → N1 → N2 ← Bob Altogether, \"shortest\" would be some combination of reachable, sufficient liquidity, lowest fee, fewest hops, and most reliable . As Hash Time Lock Contracts are nearly trustless (only potentially locking your money for some time), and operating a routing wallet should have low resource requirements, it seems likely that the payment routing market should achieve a healthy competition, therefore discouraging nodes to lock money by establishing channels just to earn fees from routing. Payment channels between nodes that have some form of regular business relationship seem more likely as there is an immediate benefit. Sources: harda , mmeijeri , mmeijeri .",
      "Everything is described in detailed in the corresponding BOLT specifications: https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md BOLT #7: P2P Node and Channel Discovery This specification describes simple node discovery, channel discovery, and channel update mechanisms that do not rely on a third-party to disseminate the information. Node and channel discovery serve two different purposes: Channel discovery allows the creation and maintenance of a local view of the network's topology, so that a node can discover routes to desired destinations. Node discovery allows nodes to broadcast their ID, host, and port, so that other nodes can open connections and establish payment channels with them. To support channel discovery, peers in the network exchange channel_announcement messages containing information regarding new channels between the two nodes. They can also exchange channel_update messages, which update information about a channel. There can only be one valid channel_announcement for any channel, but at least two channel_update messages are expected. To support node discovery, peers exchange node_announcement messages, which supply additional information about the nodes. There may be multiple node_announcement messages, in order to update the node information."
    ]
  },
  {
    "question": "Why is bitcoin written in C++?What made the core developers choose C++ as the main programming language for implementing bitcoin? Was this because of their personal preference? Or another reason?",
    "answers": [
      "The most important reason is that the original Satoshi codebase was written in C++. A system like Bitcoin has extremely strong requirements about consistency in behaviour: all nodes on the network must accept and reject the exact same blocks, or we risk a fork. The first choice to avoid bugs that risk introducing inconsistency is to not rewrite the code from scratch. Although all programming languages have flaws, and C++ is no exception, there are various reasons that make it an appropriate choice. An easily-overlooked one is that it provides very tight control over memory usage. Many modern languages (especially those that rely on garbage collection) make it hard if not impossible to reason about tight bounds of memory usage. Since Bitcoin Core is a security-critical application that is directly exposed to the Internet, it is nontrivial to guarantee that there is no way to trigger it to allocate large amounts of memory, thrashing the machine's swap space, or worse, killing the process. This is in addition to a good balance between high-level where desired but also many avenues for performance optimization. Performance may be more important than is immediately obvious, as the convergence of the network relies on quick validation and propagation of blocks. If blocks take too long to validate compared to their creation frequency, economic factors start to unfairly advantage larger/faster miners (see the Selfish Mining attack, for example). Under extreme conditions, if blocks would take ~minutes to validate, the network may fail to converge at all, as nodes simply don't hear about blocks in time anymore.",
      "I gave a keynote address at cppcon 2016 about almost this exact issue. There are a variety of reasons why C++ is an excellent language choice for blockchain applications like Bitcoin. Blockchain applications have a large attack surface. They're meant to interoperate with a large number of untrusted endpoints while still providing reliable service to local clients. This requires keeping tight control over resources like memory and CPU usage. Modern CPUs have lots of cores. Some parts of blockchain applications parallelize perfectly (like checking digital signatures) while some parts don't parallelize at all (like executing transactions in order). Modern C++ has a very good mix of effective inter-thread communication and optimization of single-thread performance. C++ doesn't have a run time that stops the world or manages memory, giving your application consistent control over this behavior. Move semantics allow you to get objects that behave like values ( a=b; a+=1; does not change b ) but perform like references (deep copies are avoided except where needed). Smart pointers allow you to avoid the costs of GC without the tedium of manual memory management. Design patterns like RAII makes code easier to maintain. Template metaprogramming facilitates independence between APIs and implementations. C++'s inheritance scheme makes the design of complex type hierarchies easier. The language is both mature and maintained. The compiler technology is extremely solid, yet new features are still being added. And the new features are aimed at solving real issues. Debuggers and analytical tools of all kinds are available for everything from performance profiling to automatic detection of issues of all kinds."
    ]
  },
  {
    "question": "What is P2PK, P2PKH, P2SH, P2WPKH - ELI5Explain like I'm 5 years old and my other half of the brain is surgically removed :) I don't want to put a lot of stress on my brain Also what is the difference between BTC held in P2SH and Unspent P2SH Output here? https://p2sh.info/dashboard/db/home-dashboard?orgId=1",
    "answers": [
      "P2PKH: \"Pay To Public Key Hash\" This is how transactions are made. You are requiring the sender to supply a valid signature (from the private key) and public key. The transaction output script will use the signature and public key and through some cryptographic functions will check if it matches with the public key hash, if it does, then the funds will be spendable. This method conceals your public key in the form of a hash for extra security. P2PK: \"Pay To Public Key\" This is similar to P2PKH; the difference is that it does not conceal your public key. Anyone using this method to send funds over the P2P network is showing people their public key in the transaction details. P2SH: \"Pay To Script Hash\" The outputs of a transaction are just scripts that, if are executed with specific parameters, will result in a boolean of true or false . If a miner runs the output script with the supplied parameters and results in true , the money will be sent to your desired output. P2SH is used for multi-signature wallets making the output scripts logic that checks for multiple signatures before accepting the transaction. P2SH can also be used to allow anyone, or no one, to spend the funds. If the output script of a P2SH transaction is just 1 for true, then attempting to spend the output without supplying parameters will just result in 1 making the money spendable by anyone who tries. This also applies to scripts that return 0 , making the output spendable by no one. This can also be used for puzzles like this one . P2WPKH: \"Pay To Witness Public Key Hash\" This was a feature of segwit which stands for Segregated Witness. Instead of using scriptSig parameters to check the transaction validity, there is a new part of the transaction called witness where the validity occurs. Also what is the difference between BTC held in P2SH and Unspent P2SH Output here? This means that out of all the P2SH transactions (transactions that can be spent by anyone with a set of parameters [scriptSig] that results in the execution of scriptPubkey with true ), the ones with unspent outputs have not been redeemed. I recommend this video by Andreas Antonopoulos on Bitcoin scripting."
    ]
  },
  {
    "question": "What open source miner applications are there?What open source miner applications are there? Especially to see how the mining process works.",
    "answers": [
      "The official list is on The Wiki and is constantly being modified since new software shows up fairly often, but here's the quick breakdown: Poclbm - Python/OpenCL GPU miner (GUI) DiabloMiner - Java/OpenCL GPU miner (MAC OS X GUI) RPC Miner - remote RPC miner (MAC OS X GUI) Phoenix miner - miner Cpu Miner - miner Ufasoft miner - miner Pyminer - Python miner, reference implementation Remote miner - mining pool software Open Source FGPA Bitcoin Miner - a miner that makes use of an FPGA Board Poclbm and Phoenix are probably the most popular (links go to the sources) though that's based more on my opinion than any facts or studies. In either case, both should shed some light on the mining process.",
      "jzgarzik wrote a very basic miner in Python. It is slow on purpose, because it shows how a simple miner works (and the mining process). It can also be reused as boilerplate code (the getwork JSON-RPC command). https://github.com/jgarzik/pyminer/blob/master/pyminer.py"
    ]
  },
  {
    "question": "Can bitcoins be \"sold short\"? Or are there \"put\" options?Borrowing an asset and \"selling it short\" facilitates finding the appropriate price for the asset, allowing people to bet that the asset is overpriced (e.g. in a \"bubble\"). Can bitcoins be sold short? Where and how? Update (from Serith's answer): how about put options , which are similar?",
    "answers": [
      "Not only will Bitcoins soon be able to be sold short through several exchanges, but once that service is available, Bitcoin banks that pay interest will be possible. A Bitcoin bank could pay interest on Bitcoin deposits by converting the Bitcoins into the least inflationary national currency available, investing those funds in loans or businesses, and using the profits to buy back more Bitcoins later to pay back depositors. However, this plan has one flaw -- what if the price of Bitcoins goes way up, beyond the interest you can collect. You would then take a loss when you purchased back Bitcoins to pay back your depositors. Normally, you would offset this risk by holding Bitcoins. But that would defeat the entire point of investing them. So you need some way to make money and risk money as if you were holding Bitcoins without actually holding any bitcoins. How can you do that? And the answer is, you offset the risk that Bitcoins will go up in value by selling shorts. Selling shorts is like holding Bitcoins without having to actually hold them, allowing you to make money if they go up and lose money if they go down just like someone holding Bitcoins would. If Bitcoins go down, you lose on the shorts but make it up by making extra profits when you buy back Bitcoins to pay depositors. If Bitcoins go up, you lose when you buy back Bitcoins, but make it up on the shorts. With the right combination of shorts, currencies, and investments, this should make the risk associated with interest-bearing bank accounts denominated in Bitcoins no greater than the risk with other currencies. (And if you sell the shorts directly to investors, you can make a profit on them as well, taking the commissions.) It is entirely possible that this is part of the reason the exchanges are considering selling shorts. Not only would they pocket the commissions, but they could safely convert a fraction of the many, many Bitcoins they're holding into interest-bearing accounts denominated in national currencies, pocketing the interest.",
      "Looks like CampBX will have it coming as well, see their FAQ for more info."
    ]
  },
  {
    "question": "How can one download the bitcoin client securely?What is the correct procedure to download the official bitcoin client, and validate it was signed by the developers, and not infected with any malware by a man in the middle?",
    "answers": [
      "Jeff Garzik signs every release with his GPG key (also here ). You can find release announcements (such as this one ) on the SourceForge.net Bitcoin development list . To verify the signature on a release, obtain the key from the link above. Obtain the release announcement from the link above. Obtain the download from any source. Then point GPG at the release annoucement (or the signature block from it, including the BEGIN and END lines). GPG will ask what file you want to verify, pick any of the ones listed in the signature certificate. It will then tell you if the release is identical to the release Jeff Garzik signed.",
      "Intructions for Linux: You need to have the following files: Download the file you want to check: wget -c https://bitcoin.org/bin/bitcoin-core-0.13.2/bitcoin-0.13.2-x86_64-linux-gnu.tar.gz Download the hash sums containing file: wget -c https://bitcoin.org/bin/bitcoin-core-0.13.2/SHA256SUMS.asc Download the release signing key: wget -c https://bitcoin.org/laanwj-releases.asc You check the file as follows: The signing key needs to be imported: gpg --import laanwj-releases.asc Check the hash sum file signature: gpg --verify-files SHA256SUMS.asc laanwj-releases.asc It should say: Good signature from \"Wladimir J. van der Laan. So now we know that the hash sum file is signed with the provided key we trust. Finally, check the file of interest: gpg --verify-files bitcoin-0.12.1-linux64.tar.gz SHA256SUMS.asc It should say: Good signature from \"Wladimir J. van der Laan (Bitcoin Core binary release signing key) \" So now we know that the tarred file is signed with the provided key we trust. Check that the hash sum matches: sha256sum --ignore-missing -c SHA256SUMS.asc It should say: bitcoin-0.13.2-x86_64-linux-gnu.tar.gz: OK"
    ]
  },
  {
    "question": "Can I use Bitcoin mining as a data furnace to heat my home?One of the waste products from Bitcoin mining is the heat that is given off by the GPUs. On cold days could this excess heat be used to warm a home, essentially creating a data furnace? When it gets warmer then the rig can be optionally shut down. As I understand it, the income generated from mining bitcoins at least pays for the electricity so long as you have a rig that is capable of meeting the difficulty. This would therefore imply that so long as you have already got a suitable rig lying around the house (e.g. for gaming) then running it up during the day would be useful. If the house also had solar panels then that would also benefit the earning potential. Are there any calculations available to support/refute this?",
    "answers": [
      "Yes, you can use a Bitcoin mining rig to heat your home. Whether or not it's worth doing depends on a number of things, such as: Whether you have a heat pump, or would otherwise install a heat pump (they generally give you 3kW of heat for around 1kW of electricity) Whether of not you have other heating that is more cost effective than electric heating (eg a wood or gas fire) Whether it's convenient to have a mining rig in the location you want heated (you lose efficiency if your heat is produce away from where you want it) The current exchange rate of Bitcoins (and the difficulty of mining them), and how those values change over time for at least the payback period of the mining hardware The price of electricity The noise produced by a mining rig. They tend to be quite noisy, so it may be a disturbance to leave it running overnight Your technical ability to maintain the equipment, and your time available to do so. If it has a problem and you don't have time to fix it, you stop earning mining income. There's no guarantee that mining earnings will pay for the electricity to run them, let alone pay for the cost of the equipment and the labour incurred maintaining it - this is dependent on the demand for Bitcoins, and your costs. There's always a risk that the exchange rate will drop to the point where it's not worth mining at all, or that new technology (eg ASICs ) will make your hardware obsolete before it's paid for itself. Any web-based profitability calculators that exist won't necessarily take into account all the factors above, and none can predict the Bitcoin exchange rate, so their usefulness will be minimal. I recommend just creating a spreadsheet to do the calculations. To include the value of the heat output in your calculations, consider what you would need to otherwise spend to obtain the same heat output, and include that figure as profit on top of the mining profit (but also of course account for the cost of electricity to run the rig). To predict the electricity usage of a particular setup, see this hardware comparison - a carefully built rig can run 4 graphics cards which might output 600-800W (or more) of heat. Using a desk fan (or similar) to keep strong air flow on the rig should reduce the potential of a convective flow of air taking the rig's heat straight up to the ceiling, where it won't be felt in cold weather.",
      "I live in Florida so it's not very cold but when it does dip down I just start mining :D and tuck myself into bed! By the way, most people have to pay for electricity to heat their homes anyway so the fact you get Bitcoins is just an added bonus to the mining-for-heating!"
    ]
  },
  {
    "question": "Are there any studies into the size of the blockchain scaling over time?After watching some of one of the 28c3 talks, It got me thinking about just how scalable Bitcoin really is. With the size of the blockchain currently, given the number of transactions/users, will the size of the blockchain be manageable as Bitcoin adoption increases? As an example (no answers about \"this will never happen\" please), if Bitcoin was as large as a company like VISA, hundreds/thousands of megabytes would have to be transmitted over the network daily and stored in the blockchain. This is not including other things being stored in the blockchain that essentially shouldn't be (Eligius putting prayers in the blockchain for example). This would mean that most casual users would need to use a thin client as storing the blockchain and keeping it up to date would require super fast internet and masses of hard drive space. (imagine Visa's 92 billion transactions per year) Are there any studies into the scalability of the blockchain? Or is the assumption that technology will be so advanced by the time of this ever occurring that it will not be an issue? (which doesn't sound like the greatest conclusion in my opinion) Also, quoting the wiki: At very high transaction rates each block can be over a gigabyte in size. These blocks must be stored somewhere. Whilst for speed it'd be ideal to store the block chain entirely in RAM, for cheapness storing only the hot parts in RAM and the rest on disk is the way to go. A 3 terabyte hard disk costs less than $200 today and will be cheaper still in future, so you'd need one such disk for every 21 days of operation (at 1gb per block). 3 TB every 21 days? 52 TB a year for the blockchain alone? Is that REALLY scalable?",
    "answers": [
      "Satoshi Nakamoto addressed this issue in the original crypto forum thread . Long before the network gets anywhere near as large as that, it would be safe for users to use Simplified Payment Verification (section 8) to check for double spending, which only requires having the chain of block headers, or about 12KB per day. Only people trying to create new coins would need to run network nodes. At first, most users would run network nodes, but as the network grows beyond a certain point, it would be left more and more to specialists with server farms of specialized hardware. A server farm would only need to have one node on the network and the rest of the LAN connects with that one node. The bandwidth might not be as prohibitive as you think. A typical transaction would be about 400 bytes (ECC is nicely compact). Each transaction has to be broadcast twice, so lets say 1KB per transaction. Visa processed 37 billion transactions in FY2008, or an average of 100 million transactions per day. That many transactions would take 100GB of bandwidth, or the size of 12 DVD or 2 HD quality movies, or about $18 worth of bandwidth at current prices. If the network were to get that big, it would take several years, and by then, sending 2 HD movies over the Internet would probably not seem like a big deal.",
      "I don't know of any formal studies into this, but here are a few points to consider: It is generally assumed that in the future not every user will run a full network node. For a \"supernode\" of which a few thousands will exist in the world, the hardware requirements will be bearable - Even if we take the 52TB/year figure at face value and ignore technological advancements, it's a feasible level of storage, and translates to 1.6 MB/s bandwidth (13 Mb/s) which is very reasonable. Spent outputs can be pruned. 52 TB worth of new transactions will allow the pruning of more or less 52TB worth of old transactions, so the overall storage requirement will not grow that quickly. Not all Bitcoin payments will appear as transactions on the blockchain. It's reasonable that the vast majority of them will be between eWallets or utilize more advanced payment protocols, such as the one suggested here . I think the correct way to approach this is by calculating the amortized cost of broadcasting a transaction. Let's say a transaction is 2KB. Creating a transaction means it will need to be stored on all nodes, of which let's say there are 5K (which is enough to be decentralized). That means a total of 10MB stored. Let's say 1TB of storage costs $200, then 10MB costs $0.002. As long as the user paid 0.2 cents transaction cost, he has covered the load his transaction put on the network. Moore's law does exist and is going strong for the foreseeable future. The costs outlined above will most likely be lower in the future. The existing banking system does not benefit from advances in computer technology, the Bitcoin system does. All in all, I don't think there's anything to worry about with regards to scalability."
    ]
  },
  {
    "question": "What is a bid wall?On the bitcointalk forums I hear a lot of talk about \"bid walls\". I have never heard of these in other types of financial markets. It seems that people use them as a way to support the price of a bitcoin. I think i read the forums too much that I have become confused. From what I understand. If someone makes a limit buy below the current market price then that puts it on the bid side of the order book. This will show there is demand for bitcoins. If there is no changes to the supply of bitcoins then the market price will increase. If someone were to put a limit sell order on bitcoins above the current market price, this would add supply of bitcoins to the market. If there are no other changes in demand then the price will decrease. Correct me if I am wrong, but what I read on the bitcoin forums seem to say that if someone puts a limit buy order up large enough then that will keep the price from increasing because there is not enough supply to overcome that \"wall\". Also the converse is said often. That someone puts up a large sell order that supports a higher price since there is not enough demand to take that supply. Am I misunderstanding what the folks on bitcointalk.org are writing on bid walls?",
    "answers": [
      "Traders often view the market depth using real-time graphical tools like btccharts or mtgoxlive . These display the bids and asks as sloping lines moving up and away from the current price. When there is a large bid or large ask, the sloping line goes vertical, resembling a wall. In the example below, from btccharts.com, we can see a bid wall at $3.90, where someone is offering to buy 10,000 bitcoins for $3.90 each: I think you must be misunderstanding the Bitcoin forums. People use all kinds of strategies when trading on the Bitcoin markets. One such strategy (known as spoofing ) is for a trader to put up a large bid wall, making it look like there's a huge demand, with the sole intention of driving the price up by tricking other speculators into buying. Once the price has risen, the trader cancels his large bid wall and sells his bitcoins at an artificially inflated price. If the price starts to fall instead of rise, the bid walls will often be taken down before they are sold into, indicating that perhaps they were never genuine offers to buy in the first place. It's often said that the presence of walls in the orderbook don't really give a clear indication of future price movements in either direction, since they are so easy to create if you have deep enough pockets. Edit: I just noticed this forum thread in which people are discussing \"the wall at 3.9\". That's the one I took the photo of! :)"
    ]
  },
  {
    "question": "How can I generate a vanity Bitcoin address?I once found a program that was capable of creating Bitcoin addresses with specific words in them, but can't find it now. Is there a trusted program, in the Ubuntu repositories for example, that can generate these 'vanity' addresses?",
    "answers": [
      "I guess you mean Vanitygen: https://bitcointalk.org/index.php?topic=25804.0 From that page: Vanitygen is a command-line vanity bitcoin address generator. Vanitygen accepts as input a pattern, or list of patterns to search for, and produces a list of addresses and private keys. Vanitygen's search is probabilistic, and the amount of time required to find a given pattern depends on how complex the pattern is, the speed of your computer, and whether you get lucky.",
      "!WARNING! The vanity address site below was hacked in December, 2013, but the site owner only recently posted an update admitting the hack: https://bitcointalk.org/index.php?topic=118968.0 More than 4 Bitcoins total have been stolen to date, as you can see from Blockchain records (note the number of vanity addresses dumping coins, and you'll see that probability alone is proof, supported by all of the users who lost their BTC): https://blockchain.info/tx/9e95fd443621d3d9fc150f290144401feb1627573c9161beb08edb472069a819 The site owner has taken down the site, but for how long is up in the air. As Stack Exchange keeps long archives, I wanted to make sure this warning stuck here for all to see, but did not want to edit the original response. You can also use https://bitcoinvanity.appspot.com All done for you on their website and nothing to install. Is secure as they never know the private key - see help on site for how this is possible!"
    ]
  },
  {
    "question": "What hash rate can a Raspberry Pi achieve? Can the GPU be used?A Raspberry Pi is a credit card sized $25 (or $45, for the deluxe option) computer, designed for educational use. Has anyone tried running mining software on it? If so, what's the hashrate like? (apparently the CPU is approximately equivalent to a P2 300MHz - I know the hashrate will be very low!) Also, can the GPU be used to mine? What's the hashrate for that, if it's been done. From the FAQ on the above linked site: \" The GPU provides Open GL ES 2.0, hardware-accelerated OpenVG, and 1080p30 H.264 high-profile decode. The GPU is capable of 1Gpixel/s, 1.5Gtexel/s or 24 GFLOPs of general purpose compute and features a bunch of texture filtering and DMA infrastructure. That is, graphics capabilities are roughly equivalent to Xbox 1 level of performance. Overall real world performance is something like a 300MHz Pentium 2, only with much, much swankier graphics. \" Note: The price of $25 or $45 excludes a way of powering it (via MicroUSB), a keyboard, a mouse and likely a USB hub. I think you need to provide an SD card too.",
    "answers": [
      "There is a nice wiki page here: https://en.bitcoin.it/wiki/Mining_hardware_comparison The raspberry pi is listed by its processor in the arm section: ARM1176JZ(F)-S. It gets 0.2 Mhash/s when clocked at 800 MHz.",
      "The Raspberry Pi uses the VideoCore IV series of GPU, which to my understanding are either a single or dual core GPU running at or around 700 MHz. Since the primary benefit of GPU mining is that you can run many parallel processes on the hundreds of cores typically found in most GPUs, the single-core nature of the VideoCore GPU undoes most of that benefit. I don't have exact numbers, nor the necessary knowledge to compute an estimate, but I can tell you that the Folding@Home folks already discussed this and came to the conclusion that an AMD Phenom II X4 940 was almost 5 times as efficient for their needs as utilizing both the CPU and GPU of the Raspberry Pi. Since the needs of Folding@Home are very similar (but not identical) to Bitcoin's, it's probably not a stretch to say that if CPU mining (admittedly with a fairly nice CPU) is 5x more efficient, the Raspberry Pi doesn't look like a strong contender. Of course, until we have solid MH/s and actual at-the-wall wattage numbers it's very difficult to say if, at scale, a cluster of $35 Raspberry Pis could compete with other setups on initial price or power cost. Personally, I'd guess not."
    ]
  },
  {
    "question": "Is there a blockchain.info for testnet?I'm trying to test to see if transactions went through or not and blockchain.info is super helpful for this on the real network.",
    "answers": [
      "Yes, blockchain.info has its own testnet service: https://testnet.blockchain.info/",
      "www.blocktrail.com/tBTC now supports testnet too and has an API for it too (including wallet API)"
    ]
  },
  {
    "question": "Is each Bitcoin address unique?I am wondering whether each bitcoin address is unique. I would assume yes. Then, how is this enforced given the distributed address generation? As I understand it, each time an address is generated, a new key-pair is also generated. On what basis is this done? Since the address is the hash of the public half of the key-pair that would also allow (at least theoretically) multiple public keys to have the same hash.",
    "answers": [
      "TL;DR: There are so many addresses that it is improbable that anyone will ever generate a duplicate of another address in use – as long as random number generators work as they should. 2^160 possible addresses Bitcoin addresses consist of an alphanumerical string with a length of up to 34 characters, excluding the capital \"O\", the capital \"I\" and the lowercase \"l\", as well as the number \"0\". This would allow for 58^34 possible combinations, however, as some of the positions are used for a checksum this is reduced to 2^160 valid addresses . The checksum on the other hand allows to detect mistyped addresses as invalid, so that it is highly unlikely to accidentally input another valid address. Chance of 3.42*10^(-27) for a collision at one trillion addresses Even if we generously assume that at some point there will be one trillion addresses (approx. 160 for each of this planet's population), according to the simple approximation formula for the Birthday attack given on Wikipedia , the chance is 3.42*10^(-27) that any two of those Bitcoin addresses collide . In comparison, the figure of addresses that were ever used to receive bitcoins was just over 13 million in May 2013 . Address space could be augmented Especially as the protocol at any point could be adapted to accept even longer addresses, we can say, yes, it is theoretically possible, but unlikely enough that we can assume for our purposes that it will never happen.* It's impractical to generate addresses for gain To answer your other question: For each address there apparently are 2^96 different private keys whose corresponding public key will map to the same address. So to actually try to pursue Bitcoin theft, it would be much more sensible to just generate random private keys and hope to find one that has a corresponding address with money on it. In all likelihood the power for such calculations would cost more than anyone could earn with such a scheme. *As long as certain random number generators work as well as they should... :)",
      "It is enforced simply having such an enormous number of addresses, that generating one equal to another one is so unlikely it can be considered as good as impossible."
    ]
  },
  {
    "question": "Where do I find the *actual* blockchain size?Okay, my hard drive is a bit cramped, and the Blockchain for my Bitcoin client is completely sucking up my free space. I want to know how much room I need to be prepared to lose. This isn't a duplicate of the other questions - those had answers that were highly impractical - I'm not sure if they dealt more with the theory of the blockchain or what, but the filesizes were way off. For example, right now, http://blockchain.info/charts/blocks-size says that the current blockchain size is 6073 MB, which is complete BS - the cumulative size of ~/.bitcoin/blocks/*.dat is 6970 MB, and it's not even done yet. Basically, what I want is a realistic, down-to-earth estimate of how much hard disk space the blockchain is going to cost me. Not the theory, not the \"data minus overhead\", the actual cost of the .dat files.",
    "answers": [
      "The blockchain sizes of Bitcoin , Litecoin , Dash , Dogecoin , Peercoin and Namecoin are listed here at https://bitinfocharts.com/ (scroll down to Blockchain Size ) As of today (2015-07-12) the sizes are (sorted by market capitalization): Bitcoin Litecoin Dash Dogecoin Peercoin Namecoin 44.73 GB 4.64 GB 1.01 GB 11.41 GB 0.4191 GB 2.64 GB $4,477,078,707 USD $209,054,841 USD $23,217,866 USD $20,686,200 USD $15,897,328 USD $9,888,883 USD Note that Dogecoin, although very new, has a very big chain already, where Peercoin has by far the smallest. Your question On my hard disk the .bitcoin directory uses 45 GiB = 48 GB.",
      "As of July 12th 2017 a full node running on my machine requires 130 GB of disk space: $ du -s ./bitcoin-data 136467234 bitcoin-data I have the txindex option enabled (txindex=1 in bitcoin.conf) so the above includes 11.5 GB of optional transaction index data, this is not enabled by default. The size of just the block data is 116.29 GB and the chain state is 2.33 GB . If you do not have enough free disk space you can run Bitcoin with pruning enabled, this will delete old block files, set prune=550 in bitcoin.conf (550 is the minimal value) and it will automatically prune the block data to stay under 550 MB. This makes the actual size with pruning enabled around 2.86 GB (block data + chain state)."
    ]
  },
  {
    "question": "How does Chaum style e-cash work? (all the Wiki links are broken)I'm trying to learn how Chaum-style ecash worked specifically how: \"the issuer does a blind signature on a serial number\" I tried looking up on Wikipedia but the page is pretty light on the details, and all the pages don't work (even the Wayback machine pages are broken)",
    "answers": [
      "Here's the basic idea of blind signing in Chaumian e-cash: Let's suppose that a central issuer (Chaumian e-cash is centralised) has an account in my name with a value of 10 dollars . In order to \"withdraw\" this money as 1-dollar \"bills\" I begin by generating ten random serial numbers, each long enough that I can be reasonably sure no one else will generate the same numbers. I am going to have the central issuer sign a message saying these are now worth one dollar each , only I don't want the issuer to know which bill is which (otherwise they could just match up outgoing and incoming serial numbers to know who I spent it with, since Chaumian e-cash can only be spent once before it has to be re-issued). So in addition to the serial numbers I also choose secret 'blinding factors' and combine them with my serial numbers. I give these blinded serial numbers to the central issuer, and they sign each one with their 1-dollar key (they have different keys for different denominations) and reduce the amount in my account with them accordingly. They know how many 1-dollar bills they signed, but they don't know what serial numbers were on each bill they signed. Now, the trick with \"blind signing\" comes in. Because of how blind signing works, I can now remove the blinding factor, but I still have a valid signed message which can be verified using the issuer's public key. This gives me a signed one dollar bill with its own serial number that the bank doesn't know (but they do know how many one dollar bills they have signed, because each one can only be un-blinded to a single serial number). Now, to spend the bills to someone else, I simply show them the un-blinded, signed serial number . They must now immediately \"cash in\" this token by going to the central issuer and showing them the signed serial number. The central issuer verifies the signature using their \"1 dollar\" key, records the serial number, and credits the new person's account. From their perspective, this dollar is indistinguishable from any other they have issued in the past . However, if someone else shows up and tries to cash in the same dollar again, they will not honour it because they have already recorded the serial number as spent. You also cannot spend a $1 serial number as a $50 serial number because $50 serial numbers use a different key. More details about e-cash, including an \"offline mode\" that relies on trusted hardware, can be found here . They use a different method of ensuring a $1 bill is not spent as a $50 bill--I don't remember which variant is whose but there are several of them which basically accomplish the same thing in slightly different ways."
    ]
  },
  {
    "question": "When will the last Bitcoin be mined?Estimates have been thrown around a lot recently as to the year in which the last Bitcoin will be mined- where are these estimates coming from? Could someone send me to the relevant code?",
    "answers": [
      "The estimate is 2140 based on the block reward halving frequency of four years. According to math and knowledge that there are 32 halving events , in 2136, the block reward will yield 0.00000168 BTC per day, which is 0.00000042 BTC per block. That's 42 satoshis . It's arguable that there could be one additional halving, to a block reward of 0.00000021 BTC, but that would require a major protocol modification since the number of Bitcoin would then exceed 21 million. Additionally, to go past that, there'd have to be a protocol modification to extend divisibility past eight decimal places. It is far, far to early to worry about either of these, because we're more than a century away from this problem.",
      "Bitcoin's reward schedule is implemented in eras of 210,000 blocks. The block subsidy gets halved with the first block of each new era. The 33rd \"halving\" at block 6,930,000 will reduce the block subsidy limit from 1 satoshi per block to 0 satoshi per block¹ and therefore the last block creating new bitcoins will be block 6,929,999. At block intervals of 10 minutes, 210,000 blocks translate to about 3.99 years, although blocks have been found faster in average in the past. Under the simplifying assumption that the halvings will occur about every four years, the final block that creates new bitcoins would occur approximately in 2140 . You can find a table with the respective calculations here: Bitcoin Reward Schedule Really, the mining reward will get minuscule much earlier already. In 2036 99% of the bitcoins will be in circulation, in 2048 it will be 99.9%. ¹Actually, the limit is 0.58207661 satoshi per block at that point, but since only whole satoshis can be paid out, none may be collected by miners."
    ]
  },
  {
    "question": "Where can I access the original, Satoshi written Bitcoin code?The articles of https://bitcointalk.org/index.php?topic=41718.0 seem to be annotated walkthroughs, and I'd like to see the raw code, as it was originally written in the first release.",
    "answers": [
      "The Bitcoin client has been hosted on GitHub for a while now. It's very close to what Satoshi initially wrote. Here's the first commit dated back to 2009: https://github.com/bitcoin/bitcoin/tree/4405b78d6059e536c36974088a8ed4d9f0f29898 You could also browse all the commits from way back: https://github.com/bitcoin/bitcoin/commits/master?page=151 Some other research points me to the actual first email sent to the cryptography mailing-list by Satoshi where he actually delivered the 0.1 version: http://www.metzdowd.com/pipermail/cryptography/2009-January/014994.html Here's the direct link provided by Satoshi but it doesn't seem to work anymore: http://downloads.sourceforge.net/bitcoin/bitcoin-0.1.0.rar Googling a bit I found this, which is what you're looking for: https://bitcointalk.org/index.php?topic=68121.0",
      "This page contains files for the first three available Bitcoin codebases written by Satoshi Nakamoto. http://satoshi.nakamotoinstitute.org/code/"
    ]
  },
  {
    "question": "Will all 21 million units be completely mined one day?It is written that the supply of Bitcoin units is limited to 21 million and that this limit will approximately have been reached around the year 2030. But is there an actual \"last Bitcoin\" (or \"last Satoshi\" for that matter) that will have been mined one day? Or will mining continue forever after producing smaller and smaller fractions?",
    "answers": [
      "Theoretically yes, but that moment is so far in the future it is likely that some other events such as new currency technology will surpass bitcoins. However, mining will not stop. Mining is the security backbone of bitcoin, and it will continue because it will still be profitable to mine. Miners will be paid fees from existing bitcoins with every transaction instead of a reward of newly created bitcoins.",
      "By 2140, the final bitcoins will be made. After 2140, no more bitcoins will be made, which means it's only trading and buying things wiith bitcoins."
    ]
  },
  {
    "question": "Is there some way to merge two wallets or to import/export addresses?I've got one wallet.dat from my laptop and another on my desktop, each containing various (different) receiving addresses that I use pretty often. I'd like to merge them into a single wallet.dat so I can see all my balances in one place. If there isn't some piece of software that can truly \"merge\" the two, is there some way to at least export an address/keypair from one wallet and then import it into the other?",
    "answers": [
      "Pywallet is a python script that (among a number of other things) can export and import key pairs. It's not as complicated to use as it might sound, some python stuff has to be installed but that's almost automatic and once it is done the tasks can be performed using a web interface. From the linked forum post (updated 8/23/11): Currently you can: Dump your wallet, see your pubkeys, privkeys, their labels, etc Dump your transactions to a json file Import a key/address into your wallet, with a label, or as a reserve key Import a transaction into your wallet Import transactions from a json file Delete addresses from your wallet Delete transactions from your wallet Get info about a privkey, i.e. see address, base58 privkey, hexprivkey, pubkey and hash160, using the network you want Sign and verify string, files, and binary string Read a device to find deleted keys (CLI only) Print the balance of a bitcoin address, read from blockexplorer",
      "A patch for the bitcoin client for this: - http://github.com/bitcoin/bitcoin/pull/220"
    ]
  },
  {
    "question": "How much would it cost to execute a 51% attack?I know that it's commonly said that they're not really in the realm of possibility right now, but how much would it really cost to execute a 51% attack on the network? And are there any organizations out there who might have a goal in mind for which such an attack would be worth it?",
    "answers": [
      "Adding to David's quote of $65,415 per hour here's a quick analysis of non-EC2 attacks (i.e. buy and run ALL the hardware to sustain a 51% attack) Since power efficiency will be HUGE for this scale of an operation, let's use the most power efficient card we can find. This lovely pastebin doc tells us that is the Radeon 5850 at 1.595 MH/W. At present you need 12.42 TH/s to pull off a 51% attack, which would require 51,585 of these cards. Assuming we put four cards to a rig it also requires 12,897 computers to run them all. Assuming the PCs take a scant 200 watts, each rig requires 804 watts of power, 10,365,735 watts in all. Assuming a fairly high efficiency cooling system, we can bump that up to about 14,619,916 watts. Before anyone claims that this alone is impossible, keep in mind it's about 0.7% of the peak output of Hoover Dam . Speaking of Hoover Dam, I'm going to use my local energy rate of 11.28 cents per kW/h (I live in Vegas) to find that it would cost $39,579.04 to run and cool these rigs for a single day. Since these cards cost $192 at the cheapest outlet I could locate, we'd spend $9,904,320 on cards and at if we spent a scant $500 on each rig's other hardware they'd cost us $6,448,120 as well for a total hardware cost of $16,352,440. If we amortize that cost over a year of operation before the parts die or become too obsolete to pull off our attacks any more, we can estimate $44,770.54 per day in hardware costs. Total cost in amortized hardware and electricity to run a 51% attack for one day on the bitcoin network: $84,349.58 - but also recall that our total startup costs were 16.35 million dollars, and all that would buy you is the ability to double-spend for a time, so no it wouldn't really be worth it.",
      "I think this question primarily relates to the integrity of BTC, and withstanding a government mounted attack against it (from what I understand, any currency which could undermine the value of our US dollar is a threat to national security). Take into account another factor or two. DDoS attacks have taken place against several smaller mining pools, which effectively discount any mining they perform. If the largest pooled mining efforts were hit with denial of service attacks for long enough, the difficulty and network strength would drop. Then the network would become particularly vulnerable. It is my belief that the BitCoin client should be coded to disallow connecting to nodes which overpower the last known status of the network. Along with distributing the blockchain, the client should also broadcast a list of possible problem nodes, and possibly some statistics of the state of the network if the client were offline."
    ]
  },
  {
    "question": "What is pool hopping?What is pool hopping and how do pool hoppers affect other miners? Are there ways to prevent it?",
    "answers": [
      "Some mining pools have a reward method for which some times are better to mine than others; normally, miners contribute to the pool equally through good and bad times, and their reward averages out to what is statistically expected. Pool-hopping is the practice of mining in a pool only during the good times, and leaving during the bad times; by so doing, a pool-hopper can get more out of the pool than the value they contribute to it, increasing their rewards at the expense of other miners. Pool-hopping gets its name from the act of constantly hopping into and out of the pool (to either other pools or solo mining). The most well-known form of pool-hopping is with pools using the proportional method, which is among the oldest, simplest, most widely used and most prone to hopping. By all accounts hopping in this context was first discussed in a paper from January 2011 by Nakamoto Ryo; a more accurate analysis was given shortly after in Optimal pool abuse strategy by Raulo; these results were extended in Analysis of Bitcoin Pooled Mining Reward Systems by myself. In the proportional method, a block's reward is distributed between miners in proportion to the number of shares each of them submitted since the previous block; the reward per share is the block reward divided by the number of shares in the round. Because of this, the reward of a share submitted at any given time is affected by the number of shares already submitted since the last block; a share submitted early in the round will have a higher reward on average than a share submitted later. It can be shown that until the number of shares in the round is 43.5% of the difficulty, a submitted share will have higher than normal reward on average; the optimal way to exploit a single proportional pool is to mine in it until this point is reached, hop to a different pool, and return when a block is found. The gain that can be achieved by following this strategy is up to 28.1%, depending on the ratio between the hashrates of hoppers and continuous miners in this pool (the more hoppers, the less they will gain). The gain can be higher if more than one proportional pool is taken advantage of (for example, 51.6% can be achieved with 2 pools). The extra profits of hoppers come at the expense of the continuous miners. The exact loss depends on the ratio between hoppers and continuous miners; when they are equal the loss is about 17.1%, and the theoretical limit when there are only hoppers is 43.5%. Slush's method, which scores shares based on the time they are submitted, was designed to combat pool-hopping, but is only an incomplete solution. SMPPS which strives to converge to the full value of each share in the long run can only be hopped to minimize the time until being paid in full, not to increase the expected reward. Modern methods make sure that the reward per share depends only on the future of the pool, not its past. This way, without being able to divine future random events, any time is as good as any other to mine, so there can never be any gain or loss from hopping (with the exception of block-withholding attacks). The most popular such methods are PPS, PPLNS and DGM. Advanced forms of pool-hopping, possible in some naive reward method implementations, include difficulty retarget hopping, tx fee hopping and hashrate fluctuation hopping.",
      "Pool hopping is a mechanism by which certain miners may exploit the payment mechanisms of pools to dramatically increase personal profits. The original mechanism by which funds were distributed to miners is the simplest and most obvious: Each miner submits \"shares\" of work and when the pool finds a block, the divide the block reward based on the proportion of the shares - if you did 50% of the work you get 50% of the reward, if you did 3% of the work you get 3% of the reward. Simple. Unfortunately this creates an imbalance wherein blocks solved in less than average time are worth more per share than blocks that took average times or longer to solve. This makes proportional pay systems inherently exploitable. To simplify the concept, imagine you're at the world's strangest casino. The only game in the house is rock-paper-scissors and you're playing against the other patrons. If you win the first game after you sit down at a table, they pay you 10 times your bet. The second game pays 9 times, the third pays 8 and so on until eventually you're not even earning your bet back. It seems obvious that the optimal strategy is to hop from table to table taking advantage of the 10x payout rule as many times as possible without every hitting diminishing returns. Pool hopping is much the same. Mathematically it works out that diminishing returns begin when all workers combined have submitted a number of shares approximately equal to 43% of the current difficulty. After this point, your shares aren't worth any more than average and it becomes more profitable to hop to another pool with fewer shares. This strategy produces, on average, about 28% more income for a pool-hopping miner. The effect of pool hopping on the other users of the pool comes from a shift in one factor of mining without a corresponding shift in the other: time vs. hashrate. Without hoppers, the value of shares in a proportional pool differs with time - shares submitted early in a round are worth a great deal more than those submitted later, but as long as hoppers are not present, the value of shares average out to a fair value. While hoppers do not change the average number of shares per block or the number of shares an honest miner submits, they do decrease the duration of the higher-paying portions of a round. With the most profitable portion of the round taking significantly less time to complete than the remainder, a miner submitting shares at a constant rate will have far more shares on average in the less profitable parts of a round than in the most profitable, thereby reducing their overall average share value. The more hoppers are present, the shorter the profitable span becomes and therefore the more dramatic the effect. Preventing pool-hopping is simple: When creating a pool, simply choose an algorithm for funds distribution that has been proven immune or even hostile to hopping - i.e. anything but proportional. When choosing a pool to mine in, one should similarly choose a pool which has chosen a fair payment schema."
    ]
  },
  {
    "question": "What does the term \"Longest chain\" mean?What does the term \"Longest chain\" mean, as there is only one 'right' blockchain exists? How another longer chain would make the 'right' chain invalid?",
    "answers": [
      "Bitcoin's block chain system is really two quite separate systems, and they are easily confused. The first one is the block tree and the second is the active chain . The block tree consists of all valid blocks whose entire ancestry is known, up to the genesis block. The rules for validness include no double spending, valid signatures, no introduction of more currency than allowed, ... These are the network rules, and every full Bitcoin node verifies them. The active chain is one path from genesis block at the top to some leaf node at the bottom of the block tree. Every such path is a valid choice, but nodes are expected to pick the one with the most \"work\" in it they know about (where work is loosely defined as the sum of the difficulties). Relativity and technological constraints prevent us from doing instant communication across the globe, so two nodes can not be expected to pick the same chain as the active one. This is no problem: the mining mechanism makes sure that the chance two nodes disagree about blocks in the past decreases exponentially as they are older. So no, there is not one \"right chain\", there are many. Nodes choose for themselves, but the system is designed to make sure consensus arises quickly. The rules in practice are this: when a new block arrives, and it extends the previous active chain, we just append it to the active chain. If not, it depends on whether the branch it extends now has more work than the currently active branch. If not, we store the block and stop. If it does have more work, we do a so called \"reorganisation\": deactivating blocks from the old branch, and activating blocks from the new branch.",
      "Imagine that the blockchain is 210000 blocks long and TWO miners both find valid blocks within a few seconds of each other and broadcast them to the network. This is perfectly normal as the Bitcoin network is peer to peer and global. You now have two chains, each of length 210001. Neither of these are longer than each other. Some bitcoind nodes will see the first miner's block and some bitcoind nodes will see the second. Temporarily you have two forks of the blockchain, each of length 210001 blocks long. They are identical for 210000 blocks, but the 210001st is different on the two forks. Sometime later another miner finds another valid block, the 210002nd block, and that will be attached to exactly one of the forks. This chain is now the longest at 210002 blocks and becomes the longest chain. It becomes the \"definitive\" blockchain. (The transactions in the alternate fork don't disappear - they simply get put back into the pool of unconfirmed transactions and miners will put them into a subsequent block)."
    ]
  },
  {
    "question": "What is \"difficulty\" and how it relates to \"target\"?I don't understand what \"difficulty\" means and how it really relates to \"target\". I understand what \"target\" is - it tells the miners, how small the resulting hash should be. (Basically, how many zeroes are there at the beginning, altough not exactly.) But I don't understand what \"difficulty\" is, how it relates to the target and why it's important. I tried to read the article on wiki - https://en.bitcoin.it/wiki/Difficulty - but I don't have a clue what is it trying to say either.",
    "answers": [
      "Difficulty is basically a different representation of the target to make it easier for normal humans to understand it. Difficulty represents how difficult the current target makes it to find a block, relative to how difficult it would be at the highest possible target (highest target=lowest difficulty). The current difficulty of 6,695,826 means that at a given hash rate, it will, on average, take ~6.6 million times as long to find a valid block as it would at a difficulty of 1, or alternatively, it will take, again on average, ~6.6 million times as many hashes to find a valid block. Difficulty is the largest possible target (0x00000000FFFF0000000000000000000000000000000000000000000000000000) divided by the current target (as of right now, 0x00000000000002816E0000000000000000000000000000000000000000000000).",
      "Difficulty is simply the ratio between the max target and the current target. It's easier to speak in terms of difficulty than in terms of the target. The max target is defined as (2^16 - 1) * 2^208 or approximately 2^224. Since there are 2^256 different values a hash can take, a random hash has a chance of about 2^(-32) to be lower than the max target. It follows that if the difficulty is D, the target is (2^224 / D) and it takes on average 2^32 * D hashes to find a block."
    ]
  },
  {
    "question": "What is proof-of-stake?As we know one of the important mechanisms of Bitcoin is proof-of-work. How does the concept of proof-of-stake work? How does it differ from proof-of-work?",
    "answers": [
      "Proof of stake is a proposed alternative to proof of work designed to increase network security. It's not currently implemented in the main chain (and would likely require a hard fork to implement), but alt currency PPCoin features a hybrid proof-of-stake/proof-of-work system of sorts. With proof of work, the likelihood of mining a block is dependent on the work done by the miner, e.g. the number of hashes checked for validity by a CPU, GPU, FPGA, or ASIC. As such, over time, the blocks are split across miners proportionally to their relative hashrates. With proof of stake, blocks are split relative to current wealth, so someone possessing 1% of the bitcoins currently in existence could \"mine\" 1% of the proof of stake blocks. This proposed system has a few (theoretical) benefits relative to proof of work: Reduced long-term transaction fees When transaction fees form the majority of block rewards, with the current proof of work system, miners would be forced to require a \"minimum\" transaction fee if they wish to remain profitable, as they must utilize physical and costly resources (hardware, electricity, internet, etcetera) in order to mine blocks. Proof of stake has no such limitation, as solving blocks would require no physical resources whatsoever (apart from a computer running the Bitcoin software, which is essentially negligible). Decreased likelihood of a 51% attack In the current proof of work system, an attacker need merely obtain over half the current network hashing capacity for a short amount of time to perform a so-called \"51% attack\". With proof of stake, an attacker would need to obtain over half of the bitcoins in existence, a far more expensive and difficult feat. Moreover, performing a 51% attack and likely devaluing Bitcoin significantly wouldn't be all that appealing if you are so heavily vested into it. However, this is debatable. If a single entity could obtain, even temporarily, loans or other borrowed capital comprising over half the network, they could perform a 51% attack with very little input resources, and might well have good incentive to do so. Just as centralized or leasable hashpower dramatically increases the risk of a 51% attack on a proof of work system, centralized or borrowable wealth dramatically increases the risk of a 51% attack on a proof of stake system. Proof of stake was first formally proposed by forum user QuantumMechanic here . Two at least somewhat complete implementation specifications have been released, one by Meni Rosenfeld and one by Cunicula; both are explained in detail on the proof of stake wiki page . Both are hybrid proof-of-stake/proof-of-work implementations, meaning that 51% of the total wealth and 51% of the network hashpower would be required to create and maintain a fork. You can find the (unofficial) forum discussion thread here ."
    ]
  },
  {
    "question": "How useful is a JavaScript miner?I don't have a great understanding of how bitcoin mining works, but how useful would a JavaScript miner be for collecting revenue from visitors? Stupid question, but if I put the user in as part of a mining pool, must their computer actually find a hash in order for me to make revenue? Is this at all practical?",
    "answers": [
      "Javascript has access to OpenGL ES, including shaders, so it has access to programmable parts of the GPU at nearly native speeds. I think that a smart kid might be able to build a fragment shader that does SHA256 hashing, which outputs to the stencil buffer, so that Javascript has a 2-way communication channel with the GPU. So yeah, you could probably use javascript to mine at really nice speeds. Maybe 70% or 80% of what an OpenCL GPU miner does? [Edit] oh look, someone already built a fragment shader that does that [Edit 2] and an actual JS/WebGL application",
      "It would not at all be useful for Bitcoin mining. However, it may be useful for other digital cryptocurrencies, such as Litecoin or PPCoin."
    ]
  },
  {
    "question": "Why is the disappearance of Mt Gox a problem?I'm sorry if this is a stupid question, I'm not a bitcoin user and may lack important information. My understanding was that each bitcoin user has a wallet on his harddrive or wherever, where he stores his bitcoins with the transaction history proving that they are his. So the system is pretty decentralized. Then why is it such a problem that Mt. Gox disappears? Don't the people losing money have it in their own wallets, if so why? Edit to add: In case the question was unclear, I was asking for why people lost money with Mt. Gox - not about the wider ramifications like potentially lost trust in *coin etc.",
    "answers": [
      "To actually try and answer your question, Mt Gox acted as a trusted middleman in btc trading, and thus had to have control over their users money. Let's say dude A has a few btc he wants to sell, and dude B has a few dollars he wants to buy btc for. B doesn't want to pay until A sends him the btc, and A doesn't want to send his btc to B until B pays. Unless they trust each other, they can not do business. By putting money and btc in the hands of a supposedly trustworthy middleman (Mt Gox), A and B can do business. As soon as they agree on the price, the middleman, who has access to both the btc wallet of dude A and the dollar wallet of B, can make sure that both transfers are made, so that each person gets what they agreed on. So essentially, users had dollar accounts and a btc accounts at Mt Gox, and it is from these that things seem to have gone missing. As has been pointed out below, it may be that accounts still show the right balance, but Mt Gox doesn't have that money anymore.",
      "People had bitcoins loaded on Mt.Gox internal trading accounts (trading wallets). This goes both for fiat currency and bitcoins. Bitcoin withdrawals were shut-down for a few weeks now, which created concepts like \"goxbucks\" or \"goxcoins\" as you could not get any Bitcoins out. Now, the Mt.Gox is closed completely, so you cannot get either fiat currency or Bitcoins out at all. People speculate that they will never get their funds back, as MtGox would have lost these assets they manage for their customers."
    ]
  },
  {
    "question": "What are the downsides of proof of stake?I am very skeptical about the security of the proof of stake system. Is it really that secure? Are there no disadvantages?",
    "answers": [
      "Vanilla proof-of-stake doesn't achieve consensus, unfortunately. People staking their coin can vote for both forks of the blockchain, and can even mine effortlessly in secret. In PoW this is impossible, as you are literally wasting energy by mining both sides of a fork. To mitigate this, most modern PoS schemes use a mixture of PoS and PoW to ensure that someone will finally decide the chain. http://www.reddit.com/r/Bitcoin/comments/1oi7su/criticisms_of_proofofstake/ for more discussion.",
      "Proof of stake has been used for many months in Nxt, and has not been broken despite having the third highest market capitalisation, so it does seem to be secure. If it wasn't, someone would have broken it by now. History shows forks rarely persist for more than a block, so it does achieve consensus. In theory, a weakness is that people can vote for both sides of a fork. In practice, that doesn't seem to happen. The gain from doing so would be trivial (there's no block reward in Nxt), and the loss of security substantial, so no-one does it. With Proof of Stake, the people who secure the block-chain the most are also the people who possess the most coins, so they have the most incentive to preserve the integrity of the currency. To put it another way, in Nxt forging is done to secure the block-chain, not to make a profit. One disadvantage is that in pure Proof of Stake, the only way to acquire coins is from someone who already has them. This can lead to issues with the distribution. For example, in Nxt the entire coin supply was initially distributed to 73 \"founders\", and some of those people still own significant fractions of the supply, giving them wealth and influence. That said, none now own as large a fraction as Satoshi owns of Bitcoin. It seems that the distribution problem solves itself over time, as the founders have an interest in spending their wealth to support the coin."
    ]
  },
  {
    "question": "How big is the UTXO database?Is there a query that will return the size of the UTXO database? Specifically, the total number of unspent outputs.",
    "answers": [
      "Bitcoin Core provides the gettxoutsetinfo RPC that has exactly the information you want. Note, it takes that call up to a minute or two to run (and maybe longer as the UTXO set keeps growing). Here's what my node says right now: { \"height\": 763253, \"txouts\": 84683939, \"bogosize\": 6314836827, \"total_amount\": 19207623.41689598, \"transactions\": 50344458, \"disk_size\": 5185703215 } Current and historical data may be found on Statoshi.info's UTXO page ."
    ]
  },
  {
    "question": "What are some good resources for understanding Bitcoin?I've tried to read about what a Bitcoin is, how to mine, etc. I find them to be confusing in that I don't understand the underlying factors driving Bitcoin. Everything I've read seems to assume the reader has some knowledge of Bitcoin (even the wiki). Where should I start?",
    "answers": [
      "I wrote the \"New to Bitcoin? Start here!\" post at bitcointalk.org. OrigamiRobot, I highly recommend that you read that introduction before proceeding on to anything else, especially the original whitepaper, which is incredibly unapproachable for the average person. After you finish it, come here and ask about the things that still confuse you--Bitcoin is very complicated, and it can take a while to wrap your head around it!",
      "Weusecoins.com has an excellent video on the basic premise of bitcoin. Bitcoin is a very complicated platform, and really has two separate entities. There is bitcoin the currency, and bitcoin the currency ledger. The wiki available at bitcoin.it will give you more in depth information if the weusecoins video is too broad."
    ]
  },
  {
    "question": "What is the cheapest Bitcoin -> prepaid VISA/Mastercard service?I am looking for the cheapest Bitcoin to prepaid VISA/Mastercard service for the amount of $5000. I have noticed some with a maximum of $100, and inquired whether it would be possible to increase this cap. It is really not interesting to have to buy 50 cards, and ensure that one empties each of them. $1000 on each card is acceptable though. The card needs to work for purchases in any country.",
    "answers": [
      "That's quite a lot of money to try to load onto a prepaid card and likely not something you'll find easily done. Some options are: http://www.okpay.com/en/services/debit-card/index.html https://www.aurumxchange.com/cards Expect to get their cards program back soon . With OKPay, you can reload using bitcoins, which OKPay will exchange into USDs for you ( the cost of this was just reduced from 5% to 2.5% of transfered amount ). With AurumXChange, you can reload using USDs from Mt. Gox codes. For that amount though you'll probably be best arranging trades with some buyers willing to exchange Moneypak to you. For instance, on the #bitcoin-otc there often times are traders looking for BTC and for larger amounts will go out and buy a MoneyPak to do the trade. You can load a number of different prepaid cards with MoneyPak, up to $1,000 each. See the Prepaid Cards section for the list: https://www.moneypak.com/WhoAccepts.aspx Along the same lines, you might find a trader that would deposit cash at Western Union to reload a Western Union prepaid card.",
      "I would recommend http://www.xmlgold.net . They offer a pretty good system which allows you to buy a prepaid mastercard with bitcoins and load the card with bitcoins. They have low fees."
    ]
  },
  {
    "question": "How many Bitcoin addresses are/have been carrying a balance?Bitcoin addresses can be generated at will, and the theoretical limit to their number is high. Addresses are constantly being generated to receive funds or balance transactions, but they are also being emptied. How many addresses are carrying a balance at the moment, and how has this number developed historically? Would this number be a good proxy for the Bitcoin adoption rate? I'd also be interested in the number of addresses that have been part of transactions during the last x days (i.e. active addresses). The blockchain contains all necessary data to derive the numbers, so maybe there's even a site that lists/graphs them?",
    "answers": [
      "I calculated the answer by starting with Gavin's \"bitcointools\" and modifying it to track account balances. Here's what I found. Each line shows the number of addresses after the specified block was found, at the end of each month. So the 1st line is saying that after block 2543 was found at the end of Jan 2009, there were 2,439 funded addresses, and all 2,569 were 'active' in January 2009. The 'active' number is the number of addresses involved in a transaction in the preceding month, and can be bigger than the number of addresses which remain funded at the end of that month. -block --date-- --total-- ---used--%total- -active---%total---%used- 2543 Jan 2009 2,569 2,439 (94.94%) 2,569 100.00% 105.33% 5923 Feb 2009 5,975 5,646 (94.49%) 3,447 57.69% 61.05% 9389 Mar 2009 9,444 8,868 (93.90%) 3,486 36.91% 39.31% 12831 Apr 2009 12,893 12,125 (94.04%) 3,495 27.11% 28.82% 16214 May 2009 16,288 15,388 (94.47%) 3,424 21.02% 22.25% 18450 Jun 2009 18,528 17,543 (94.68%) 2,267 12.24% 12.92% 20375 Jul 2009 20,456 19,347 (94.58%) 1,973 9.65% 10.20% 21939 Aug 2009 22,021 20,749 (94.22%) 1,639 7.44% 7.90% 24098 Sep 2009 24,180 22,647 (93.66%) 2,212 9.15% 9.77% 26224 Oct 2009 26,311 24,374 (92.64%) 2,231 8.48% 9.15% 28441 Nov 2009 28,533 26,411 (92.56%) 2,262 7.93% 8.56% 32489 Dec 2009 32,611 29,827 (91.46%) 4,420 13.55% 14.82% -block --date-- --total-- ---used--%total- -active---%total---%used- 37493 Jan 2010 37,647 34,342 (91.22%) 5,304 14.09% 15.44% 43096 Feb 2010 43,329 37,274 (86.03%) 7,009 16.18% 18.80% 48297 Mar 2010 48,615 40,329 (82.96%) 6,308 12.98% 15.64% 53875 Apr 2010 57,806 42,688 (73.85%) 10,839 18.75% 25.39% 58815 May 2010 63,368 44,620 (70.41%) 6,762 10.67% 15.15% 63561 Jun 2010 69,540 47,011 (67.60%) 7,056 10.15% 15.01% 71436 Jul 2010 94,992 53,227 (56.03%) 27,957 29.43% 52.52% 77452 Aug 2010 107,172 55,995 (52.25%) 14,162 13.21% 25.29% 82997 Sep 2010 120,562 56,490 (46.86%) 16,883 14.00% 29.89% 88892 Oct 2010 135,952 58,428 (42.98%) 18,921 13.92% 32.38% 94801 Nov 2010 155,639 60,615 (38.95%) 22,307 14.33% 36.80% 100409 Dec 2010 176,326 65,622 (37.22%) 23,377 13.26% 35.62% -block --date-- --total-- ---used--%total- -active---%total---%used- 105570 Jan 2011 210,243 69,030 (32.83%) 37,989 18.07% 55.03% 111136 Feb 2011 267,542 78,813 (29.46%) 62,381 23.32% 79.15% 116038 Mar 2011 353,093 90,304 (25.58%) 92,321 26.15% 102.23% 121126 Apr 2011 443,112 99,090 (22.36%) 99,144 22.37% 100.05% 127865 May 2011 631,480 132,152 (20.93%) 203,052 32.15% 153.65% 134121 Jun 2011 1,061,590 196,975 (18.55%) 462,886 43.60% 235.00% 139035 Jul 2011 1,548,806 380,056 (24.54%) 531,002 34.28% 139.72% 143408 Aug 2011 1,930,979 487,833 (25.26%) 428,095 22.17% 87.75% 147565 Sep 2011 2,205,926 533,670 (24.19%) 318,294 14.43% 59.64% 151314 Oct 2011 2,411,298 546,269 (22.65%) 241,105 10.00% 44.14% 155451 Nov 2011 2,601,999 553,251 (21.26%) 225,012 8.65% 40.67% 160036 Dec 2011 2,768,500 568,177 (20.52%) 199,879 7.22% 35.18% -block --date-- --total-- ---used--%total- -active---%total---%used- 164780 Jan 2012 2,956,869 580,453 (19.63%) 236,927 8.01% 40.82% 165643 6 Feb 12 2,994,694 583,126 (19.47%) 62,300 2.08% 10.68% So the number of non-empty addresses has been around 600,000 since September 2011. As of block 165643, the ten most common values for addresses to store were: 0.00000000 (in 2411568 addresses) 50.00000000 (in 40631 addresses) 0.00000001 (in 35921 addresses) 0.05000000 (in 22806 addresses) 0.00100000 (in 22439 addresses) 0.02000000 (in 18160 addresses) 0.01000000 (in 13178 addresses) 1.00000000 (in 11636 addresses) 0.00500000 (in 9502 addresses) 0.00000002 (in 7628 addresses) The next 43 most common values after that were the 43 values from 3 satoshis to 45 satoshis, with between 5472 and 5799 addresses having each value. I don't know what's special about 0.00000045 and not 0.00000046, but only one other value with a non-zero 8th decimal digit occurred in more than 25 addresses. That was 0.00000703, which occurred in 101 different addresses. I also found a bunch of weird looking addresses, which nobody will ever be able to spend from. http://blockchain.info/address/871a40e5e61b96b6171f1b435788082edadda7a8 shows a lot of transactions sending tiny amounts to human-readable addresses, spelling out paragraphs of text. As of block 165643, from Mon Feb 6 2012: 2 addresses have 6 or more figures (100,000 <= x): 105,258.88 12WmWuSQCgpEkPQTZ4ABijQaz6TCV69ZpE and 105,555.00 1933phfhK3ZgFQNLGSDXvqCn32k2buXY8a 70 addresses have 5 figures (10,000 <= x < 100,000) 740 addresses have 4 figures (1,000 <= x < 10,000) 6,552 addresses have 3 figures (100 <= x < 1,000) 66,118 addresses have 2 figures (10 <= x < 100) 50,638 addresses have 1 figure (1 <= x < 10) 459,006 addresses have a fraction (0 < x < 1) 2,411,568 addresses have 0 BTC",
      "at the 28c3 conference, \"bitcoin - an analysis\" shows some data related to this. http://events.ccc.de/congress/2011/Fahrplan/events/4746.en.html http://media.ccc.de/browse/congress/2011/28c3-4746-en-bitcoin_an_analysis.html"
    ]
  },
  {
    "question": "Is Butterfly Labs reputable / Should I preorder the SC Jalepeno?I'm somewhat new to the mining scene but I'm a bit familiar with everything. I see that GPU mining will become much less cost effective over the next year or so, especially around December when the block reward size drops to 25 BTC. As an entry level miner, I don't have a decent rig to just use a pool with or anything. I'm stuck with a quad core AMD mobile CPU in an HP laptop with the worst ATI card known to mankind, giving me about 7.5 Mh/s using rpcminer-4way. Based on what I've seen, the claims that Butterfly Labs is making are pretty substantial and if they're true, they could greatly change the playing field. At a price as low as $150 for 3 Gh/s, I would be willing to invest, since I don't have the money right now to build a GPU mining machine. I have seen many people preorder the SC Jalepeno model and I'd just like some additional info and background on the company and their products before shelling out $150-$300. And are there any comparable low-cost FPGA or ASIC USB devices with a decent Mh/s/$?",
    "answers": [
      "EDIT: My original answer may have made sense back when the question was asked, but now it is clear that Butterfly Labs cannot be trusted. As they say, \"fool me once, shame on you; fool me twice, shame on me\". After all the delays and controversies with their FPGA line, they have given their word that with the experience gained they really will be able to deliver their ASIC line on October 2012. 10 months later (and 20-fold difficulty increase later), even the first pre-orderers didn't get their orders in full. This didn't stop them from announcing a new line, with pre-orders and the same empty promises. Which, if they deliver, will be better performing than their first ASIC line, without any compensation to their loyal customers who have waited more than a year. The fact that their CEO was shown to be a convicted felon doesn't help.",
      "Beyond the concerns about BL's ability to deliver, should they be successful it's very questionable what kind of return you'll be able to get as an individual user even with the substantial increases in efficiency they promise. With Bitcoin mining, the number of coins dispensed in a given time period is fixed and self adjusting to the relative strength of the network. When the pre-orders are all tallied and the first production run ships, we're likely going to see lots of chaos as the total network hash spikes up with each block of BL units being plugged in, but eventually it should hit some kind of equilibrium.... At which point exactly the same number of coins will be dispensed to the people who own BL hardware, relative to the $$ they invested with BL. That said, I pre-ordered a Jalepeno yesterday."
    ]
  },
  {
    "question": "how to monitor +20,000 addresses for new received transactions?I have around 20000 generated addresses which I want to monitor for new transactions. More addresses should probably come. Customers should use every address only once but I would like to monitor already used addresses if some of them decide to transfer coins to \"used\" addresses. These addresses are not in the online wallet, I have only addresses in the databases. Private keys are held offline. That means that I do not want to monitor addresses from the local wallet but the addresses from databases. A command should executed after a transaction is received (with enough confirmations). There are some monitor services which can send an email or call url after receiving a transaction for an address on the watchlist. I would like to implement the same feature for my application without depending on external service. I saw some questions and answers like: How to know there is a new transaction? or Monitor all transactions on bitcoin network - API But what would be the most efficient way to do this? Is there a perl/php compatible way to do that? One of topics from above links to https://bitcointalk.org/index.php?topic=89725.0 where Gavin is talking about some new features but I did not get how could I or whether I can use anything of this to monitor a high number of addresses. Sending every minute a batch RPC call with a few thousands addresses to bitcoind is probably not a solution :-(. I hope that there is a elegant way to monitor the whole information stream (all incoming transactions and other incoming information) and react if it matches what I need.",
    "answers": [
      "I am basically doing the same thing for bitcoinmonitor.net. I have a database of addresses to monitor and get notifications from bitcoind for any incoming transaction. I maintain a patchset for bitcoind which allows setting an url which will be called with any incoming unconfirmed transaction, including transaction details in a json object. Also for any new accepted block a (different) url can be set up to be called with details on the new block. So you will get a notification for any incoming unconfirmed transaction, then you can match this with the monitored addresses in your database. If you want to trigger actions after a certain number of confirmations you need to hook up to the new block event. Check https://github.com/TripleSpeeder/bitcoin for my bitcoind fork. I try to keep it more or less in sync with the current stable official client. This is running stable with bitcoinmonitor.net for around 10 months now.",
      "You could import all of those keys into a wallet using a very long password that you will never use again. Then, you could make bitcoind handle keeping track of all of those addresses and their balances, while not being able to spend any of them. The rest can be handled through the JSON RPC API . It might not be the neatest way of doing things, but it should work."
    ]
  },
  {
    "question": "What are the arguments for and against the increase of the block size limit?Can someone give a quick point by point list, what arguments the proponents and opponents of increased blocksize have for their case?",
    "answers": [
      "Please note, this answer was written in Februar 2015. The debate has significantly evolved since then, but I haven't gotten around to updating this answer, yet. I'm sorry, this kinda turned out less brief than it started. TL;DR: Very briefly, it is an issue of opposing ideologies: Proponents wish to provide a common good to everyone and believe the increase in blocksize to be necessary to that end. Opponents feel that a) it is impossible to introduce a change of that magnitude to Bitcoin at this stage, b) bigger blocks will mess up mining dynamics, or c) the increase changes properties of Bitcoin that shouldn't be changed. What happened before Originally, there was no blocksize limit. In fact, Satoshi Nakamoto was envisioning \"100 million transactions per day, [...] taking 100GB of bandwidth\" even in 2008 . The blocksize limit was introduced later, when people where starting to play around with bitcoin, but before the value picked up significantly, when a worry came up that people might bloat the blockchain with cheap \"spam transactions\".¹ The problem is that 1MiB of transactions provides such a small capacity that, we'd be limited to seven transactions per second at minimal transaction size, or extrapolating from current transaction sizes, around four transactions per second. The block limit has not been encountered yet, and is therefore not yet a serious restriction, however this is significantly less than competing global payment networks can handle. The thing is, that Bitcoin has become fairly valuable, and people want different things out of Bitcoin. The \"apolitical money\" is very political suddenly (as it always has been). Arguments against increasing There are quite a few different concerns here: Bigger blocks will destroy the market for transaction fees Increasing blocksize will make more room for transactions, which could reduce competition to be included in a block, in turn lowering transaction fees. In the long run, the block reward will dwindle, therefore less money would go towards mining, and the security of the Bitcoin network would wither with the lower income. Bandwidth requirements are too much for full nodes At 20MB per block, full nodes would have to download 2.8GB transaction data per day. This will be not only challenging data storage, but might actually be beyond the bandwidth capacity/datacap of some full node maintainers. One must consider especially that full nodes also serve the requests of thin-clients, so upload capacity might be more important than download capacity. However, on internet contracts for home-users upload speed is often significantly lower than download speed. It has been suggested that a larger blocksize would quickly lead to a large increase of transaction numbers due to induced demand . \"Bigger blocks will lead to centralization.\" Consensus may not be achievable Once the first block larger than the 1MiB limit will be mined, a hardfork will occur between the network participants that refuse blocks greater than the limit, and network participants that accept it. Blocks mined on the old network remain compatible to the new network, but not the other way around. Some voices have announced that they would use the fork as an opportunity to double-spend all their Bitcoins, spending them to themselves on the 1MiB-chain, and selling them on the 20MiB-chain, to profit and drive the new chain in the ground. Some users suggest that this supporters of that proposal have sufficient Bitcoin holdings and support that they can essentially force failure of the blocksize increase, they presume that exchanges would land on different sides in the discussion, but all users would quickly flock to the \"safe old chain\", once the \"civil war\" starts. Bitcoin is destroying viability of altcoins An increased Bitcoin blocksize would decrease demand for other blockchains, hurting investors of altcoins. Bitcoin is not meant for every person on the planet to pay for their every cup of coffee Some people feel that Bitcoin should be an exclusive privilege for settling between companies and the super-rich. A bigger blocksize would dilute the exclusiveness. They argue that something that is useful, but universally available is worthless. Bitcoin instead is meant to \" force the poor to yield to the rich, universally, as a matter of course \". People are feeling that something is being decided without them being consulted \"There is only one proposal, we have no choice.\" \"We cannot predict how quickly bandwidth will grow, the proposed increase it too much.\" \"There is no consensus, forking without community support is a dead-end.\" \"There will be huge problems if we do this.\" \"Why haven't the miners been asked?\" I have trouble relating to these last statements, as the discussion about the blocksize limit has been going on for years. Arguments for increasing The transaction capacity is too low to support a global payment network 4.4 tps (transaction per second) are too few to support a global payment network. At current network capacity, a bigger demand for transactions would cause regular users to be priced out of the blockchain. One would have to wait forever to have a transaction included in a block, and Bitcoin would eventually only get used to settle between banks, mayor corporations, and the super-rich. The blockchain instead should be accessible to everyone, and therefore the blocksize must be increased. Often, this is followed by the argumentum ab auctoritate , that the blocksize limit was always meant to be temporary, and the fork being necessary to achieve the vision Satoshi outlined in the original whitepaper . Greater blocksize will increase total transaction fees Even in a bigger block, transactions are not a free resource, as they cost bandwidth, data storage, and cause slower block propagation. Already, miners are not always including all transactions. Therefore, a market for transaction fees would exist even with bigger blocks, and more transactions would cause a higher total of transaction fees. Effective blocksize will not increase over night The blockchain of the past six years is smaller than 30GiB. It is wrong to assume that with the introduction of a larger limit, the blocks would suddenly fill up quickly, when they haven't done so before. Consensus will be achieved before the hardfork is initiated Major payment providers, exchanges, and mining pools will side with the hardfork supporters, causing the opponents to find themselves to be such a small minority that they will be stuck on an irrelevant alternative chain. Technical issues will be fixed Slower block propagation due to bigger blocks will be mitigated by Header-first synchronization and Inverted Bloom Lookup Tables . Internet connections will speed up sufficiently in parallel to increasing traffic demands on the network. Datastorage issues will be solved by introduction of a pruned blockchain, where most \"full nodes\" only keep a limited number of the last blocks, and few full nodes maintain the complete blockchain. Conclusion Personally, I think it is the natural progression of Bitcoin to increase the blocksize, as I see potential for Bitcoin to serve a broader audience. However, I do get some points of the contrarians, especially that it is hard to make predictions about how this will all play out. Further reading is found here (and in a million other places): About discussion: Tim Swanson: What is the blockchain hard fork “missile crisis?” Reddit: Should the maximum block size be increased soon Quora: Who will win the Bitconi blocksize war? Pro increase: Gavin Andresen: A Scalability Roadmap DeathAndTaxes: Permanently keeping the 1MB (anti-spam) restriction is a great idea,… if you are a bank. Contra increase: ² Mircea Popescu: Let's address some of the more common pseudo-arguments raised by the very stupid people that like the Gavin scamcoin proposal ¹ Does anyone have links to the discussion on the introduction of the blocksize limit? I was looking for that. ² I'm still looking for more representative contra-positions. Wading through a few threads of some forums gave me a skin rash, but hardly anything useful.",
      "These three arguments are againt the block size increase ... Since the block size will increase then first argument is that trxns will easily inserted in the block i.e this thing will lower the trxn fees and then miners gonna lose their motive becoz trxn fees will be decreased, this may demotivate the miners (for example : suppose you are doing a job and you get 10$ for the job daily , what if that price drop to 5$ for the job daily and job is same....then you will be looking for other job or better option , that's the thing with miners) and miners will move to some better option. If no. of miners decreases then this will decrease the overall hashrate of bitcoin, so sad. Second argument is that it will divide the community becoz if we want to increase the block size in bitcoin blockchain then this increment in blocksize will cause a fork in the system which will make two parallel bitcoins so this will split the community. Third argument is that block size increase will cause centralization, since the network size will increase due to more trxns, the amount of processing power required to mine will increase as well. This will not help small mining pools and give mining powers to large scale mining pools and will increase centralization which is not acceptable in bitcoin community. This blocksize increase is still debatable in community."
    ]
  },
  {
    "question": "How is SegWit a soft fork?Reading this section of BIP144, I noticed the followng statement: Parsers supporting this BIP will be able to distinguish between the old serialization format (without the witness) and this one. The marker byte is set to zero so that this structure will never parse as a valid transaction in a parser that does not support this BIP. If parsing were to succeed, such a transaction would contain no inputs and a single output. And this is in fact confirmed by this line in Bitcoin Core which is executed for every transaction found in a block during the CheckBlock call. As far as I understand, this should mean that old clients that see a block containing a SegWit transaction would consider that transaction invalid and hence discard the whole block. Is that correct? What am I missing?",
    "answers": [
      "You're confusing transactions (the abstract object) and their serialization (the bytes on the wire in the P2P protocol or on disk). Sure, SegWit introduces an extension to the P2P protocol (BIP144), which relays witnesses along with transactions, and old clients wouldn't understand such messages. But old clients don't see them. Witnesses are only included when the requester asks for them, which old clients don't do. For them, new clients remove the witnesses before relay. Exactly because the witness of a transaction does not contribute to its txid, it is in fact possible to remove them before relay, without invalidating them. That is what makes it a soft fork."
    ]
  },
  {
    "question": "What is the difference between a miner and a full node?I have trouble finding the difference between a full node and a miner. It looks like these two names are used interchangeably which I think is not entirely correct. Miners do process blocks and full nodes verify if transactions which has been packed in the block by miners are all valid. Some can run a full node without running the mining software. I know a lot of people who think that miners and full nodes are one and the same. Thank you for your help.",
    "answers": [
      "A 'full node' is a participant on the network that has independently validated the complete copy of the blockchain, and thus has verified all transactions since the beginning. This requires about 350GB of drive space (currently). A pruning node is one that has verified all prior transactions; however, it has deleted all blocks below a certain space requirement, but still has a copy of the UXTO set. It's less useful to the community, but is useful to the node's owner, and takes less resources on the computer (can be under 1GB of drive space). A miner on the other hand creates blocks in the blockchain which the nodes keep. Basically, the miner adds transactions to a block, with the goal of creating a new block with a valid hash that will be accepted by the network. Miners spend about 10 minutes working on a problem, but nodes keep that result forever after in the database and verify it with others. Miners don't need to know about prior blocks (except for the prior one) with very few exceptions. So, a miner is completely different than a full node. It's not comparing the same like things. Full vs Light is comparing two like things - fruit (apple and orange). Miner vs FullNode is comparing two totally different things (apple and fence).",
      "Ok after reading the comments I still didn't find a valid answer to the initial question. A (full) node contains the whole block chain. With this knowledge this node can check if new transactions actually are OK. Although not strictly necessary, a miner is a full node(so with complete knowledge of the block chain) which additionally creates new blocks compared to just nodes than only validate information. This hazel has been long time in my head and no sourse was available to clarify than until i read the comment of carsten_ger in the following link: https://www.reddit.com/r/BitcoinBeginners/comments/2rpmyl/what_is_the_difference_between_running_a_node_and/ Hope that helps."
    ]
  },
  {
    "question": "Is there a difference between bytes and virtual bytes (vbytes)?In an Optech newsletter, size is referred to using vbytes. Is there a difference between vbytes and bytes? If so, what is the difference?",
    "answers": [
      "Yes, bytes and vbytes are referring to two different metrics: size and virtual size (vsize) . The size in [bytes] of a transaction refers to the raw byte length of its serialized format. It is used to measure the data footprint of transactions when relayed on the network or stored on disk. The vsize in [vbytes] refers to a transaction's weighted size under segwit's rules. It is used to compare how much blockweight needs to be allocated to confirm a transaction. Block weight limit Bitcoin blocks are limited in their transaction capacity. Before Segregated Witness (segwit) was activated, blocks were limited to a blocksize of 1,000,000 bytes. Under that paradigm, the size of a transaction corresponded to the byte count of its serialized format. The activation of the segwit softfork replaced the blocksize limit with a blockweight limit of 4,000,000 [weight units (wu)]. The new protocol rule defines the weight of a transaction as the sum of the witness bytes counted at a factor of one and non-witness bytes counted at a factor of four. weight [wu] = 4 [wu/B] × non-witness length [B] + 1 [wu/B] × witness length [B] Since non-segwit transactions don't have any witness data, this results in equivalent rules for non-segwit blocks before and after the rule change: 1 B / 1,000,000 B = 4 wu / 4,000,000 wu One byte is the same portion of the previous blocksize limit as four weight units of the new blockweight limit. Transactions without witnesses, non-segwit transactions, take exactly the same portion of the blockweight as they took of the blocksize prior to segwit activation. This allowed segwit to be introduced as a forward compatible soft fork . Segwit Discount For segwit transactions, which do include witness data, the resulting transaction weight is strictly smaller than 4 × size due to the witness bytes contributing at a lower factor. This results in a lower relative portion of the blockweight to include a segwit transactions than an equivalent non-segwit transaction. The adoption of the segwit output format results in an effective capacity increase. Segwit blocks may exceed raw byte sizes of 1,000,000 bytes, with e.g. the biggest block to date achieving a raw byte size 2,424,027 bytes. Feerates and their units Before segwit activated, users measured transaction sizes in [bytes] and feerates in [satoshis per byte]. Since segwit activated, the protocol measures transactions by weight in [weight units]. At the protocol level, this shifts the range of feerate values by a factor of four. Segwit introduces the measure virtual size (vsize) in [virtual bytes (vbytes)] to ease comparison of feerates before and after segwit activation. The vsize is calculated by dividing the transaction weight by four: vsize [vB] = weight [wu] / 4 . The range of values of fee per vsize thus matches the range of the pre-segwit fee per size . To this day (Oct 2020), it remains popular to track feerates in [satoshis per vbyte]. If you are looking for an approachable example, check out this detailed comparison with concrete values: How do virtual size, stripped size and raw size compare between legacy address formats and native segwit?",
      "For non-segwit transactions, vbytes = bytes. With the implementation of SegWit, we now see the weight of the block/transactions rather than seeing the absolute size on the wire. While calculating the weight of a transaction, we use a weight of four for the normal transaction components (ex signature) and weight of one for the witness components. Now vbyte is always equal to weight/4. Following will the calculation to distinguish between vbytes and actual bytes on the wire. Let St the number of bytes needed to serialize the transaction in legacy format (which does not include the witnesses) and Sw be the number of bytes needed to serialize the witness component. Weight of the transaction = St*4 + Sw vbytes = (St*4 + Sw)/4 = St + Sw/4 actual size on wire = St + Sw difference = (3/4)*Sw Since non-SegWit transactions do not segregate the signatures to the witness component Sw = 0, and hence vbyte is equal to normal bytes."
    ]
  },
  {
    "question": "Is bitcoin.org or bitcoincore.org the one to trust?\"Download Bitcoin Core\": https://bitcoin.org/en/download \"Download Bitcoin Core\": https://bitcoincore.org/en/download/ I've been alternating between the two sites for years. I have no clue who to trust the most. Why are there two? I mean, I get it, it's \"decentralized\", but we all know that in practice, we must trust some kind of central source to get the actual \"reference implementation\", which most of us do consider the official \"and only\" (for us) Bitcoin client. There's something which psychologically prevents me from ever trusting one of the other Bitcoin wallets/clients. It seems to me that Bitcoin is so absurdly complicated that only one team can really get it right. I've spent endless hours over so many years just trying to understand it on a \"user\" level, but it's just an Enigma still in so many ways. I'm even nervous for the main Bitcoin Core team to make a mistake, by accident or through evil intentions.",
    "answers": [
      "It looks like https://bitcoincore.org/ is the one run by the people who run the Github bitcoin/bitcoin project (the actual core developers) since it is the one listed on their Github page: https://github.com/bitcoin/bitcoin If you want the absolute best source for the client directly from Bitcoin Core devs then I would use that site or their Github page for downloads. https://bitcoin.org is still, however, a reliable source for information on Bitcoin Core, and maintained by the community. However, it is owned by someone who isn't tied to the Bitcoin Core project itself (as far as I'm aware): https://github.com/cobra-bitcoin",
      "https://bitcoin.org/en/bitcoin-core/ says For the latest developments related to Bitcoin Core, be sure to visit the project’s official website . (which is a link to https://bitcoincore.org/ ) So there has been a deliberate separation between the Bitcoin.org project and the Bitcoin core project. This would make sense as Bitcoin.org provide information and links for many wallet programs and might wish to be seen as unbiased. The latter is therefore the \"one to trust\" unless you know of some concrete reason otherwise."
    ]
  },
  {
    "question": "Why would anyone sell a Bitcoin miner instead of just mining themselves?Every time I have asked Bitcoin experts about buying a \"cloud mining\" account, that is, paying fiat money to a company for them to mine Bitcoin for me, I get the response that it's a scam. \"Why would they want to give you any Bitcoin when they can just mine for themselves?\" is the reasoning given. But then doesn't the same logic apply to actually buying a miner and \"mining at home yourself\"? Why would anyone sell such a machine when they can just hook up another one to their massive warehouse of miners and get more Bitcoin for themselves? Why bother dealing with charging fiat (or Bitcoin!) from annoying customers, having to deal with shipping and all that stuff? Why not just... mine themselves? It seems like the very same thing to me. I just don't see any way for me to mine Bitcoin which would actually be profitable or make sense.",
    "answers": [
      "Every time I have asked Bitcoin experts about buying a \"cloud mining\" account, that is, paying fiat money to a company for them to mine Bitcoin for me, I get the response that it's a scam. Most of them are scams because it's almost impossible to verify that your money is used for mining. You need to trust a company that can do anything with the money (trade, lend, run away after few months etc.) Why would anyone sell such a machine when they can just hook up another one to their massive warehouse of miners and get more Bitcoin for themselves? Mining is a business which requires: Space Electricity Hardware Cooling People to manage Manufacturing ASICs is a business in which you create hardware used in mining, ship it and provide support. A company which creates ASICs can do both (manufacturing and mining) or just manufacturing. This is similar to lot of other hardware companies that could use the product themselves for business but it has different risk/reward compared to just manufacturing. I just don't see any way for me to mine Bitcoin which would actually be profitable or make sense. Mining profitability calculator: https://insights.braiins.com/profitability-calculator",
      "The difference is that with cloud mining, all you are doing is lending the company money. And you are expecting them, for no rational reason, to pay you back an interest rate higher than they would have to pay if they took out the worst loans in existence. In the case of cloud mining, literally everything is done by the company. All they are doing is borrowing money from you and you are somehow expecting that the will pay you more than the normal amount of interest borrowers pay to lenders. That's obviously ridiculous. In the case of buying a miner, the company just provides you a physical product that they manufacture. It is then up to you to maintain it, to provide it power and cooling, to maintain its internet connection, and to take on risk over months that the value of the cryptocurrency it produces will drop. That is nothing like just lending money to a supposed turn-key profit generator that requires you to do nothing but kick back and collect profit. Why would companies that make miners have access to cheap power and cooling? Why would companies that make miners have facilities that can house them?"
    ]
  },
  {
    "question": "Can a 51% attack be detected and dealt with?If someone got 51% hash power and started rewriting the blockchain from scratch (building a longer chain with a completely different history), could this be detected? Could \"the honest users\" revert such attacks?",
    "answers": [
      "Can such attacks be detected? Yes. What you would see is a chain reorganization that invalidates a large (greater than three) number of previously-accepted blocks. The standard client will actually log this -- you'll see a REORGANIZE in the client's debug.log file. The client doesn't currently log the number of blocks invalidated by the reorganization, but that's a simple enhancement. Can honest users revert such attacks? Sort of. If a transaction you care about is in the set of blocks that was invalidated, you can always resubmit that transaction. Unless the sender issued a conflicting transaction as part of a double-spend attack, the transaction will still be valid. (The network will actually do this for you automatically. Miners don't want to miss out on the chance to grab the transaction fees associated with the undone transactions.) As a longer-term solution, there have been proposals discussed to reject reorganizations that invalidate suspiciously large numbers of blocks such as four or more. The problem with these proposals is that under unusual circumstances (such as if a disaster partitions the Internet for half an hour), the network can permanently split with each side rejecting the other side's block chain as a suspicious reorganization. Essentially, the client would have to go to a \"lockout\" mode if this happened and reject all transactions until some mechanism to find the real block chain could be implemented. (It could submit all transactions to both chains and consider only transactions accepted in both as confirmed!) One proposal uses a central authority to pick the real chain. This is an area where there is room for innovation. One important point to keep in mind though: If the sender is not attempting a double-spend attack, you have nothing to worry about (other than the reduced usefulness of an unstable exchange network). You can submit the transaction to the block chain as many times as you need to until some block containing the transaction finally does win. Only the sender can create a conflicting transaction that would make you unable to get the transaction you care about into the chain. Update: In fact, you can lose coins even if the sender wasn't attempting a double-spend attack. Suppose A sends B money and then B sends C money, if A successfully uses a double-spend attack to invalidate the transaction that sent the coins to B, the send from B to C can fail (because a conflicting transactions means B will never have the funds to spend) even though B was not attempting a double-spend attack.",
      "A comment about “starting from scratch”. Several check-points have been hardcoded in the client source (hashes of blocks are regularly added in new versions of the client) precisely to reduce the impact of large rewrites of big chain chunks. The transaction history generated in the early days of bitcoin could easily be rewritten with all the processing power available to miners today. But recent clients cannot be lured this way because of these check-points. Someone with 51% of the total computing power could start rewriting the history from the last check-point, but he cannot go further in the past. Also, for the attack to be effective, one must overtake the network chain before the next check point is accepted by a majority of nodes."
    ]
  },
  {
    "question": "Could the EC2 infrastructure be used to efficiently launch a 51% attack?This excellent answer from Serith states that one would need 31150 ATI 5870 graphics cards to launch a 51% attack. Amazon EC2 offers computers for rent for 2.10$ per hour. These instances have 2 x NVIDIA Tesla “Fermi” M2050 GPUs. Given that these are as fast as the ATI 5870 (I have absolutely no idea whether this is the case), and that Amazon has enough of these instances available, one should be able to launch a 51% attack for one hour for a mere 65415$. If the hash rate of the Bitcoin network varies over the time of the day or under such events as a power cut, then it could be cheaper. Is this a potential threat to the Bitcoin network?",
    "answers": [
      "An NVIDIA Tesla “Fermi” M2050 is not as fast as an ATI 5870. According to the wiki , the NVIDIA card makes around 70Mh/s and the 5870 makes around 400Mh/s. If they were similar and if Amazon had that amount of cards available for rent , then it would be possible. Just don't forget that you would be paying $65415 per hour to sustain an attack that will not give you that much power over the network. See this question for an explanation of what the attacker could do.",
      "EC2 would be prohibitively expensive to attack bitcoin but would be well suited against so called \"GPU unfriendly\" block chains. Against bitcoin EC most likely usage would be to \"top off\" an attackers hashing power. If a hypothetical attacker built a massive hashing farm but was slightly short of 51% hashing power the attacker could use EC2 instances to push the attack \"over top\". EC2 is ill suited as primary source of an attacker's hashing power because EC2 GPU prices are expensive, the GPU Amazon chose is poorly suited for hashing, and the number of instances is lmited (Amazon only has so many GPU instances). CPU instances are significantly cheaper but they have on average 1/50th the hashing power of average GPU which significantly increases the number of instances necessary to achieve 51% hashing power. For so called \"GPU-unfriendly\" block chains (litecoin, tenebrix, solidcoin, etc) use of EC2 instances is far more efficient and economical. Since these chains chose to exclude GPUs (a dubious decision) they have in effect removed the performance advantage between the hardware used by honest nodes and the most cost effective hardware available to attackers. Each honest node is now significantly less powerful (being limited to on average a single CPU) and CPU power (in a variety of forms) is much cheaper and easily accessed by an attacker. In essence these chains have commoditized the hardware used for hashing and as such left themselves vulnerable because large amounts of CPU hardware can be obtained for very cheap if only needed for a short period of time (like in a 51% attack). Although the problem exists in all \"GPU unfriendly\" chains lets take a closer look at one chian, Litecoin. Litecoin's hashing power is roughly 30MH/s. To defeat that would require only 6000 Amazon Compute Units (virtual CPU roughly equivelent to a modern 1GHz Xeon CPU). The largest Amazon instances have 30 compute units. Thus it would only require 200 of the largest instances or roughly $300 per hour at current prices to achieve 51% of Litecoin's network hashing power. Every other \"GPU unfriendly\" coin faces the same problem. By excluding high performance GPU they have made it easier for an attacker to leverage large sources of easily obtained low cost CPU power putting the network at risk"
    ]
  },
  {
    "question": "How often forks occur?How often do forks occur in the block chain? I'm interested in the small, one block forks that happen when two miners create a block at the similar time.",
    "answers": [
      "Blocks are orphaned once in a while, roughly every few hundred blocks: http://blockchain.info/orphaned-blocks There used to be a blockexplorer -provided list of chain reorganizations which can occur upon such events (might become available again someday): http://blockexplorer.com/q/reorglog These chain reorgs used to happen a few times per month.",
      "I don't think the blockexplorer reorglog catches all blocks. http://blockchain.info/orphaned-blocks shows 1-2 detached blocks per day."
    ]
  },
  {
    "question": "Why does my wallet need to download the whole transaction history?I started a wallet, and it is downloading and synchronizing lots of transactions. This takes time and network bandwidth. Why is this necessary? Is this some form of accountability? With Paypal, for example, this isn't done. And as you grow, I guess this becomes a huge -- will the amount of transaction data become too large? It is a bit scary to have my computer run off and synchronize, without it informing me what kind of information it is getting and whey this is necessary. Can't the whole transaction history be shown or available on a website, rather than loaded on my computer?",
    "answers": [
      "The short answer to your question is \"no\". The reason is actually pretty simple: Without the entire block chain, there is no way to know that funds that are claimed to have been sent to you weren't actually sent to someone else. There is no way to prove the absence of a conflicting transaction, other than to check every valid transaction. With a bank, the bank clears your checks for you. Here, you clear your own checks. Without knowing every check an account has received or sent out, how can you know the account has sufficient balance to cover your check? Of course, you don't have to run the Bitcoin client. Your alternative is trust someone else with your coins.",
      "Bitcoin is a new approach to security of money, offering nigh-full transparency. You can \"audit\" any account and see what transactions were performed without a problem. With traditional models, like Paypal or the banks, you can't do that. As Bitcoin is P2P, it needs to have all the data to be able to validate all of it. This way no single entity can take the whole network down, or freeze anyone's account. There are works done, however, on a set of servers forming Stratum overlay network protocol that will be handling almost all of data handling for very thin clients. In this model one would not need to download or validate the entire blockchain, but some people see this as giving up their security (this issue is addressed and debunked here ). A third option is thin clients that validate all the data, but prune older blocks that they don't need themselves. This approach would save hard drive space, but not the initial validation time. In short, if all Bitcoin data was stored on a single website, the system would be vulnerable to being taken down and trust would be centralized. With the standard client, one need not trust any single individual, so security is greater. There are are other solutions being developed that will be something in-between the two."
    ]
  },
  {
    "question": "What is the expected time until the next block is found?https://bitcoin.stackexchange.com/a/3908/659 says: Luckily, you'll only have to wait five minutes on average for a block to be found (blocks are one every ten minutes, so the expected delay until the next block is five minutes). Upon reading it, I instantly felt that this was incorrect, and that the expected time until the next block is always 10 minutes (assuming the network hash rate matches the current difficulty). If the blocks were generated exactly every 10 minutes, than it would be true that the expected time would be 5 minutes, but they're not. So what's the real expected time? Please make a plausible argument for why it is so.",
    "answers": [
      "10 minutes. Assuming, as you say, that the current network hashrate matches the difficulty - otherwise it is proportionally higher or lower. Block finding is a Poisson process . The rate parameter λ is chosen so that 2016 blocks on average are found every 2 weeks, and since in such a process the expected number of events is proportional to the time span, it means λ is 1/(10 minutes). The time until the next event (the next block found in our case) follows the exponential distribution with mean 1/λ, which is 10 minutes. This distribution is memoryless - the amount of time spent waiting for a block has no effect on the amount of time left to wait. When a block is found the expected time until the next block is 10 minutes (which is intuitive), and it is also 10 minutes at any other time. If blocks arrived once every 10 minutes like clockwork, the expected time until the next block at a random point would be indeed 5 minutes - but then we wouldn't have to worry about expectations, we'd know exactly when the next block will be found. In the future, the decreased generation reward might cause the total hashrate to fluctuate as transaction fees accumulate, causing reduced variability in block finding times, and reduced expected waiting time."
    ]
  },
  {
    "question": "How will multisig addresses work?How will multisig addresses work? Will they consist of multiple traditional addresses, or will they have some different structure? Will one be able to specify whether they will require 2 out of 2, 2 out of 3 or M out of N signatures? Where can I find out more about their specification?",
    "answers": [
      "I know this question is old, but I stumbled upon it looking how to teach myself how multisig addresses work, and I imagine others will to. So I’m going to try to explain the typical flow for creating, adding bitcoins to, and eventually spending a multisig address. This explanation is aimed at beginners, so please excuse my lack of brevity. First off, some terminology we should get out of the way. Bitcoin Address: A bitcoin address is a string of (usually) 33 or 34 digits which we give to people when we want them to send us bitcoins. Here is an example of public address 19evXeJDDLNeRS4st4bGUJNGk8eBgVCCg4 Public Key: A public key is used to derive a bitcoin address, although knowing a bitcoin address WILL NOT allow you to find that address’s corresponding public key. For more information on the public key / bitcoin address relationship go to https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses . Here’s what the public key for the bitcoin address pasted above looks like 035739f07de25c205525d81b126ed87bc30377e688705072d186e4f5c88908ce3a Note that I only know that public key because it’s stored along with my private key in my wallet, I’m posting this usually confidential information here because it is easier to understand bitcoin when you have examples. Multisig transaction/address: A multisig transaction is just a transaction that has as one of its inputs a multisig address. Multisig addresses are used to make it so multiple keys owned by separate entities are needed to move the bitcoins in an address. OK great! Now, here are the steps and background for making a multisig address. I’m going to explain things in plain English first, and then follow up with the bash/Terminal commands you will use to create/add money to/spend the multisig address. I’m using the standard bash delimiter “$>” to indicate that whatever comes after the “$>” is what you should enter into your terminal. Lines that come after the line containing “$>” are the output of that command. If you ever have any questions about a command your entering, you can type the following into the Terminal to show what arguments should be passed to the command $> bitcoind help This explanation assumes you have an update to date and functioning bitcoind server running that can accept RPC commands. i. Create the public keys that will comprise the multisig address. You are going to use these public keys and one other piece of information to create your multisig address. The most common distribution of the addresses in a 3-address multisig address (it’s possible to have a multisig address comprised of more than three addresses, but they’re not supported by all miners so for this explanation we’ll deal with the most common 3-address multisig address) are as follows. PubKey#1 is typically owned by you and stored on a device you have easy access to (like your mobile phone). PubKey#2 is typically also owned by you but stored somewhere secure (like cold storage or in a paper wallet). PubKey#3 is often the public key of some third party, like your brother or a company offering bitcoin-related services like Coinbase. Let’s call each of these owners of a public key an entity. Recall that Bitcoin uses private/public key cryptography, so whomever creates a public key also keeps the corresponding private key to themselves. This private key will be important later in the explanation. So let’s create 3 new public addresses which we’ll end up using to create a multisig address! Note that as I explained above, if you were using a multisig address in a real world situation you’d probably get one of the three public keys from some third party, but for this explanation here we’re just going to create all three ourselves. Here are the relevant RPC commands for creating public keys: Enter this command to see all your accounts. Assuming you’re starting fresh, you’ll only have the account with the name empty string and no bitcoins in it $> bitcoind listaccounts { \"\" : 0.00000000 } Enter the following command three times to create three new addresses in this account $> bitcoind getnewaddress “\" Enter this command to view your newly created addresses $> bitcoind getaddressesbyaccount “” [ \"1CtfcziAhqx83CtSPdufgZDGmL8ohTFTdd\", \"1JeK7TZR85BL8WvtHgCiTSYtPJupdYYXgR\", \"1MP3BzdhzoBmGoBiVfLmhv7B4Czxm3MbrU\" ] You’re not done though. So far you’ve only seen the public addresses. You need to get the public keys of these addresses. Luckily you can do that simply by typing the following command three times, each time substituting for one of the addresses you created $> bitcoind validateaddress { \"isvalid\" : true, \"address\" : \"19evXeJDDLNeRS4st4bGUJNGk8eBgVCCg4\", \"ismine\" : true, \"isscript\" : false, \"pubkey\" : \"035739f07de25c205525d81b126ed87bc30377e688705072d186e4f5c88908ce3a\", \"iscompressed\" : true, \"account\" : \"\" } The value to the right of “pubkey” is that address’s public key. ii. You then use these three keys to create the multisig address. In the previous paragraph I mentioned how you needed the public keys plus one other piece of information to create the multisig wallet. That piece of information is the number of signatures needed to spend the bitcoins in a multisig address. One of the useful things about a multisig address is that, in order to send the money in the address, it takes multiple private keys (I told you we’d come back to these!) signing the transaction to make it valid. So for this example we’re going to use the number 2; two out of the three entities will need to sign the transaction in order for bitcoins to move anywhere. When we create the multisig address, bitcoind will return the multisig 34 digit address, as well as a bunch of hex data called the “redeemScript”. Note that the first digit in the address is a “3”. Most addresses your used to probably begin with a “1”, but all multisig begin with “3”. Copy, paste, and save the address and redeemScript values somewhere as we’ll need them in a bit. So, we create the multisig address by entering the following command. Be sure to type the apostrophes and quotes exactly as I have, and substitute for the public keys you got from validateaddress. $> bitcoind createmultisig 2 ‘[“ \", \" \", \" ”]' { \"address\" : \"3DS7Y6bdePdnFCoXqddkevovh4s5M8NhgM\", \"redeemScript\" : \"5221027ca87e1aa2595ec7771afee8fdc6efdbc301b8370c4386731b4bd82247dc74a321022cc9874ba092095dd a47a4e4edb1781c43c35b3ec0429ac005df37b9d6eec94b21035739f07de25c205525d81b126ed87bc30377e6887 05072d186e4f5c88908ce3a53ae\" } Copy the output that you get somewhere, we will need it soon. iii. Send some bitcoins from one of your wallets to the multisig address. I was surprised to learn Coinbase doesn’t think that multisig addresses are valid, so if you’re using Coinbase you can’t send directly from your Coinbase wallet to the multisig address. As a workaround, you can use Coinbase to send a small amount of bitcoins (I sent 1 dollar’s worth) to one of the three addresses you originally created, wait for that transaction to get confirmed, and then use the following command to send bitcoins from that regular address to the multisig address. Replace with the multisig address and with some amount of bitcoins worth less than the amount you sent to the regular address. Remember that you’ll have to pay transaction fees! If the command works it will return the transaction’s transaction hash. You can look at this transaction by entering the transaction hash into the search field at blockchain.info. $> bitcoind sendtoaddress 0ac29fc675909eb565a0984fe13a47dae16ca53fb477b9e03446c898b925ab6b iv. Finally, we’re going to spend the bitcoins we just received in the multisig address. We will use the private keys of the first two addresses we created in step 1. In order to obtain the private keys, we enter the following command twice into the Terminal, each time replacing with one of the bitcoin addresses you created: $> bitcoind dumpprivkey KyiRjmZYPH7cfyKf1WNb3BZFz1ySurWEYKxLngkH6VmTcSCirBPG (As a side note, the worst possible thing you can do in the bitcoin community is to paste the private key of one of your addresses onto a public forum. NEVER DO THIS! I am only doing this because I want to make sure readers can follow along with my explanation, and there's only a couple dollars in these addresses) v. Now that you have two public/private key pairs, we can finally spend the bitcoins we sent to the multisig address. To do so, we first need to gather some information about that transaction where we sent bitcoins to the multisig address, because we need to choose the correct output from that transaction to use as the input in the raw transaction we’re about to create. Type the following into the terminal, replacing with the transaction hash that was returned earlier. $> bitcoind getrawtransaction 1 { \"hex\" : \"010000000175783b2ca3381efb15ee7f5f44632a2c699171a924185386460b91d0f211d3bb000000006a47304402207707875d5c29ed0d97cd72087c67c17c57e2ef34d0b6208a054fffece8704477022045aec0ea57830f53fa0e52094400dd4fb654d7712f2ac3341a762d0f46c02d370121027ca87e1aa2595ec7771afee8fdc6efdbc301b8370c4386731b4bd82247dc74a3ffffffff0210270000000000001976a91431e71089318d7b1ea51a1add0dd6525423f713c488ac702402000000000017a91480cff499983050ec4268d749a1f898bec53e9fc28700000000\", \"txid\" : \"0ac29fc675909eb565a0984fe13a47dae16ca53fb477b9e03446c898b925ab6b\", \"version\" : 1, \"locktime\" : 0, \"vin\" : [ { \"txid\" : \"bbd311f2d0910b4686531824a97191692c2a63445f7fee15fb1e38a32c3b7875\", \"vout\" : 0, \"scriptSig\" : { \"asm\" : \"304402207707875d5c29ed0d97cd72087c67c17c57e2ef34d0b6208a054fffece8704477022045aec0ea57830f53fa0e52094400dd4fb654d7712f2ac3341a762d0f46c02d3701 027ca87e1aa2595ec7771afee8fdc6efdbc301b8370c4386731b4bd82247dc74a3\", \"hex\" : \"47304402207707875d5c29ed0d97cd72087c67c17c57e2ef34d0b6208a054fffece8704477022045aec0ea57830f53fa0e52094400dd4fb654d7712f2ac3341a762d0f46c02d370121027ca87e1aa2595ec7771afee8fdc6efdbc301b8370c4386731b4bd82247dc74a3\" }, \"sequence\" : 4294967295 } ], \"vout\" : [ { \"value\" : 0.00010000, \"n\" : 0, \"scriptPubKey\" : { \"asm\" : \"OP_DUP OP_HASH160 31e71089318d7b1ea51a1add0dd6525423f713c4 OP_EQUALVERIFY OP_CHECKSIG\", \"hex\" : \"76a91431e71089318d7b1ea51a1add0dd6525423f713c488ac\", \"reqSigs\" : 1, \"type\" : \"pubkeyhash\", \"addresses\" : [ \"15Yrv3rAVxYTTGePM3ZZwumSnMfS9St9uD\" ] } }, { \"value\" : 0.00140400, \"n\" : 1, \"scriptPubKey\" : { \"asm\" : \"OP_HASH160 80cff499983050ec4268d749a1f898bec53e9fc2 OP_EQUAL\", \"hex\" : \"a91480cff499983050ec4268d749a1f898bec53e9fc287\", \"reqSigs\" : 1, \"type\" : \"scripthash\", \"addresses\" : [ \"3DS7Y6bdePdnFCoXqddkevovh4s5M8NhgM\" ] } } ], \"blockhash\" : \"00000000000000002ab5cb0ee400200b8575fe393fef57d41b41a5d533a414a3\", \"confirmations\" : 5, \"time\" : 1404775273, \"blocktime\" : 1404775273 } Look for the key “vout”, which should have a JSON array as its value. We need two values here; the index of the output in vout which has the largest value, and the value of the “hex” key within that same output. When I originally sent this transaction I had sent 0.00160400 bitcoins. 0.0001 of that went to paying miner fees, and the remaining 0.0010000 went to a change address that my client software created for me. We’ll want to use the output with the largest value (here 0.00140400) as the input in our transaction when we create our raw transaction. So here the index is equal to 1. In this same transaction we’ll need the value for the key “hex” within “scriptPubKey. It’s too much to go into detail here as to what this value represents, if you’re interested in learning about one of the more fascinating parts of the bitcoin protocol start reading here https://bitcointalk.org/index.php?topic=377604.0 . At a high level, the scriptPubKey “hex” value is a hexadecimal encoding of the script that gets run as part of a transaction input in order to verify that the transaction is valid. Anyways, the value for “hex” we want is thus a91480cff499983050ec4268d749a1f898bec53e9fc287 Remember when we created the multisig address one of the values that was returned was something called the “redeemScript”? Hopefully you copied and pasted that somewhere because we’ll need that to create our raw transaction as well. This also is used to verify that the transaction is valid and can thus be passed around by nodes when it is broadcasted to the network. OK, here comes the most confusing part coding-wise; we’re going to do some relatively low-level bitcoin operations that are what is actually going on when you send coins from one address to another, though with the added complication of using a multisig address. We’re going to use the transaction hash, the index in the vout array we just found, the scriptPubKey, the redeemScript, as well as a bitcoin address which will receive a certain amount of coins we specify. Enter the following into the Terminal exactly as I have written, replacing with the transaction hash, with 1, with the scriptPubKey, with the redeemScript, with the address you want to send these bitcoins to (I used one of the three I created at the start), and (you guessed it) with the amount you want to send. Don't forget to account for a roughly 0.0001 transaction fee. Be warned that the warnings you’ll get are not very descriptive, so make sure you follow this layout exactly. $> bitcoind createrawtransaction '[{\"txid”:” \",\"vout”: ,\"scriptPubKey”:” \"}]' ‘{“ }'’ 01000000016bab25b998c84634e0b977b43fa56ce1da473ae14f98a065b59e9075c69fc20a0100000000ffffffff0160fd0100000000001976a9145eed147e77af70c64c31c056c3b3474c79c65da088ac00000000 That command just returned a raw hex-encoded transaction, this is the collection of bytes that bitcoin clients broadcast to the network, and which contain the information necessary to verify that the outputs being used as input in the transaction are valid. But right now this transaction is NOT valid, because it has not been signed by at least two of the private keys that are associated with this multisig address. Let’s do that now. We’re going to take this raw hex transaction, most of the information we just entered in the previous command, and the private key of the first address we created and sign the transaction. The command looks like this, where you’ll replace with the output of the previous command, and with the private key of the first address we created (remember, the one we obtained by running “bitcoind dumprivkey ”?) $> bitcoind signrawtransaction ‘ ' '[{\"txid”:” \",\"vout”: ,\"scriptPubKey”:” \"}]' ‘[“ ”]' { \"hex\" : \"01000000016bab25b998c84634e0b977b43fa56ce1da473ae14f98a065b59e9075c69fc20a01000000b500483045022100f98068a026e2fc75cfeffe84bbac4223ed172df42bca01fd748a14bd960b1695022062c61a7f4f2a63a65d96b0feaf2a048bc2ca93e5de13013978a187395f880b6d014c695221027ca87e1aa2595ec7771afee8fdc6efdbc301b8370c4386731b4bd82247dc74a321022cc9874ba092095dda47a4e4edb1781c43c35b3ec0429ac005df37b9d6eec94b21035739f07de25c205525d81b126ed87bc30377e688705072d186e4f5c88908ce3a53aeffffffff0160fd0100000000001976a9145eed147e77af70c64c31c056c3b3474c79c65da088ac00000000\", \"complete\" : false } You’ll note that the “complete” key is false. That’s because we’ve only provided one of the two signatures we need to make this a valid transaction. The value for “hex” is hexadecimal representation of the raw transaction we created, but with one signature included. Next we’re going to take the transaction with one signature and sign it with the private key of the second address we created. The Terminal command is very similar: $> bitcoind signrawtransaction ‘ ' '[{\"txid”:” \",\"vout”: ,\"scriptPubKey”:” \"}]' ‘[“ ”]' { \"hex\" : \"01000000016bab25b998c84634e0b977b43fa56ce1da473ae14f98a065b59e9075c69fc20a01000000fdfd0000483045022100f98068a026e2fc75cfeffe84bbac4223ed172df42bca01fd748a14bd960b1695022062c61a7f4f2a63a65d96b0feaf2a048bc2ca93e5de13013978a187395f880b6d0147304402201ce986e3fd780f4fe81f40ceb271a8ff34c3845e385b8424f8b20d1b91f1282102205dc71831baf5606f59d06b1d115bda3ec28817cdb4bf9df06643d550c30ef193014c695221027ca87e1aa2595ec7771afee8fdc6efdbc301b8370c4386731b4bd82247dc74a321022cc9874ba092095dda47a4e4edb1781c43c35b3ec0429ac005df37b9d6eec94b21035739f07de25c205525d81b126ed87bc30377e688705072d186e4f5c88908ce3a53aeffffffff0160fd0100000000001976a9145eed147e77af70c64c31c056c3b3474c79c65da088ac00000000\", \"complete\" : true } You’re probably happy to note that “complete” is now true. We now have only one more step! We’re going to take the output of this last command, which is a valid and fully signed transaction sending bitcoins from a multisig address to an address you specifying, and send it off using the “sendrawtransaction” command, like this $> bitcoind sendrawtransaction bc26380619a36e0ecbb5bae4eebf78d8fdef24ba5ed5fd040e7bff37311e180d And finally, this will return the transaction hash for the transaction you just sent out. That’s it! You can use blockchain.info to see that transaction on the network. Now you know how multisig addresses are created, how to send money to multisig addresses, and most importantly how to spend those bitcoins. Now please, go out and help make wallet software that implements multisig transactions in a user friendly way.",
      "Transcation in bitcoin are actually scripts, where normaly it states one input and one output address. But there are other op code such as CHECKMULTISIGVERIFY script. Each signing party will have their own public key hence their own address. The way it works is as shown: N K1 K2 K3 M CHECKMULTISIGVERIFY Where : -N is the number of signature to continue -K1, K2, K3 The actual 3 public key -M The number of public key you provided What the actual transaction does qould be set into the input script. See here for an example of a transaction with a third party."
    ]
  },
  {
    "question": "How does Satoshi Dice's 'zero confirmations' transaction system work technically?The popular bitcoin betting game Satoshi Dice sends back payments very fast, they don't wait for confirmations. The user sends money to Satoshi Dice and gets back winnings a couple of seconds later. Here's a quote from their site: The SatoshiDice Bitcoin game operates with zero confirmations [...] This is safe because it always builds the answering transaction with the output of your bet transaction. This means a blockchain that does not contain your bet cannot contain the site's answer. I think I understand the theory behind this: Satoshi Dice always sends back coins from your own bet. So if your bet doesn't get confirmed then your winnings also won't get confirmed. What I don't understand is how I could technically create these kind of transactions. Using bitcoind, how could one build these transactions? Thanks for your suggestions.",
    "answers": [
      "A transaction claims some outputs from previous transactions and then creates new outputs whose summed value is equal to (or less than, in the case of fees) the sum of the claimed outputs values. For a transaction to be valid it must be the only one that claims the outputs (no double spend) and the transaction that created the claimed outputs must be valid. Satoshi Dice can immediately send back a transaction containing the winnings because the transaction claims the output of the incoming transaction, chaining the two transactions together. The result is that either both transactions are valid, in which case the player gets his winnings, or the first transaction is not valid, immediately invalidating the second one, and Satoshi Dice is not tricked into sending coins back without receiving the wager.",
      "A transaction simply link an older output transaction and reasign it. You can send bitcoin you just reveice because you can link to the other transaction immediately. Then the transactions can be mined in the same block. The standard bitoin client doesn't let you spend unconfirmed bitcoin because it could let some create an attack."
    ]
  },
  {
    "question": "What's the difference between bitcoind and bitcoin-qt? Different commands?This is a multi-part question, mainly do to contradictory information from different articles. It's got me all confused. From my understanding, bitcoin-qt is just a GUI version of bitcoind - which was the original 'client' or 'node'. Is it true that bitcoind is actually built within bitcoin-qt, and runs in the background as a daemon (when the app is open)? When I first started bitcoin-qt, it started downloading the block-chain. After that, I was curious about setting up a pool server, so I sought out information about that. I ended up going through a tutorial on installing Eloipool - they informed me that I had to have bitcoind setup and running as a daemon. That was interesting, because I thought that it was already running through bitcoin-qt? This is where my confusion started. I even tried using the bitcoin-qt debug console; but it didn't have the same commands as bitcoind - specifically the rpc ones. Where does this leave me? Am I doing something wrong? If I shutdown bitcoin-qt and start bitcoind -daemon, then it starts downloading another block-chain. Do I really need both of these to make this work, or does the bitcoin-qt have access (somehow) to all the bitcoind commands? Does bitcoin-qt use bitcoin.conf, the same as bitcoind? The reason I ask this, is for setting up the rpcuser and rpcpassword, amongst other things. * UPDATE * I did some more reading, and found out that most people just use bitcoind for more serious stuff. Is there not a way to configure bitcoin-qt to use a currently running instance of bitcoind, instead of spawning it's own daemon (when GUI is open).",
    "answers": [
      "You can either run bitcoin-qt or bitcoind , not both at the same time (the Qt part is not just a frontend on top of the RPC code, it uses the core directly). You can however run Bitcoin-Qt with the -server command-line switch, in which case it will also expose an RPC service (essentially functioning like bitcoind in addition to the GUI interface). The RPC console inside the GUI has the exact same functionality as the bitcoind RPC client. PS: bitcoind is both an RPC server (when started without RPC command on the command-line) and an RPC client (when started with RPC command on the command-line), while Bitcoin-Qt only optionally runs an RPC server (when started with -server ). Update: In version 0.9, bitcoin-cli was added with just the RPC client functionality from bitcoind . In version 0.10, this functionality will be removed from bitcoind . This means that the following ways of interacting will be possible: bitcoin-cli or an external RPC client talking to bitcoind . bitcoin-cli or an external RPC client talking to bitcoin-qt -server . Using the RPC console in bitcoin-qt ."
    ]
  },
  {
    "question": "What is the format of the coinbase transaction?I'm trying to understand the format of the coinbase transaction. I've read that it is arbitrary and not specified. I'm wondering because I need to generate mining work and create an internal pool. As I've found out, you can change the ntime , nonce and extranonce fields. The last one should be suited in the coinbase parameter, right? So, can anyone help me analyze the content of the coinbase transaction and how am I supposed to build one, so all miners in my pool could have different headers for hashing? A step-by-step guide on an existing block would be much appreciated, links and other stuff too.",
    "answers": [
      "A coinbase transaction follows the same format as a normal transaction, except: It has exactly one txin This txin's prevout hash is 0000...0000. This txin's prevout index is 0xFFFFFFFF The txin's prevout script is an arbitrary byte array (it doesn't have to be a valid script, though this is commonly done anyway) of 2 to 100 bytes. It has to start with a correct push of the block height (see BIP34). The sum of the txout's values cannot exceed the subsidy (25 BTC for now, halves every 210000 blocks) plus the fees of the non-coinbase transactions in the same block. About the scriptSig being an arbitrary byte array, there is one caveat: the checksig operations in it are counted towards the block sigop limit (20000), so you probably don't want to accidentally trigger this. Making it a list of just push operations (including of the extranonce) avoids that.",
      "Look at block #280963 . Look at coinbase transaction d1c6b8...fd08 . You can see CoinBase data: 038349040d00456c69676975730052d8f72ffabe6d6dd991088decd13e658bbecc0b2b4c87306f637828917838c02a5d95d0e1bdff9b0400000000000000002f73733331312f00906b570400000000e4050000 This is a script. Look at wiki for details. In coinbase transaction this script can contain any data. If you change this data, merkle root will change as well, and diffirent miners can start changing nonce/timestamp for merlke root, that you provides for them. Look at wiki for more information about merkle tree. Coinbase transaction contains single input. This is input is not used, and it contains 32 bytes zeros as previous tx. Look at wiki for more information about what data transaction contains. I provide as example of decoding raw coinbase transaction. > getrawtransaction d1c6b8140246950475735394b0ac68f9ada60d313d2b5308afbc569c84f7fd08 < 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff53038349040d00456c69676975730052d8f72ffabe6d6dd991088decd13e658bbecc0b2b4c87306f637828917838c02a5d95d0e1bdff9b0400000000000000002f73733331312f00906b570400000000e4050000ffffffff01bf208795000000001976a9145399c3093d31e4b0af4be1215d59b857b861ad5d88ac00000000 01000000 - version 01 - input count 0000000000000000000000000000000000000000000000000000000000000000 - prev tx ffffffff - prev out n 53 - length of coinbase script 038349040d00456c69676975730052d8f72ffabe6d6dd991088decd13e658bbecc0b2b4c87306f637828917838c02a5d95d0e1bdff9b0400000000000000002f73733331312f00906b570400000000e4050000 - coinbase script ffffffff - sequence 01 - output count bf20879500000000 - 2508660927, satoshi count, or 25.08660927 BTC 19 - script length 76a9145399c3093d31e4b0af4be1215d59b857b861ad5d88ac - script 00000000 - locktime"
    ]
  },
  {
    "question": "How does the Kimoto Gravity Well regulate difficulty?Maxcoin will use the Kimoto Gravity Well (KGW) to regulate the difficulty. From what I could find about the KGW, it retargets after every block and adjusts very quickly, e.g. when multipools add and retract mining power to a smaller coin's network. Apparently, KGW = 1 + (0.7084 * (PastBlocksMass/144)^(-1.228)) ( -> Introductory post by Kimoto ) describes how to calculate the Kimoto Gravity Well. On another source, it was stated that \"KGW is applied if the hash rate is high, and 1/KGW when the hash rate is low\" ( -> Post on Catcoin's adoption of KGW ). This leaves me with three questions: What does PastBlocksMass refer to? Does KGW only rely on the time required to find the previous block? Why/How does the above formula produce the described fast adaptation of the difficulty?",
    "answers": [
      "The explanations on the web are all very vague and mystical, on purpose maybe. Here is my take in simple words, just reading the megacoin source code from the above comment. The goal is to have a more adaptive way of adjusting the difficulty instead of just averaging the last 2016 blocks like bitcoin. This is needed because of multipools which might switch the coin they are mining, and a sudden change in hashrate can occur (both increasing or decreasing). Especially when a multipool switches away you get stuck too long with a too high difficulty. The algo loops backwards through the blocks, starting from the current one. The PastBlocksMass is just the number of blocks, so it starts at one and increases in each loop. In each loop an adjustment factor is computed, which is the target block time divided by the actual block time, in a cumulative fashion, so at loop 10 we would have the 25 minutes target time divided by the time it actually took to compute the last ten blocks. When the hashrate increases, we get shorter times and an adjustment factor greater than one and vice versa. The loop ends whenever the average adjustment factor is larger than the kimoto-value , or smaller than 1/kimoto-value . To understand this look at this python script and an example plot: from pylab import * one_day = 1440 / 2.5 # how many 2.5 min blocks per day nmin = one_day / 4 # PastBlocksMin nmax = one_day * 7 # PastBlocksMax x = arange(nmin, nmax) # PastBlocksMass # start with 2.5 minute blocktime + some noise t0 = 2.5 + randn(nmax) / 4 t1 = 2.5 + randn(nmax) / 4 # t0 has 20% more hashrate, so shorter blocktime in the beginning t0[:one_day] = 2.5 / 1.2 + randn(one_day) / 4 # t1 has higher blocktime in the beginning t1[:one_day] = 2.5 / 0.9 + randn(one_day) / 4 s = arange(nmax) adjust0 = (arange(1, nmax + 1) * 2.5 ) / cumsum(t0) adjust1 = (arange(1, nmax + 1) * 2.5 ) / cumsum(t1) # the magic function def kimoto(x): return 1 + (0.7084 * pow((double(x)/double(144)), -1.228)); plot(x/one_day, kimoto(x)) plot(x/one_day, 1/kimoto(x)) plot(s/one_day, adjust0) plot(s/one_day, adjust1) legend([\"kimoto\",\"1/kimoto\", \"20% increase in hashrate\", \"10% drop in hashrate\"]) xlabel(\"days\") ylabel(\"adjustment factor (target/actual blocktime)\") show() The script produces a figure like this . It shows two constructed examples when the hashrate increases and when it drops for one day. Best is to play with different settings for a while to get a feel for what is going on. You see that the lines cross through the Kimoto formula at some point. This is when the algo exits and uses this adjustment factor to compute a new target/difficulty. For large adjustment factors this happens earlier than for the ones closer to one. This is to have a quick adaptation if the hashrate changes a lot, and a slower one if not - then we want a longer period to get a better average. The parameters of the Kimoto formula are adjusted in such a way that one roughly adjusts in one day to a 10% change and in seven days to a 1.2% change. A minimum of 144 blocks determine the new difficulty and at most 4032 (0.25 days or 7 days for a 2.5 minute blocktime). Summary: the Kimoto gravity well algo has a fancy name and determines the number of blocks which contribute to the evaluation of the new difficulty. It gives fewer blocks for high hashrate changes and is therefore more adaptive."
    ]
  },
  {
    "question": "What happens if your transaction is never confirmed?If I have a low amount and don't include a fee, the transaction takes forever to get confirmed. What happens if it never gets confirmed? Can the wallet that I sent it to still spend the money?",
    "answers": [
      "If a transaction goes unconfirmed for too long, it will eventually disappear from the network. Most clients will remove it from their pool of unconfirmed transactions at some point. When most clients have removed it, you can go ahead and send the transaction again, this time with a higher fee. There's not a precise time when the transaction will disappear from the network, it could be days or up to a week. This is why it's always recommended to set a transaction fee. The wallet that you sent it to cannot spend it because it's not confirmed. So you have to wait until it disappears from the network and send an entirely new transaction.",
      "Your client will have this marked as spent and will prevent you from sending any unspent coins included in the transaction while continuing to try to broadcast the original transaction. There is an easy solution, though. You simply need to dumpprivkey and add it to another client, where you can send the coins from this address to another, effectively creating a double-spend permanently nullifying the original transaction. Instructions on how to export and import private keys can be found here: Using dumpprivkey to make a paper backup Additionally, blockchain.info (and mtgox) allow you to import private keys which you can spend from your web wallet."
    ]
  },
  {
    "question": "How do I use walletnotify?I have bitcoin daemon and I want to use the walletnotify option with a json-rpc call. Some of the examples use a \"transaction.sh\" file for walletnotify . What is it for? What do I have to write in that sh file, to make walletnotify work for more than 6 confirmations.",
    "answers": [
      "First you must configure your bitcoin.conf file for JSON-RPC rpcallowip=127.0.0.1 rpcuser=yourusername rpcpassword=reallystrongpasswordthatsnothis rpcport=7788 walletnotify=/home/scripts/transaction.sh %s Where transaction.sh is some bash program. One approach is to have it make an http request to some process to notify you of the deposit. An example: #!/bin/sh curl -d \"txid=$1\" http://127.0.0.1/some/route walletnotify will execute transaction.sh every time you either receive bitcoin send bitcoin when a bitcoin gets its first confirmation %s is the transaction ID or txid which gets passed to transaction.sh .",
      "to complement Loourr's answer, %w can also be passed to your script, informing you of the wallet in the node that received the funds, since you may have > 1 wallet"
    ]
  },
  {
    "question": "What are the minimum and maximum lengths of a Mainnet Bitcoin address?I'm getting mixed answers on this question. For example, this source says addresses vary between 27 and 34 characters in length. The Wiki says 26-35 characters. Neither source cites something that will let me independently confirm the figures. What are the minimum and maximum lengths of a Bitcoin address on mainnet, and how are these numbers derived?",
    "answers": [
      "The wiki is correct! The source you linked must have assumed that the address with the smallest encoding has version_byte=00, data=20*00, checksum=94A00911 $ encodeBase58 00000000000000000000000000000000000000000094A00911 1111111111111111111114oLvT2 Which has length 27. This address is valid and has been used on the blockchain ! But it is not the shortest address. I wrote this short bash script to find the minimum length address. It found that there were a total of 266 address of length 26 . For anyone who is curious, these are the 266 addresses with length 26 . The maximum length address has version_byte=00, data=20*FF, checksum=FA06820B: $ encodeBase58 00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA06820B 1QLbz7JHiBTspS962RLKV8GndWFwi5j6Qr Which has length 34. This has also been used to receive coins, as can be seen here .",
      "The wiki says that A Bitcoin address is an identifier of 26-35 alphanumeric characters. This information is now outdated but it was true at the time this question was asked look at morsecoder's answer . With the introduction of Bech32 type addresses in 2017, the minimum and maximum length of a Bitcoin address have changed. According to BIP 173 : [Segwit] addresses are always between 14 and 74 characters long. Version 0 witness addresses are always 42 or 62 characters."
    ]
  },
  {
    "question": "Current FPGA CompetitivenessI know CPUs and GPUs can't really compete with ASICs anymore but what about FPGAs? Are they still reasonable? Anyone have a ballpark idea of what kind of Gh/s (or Mh/s) has been done with something like a Spartan 6?",
    "answers": [
      "First a bit of perspective on FPGA mining . ​ Around 2011 some miners started switching from GPUs to FPGAs, (Field Programmable Gate Arrays), after the first implementation of Bitcoin mining came out in Verilog , (a hardware design language that’s used to program FPGAs). The general rationale behind FPGAs is to try to get as close as possible to the performance of custom hardware while also allowing the owner of the card to customize it or reconfigure it \" in the field \". By contrast, custom hardware chips are designed in a factory and do the same thing forever. FPGAs offer better performance than graphics cards, particularly on “ bit fiddling ” operations which are trivial to specify on an FPGA. Cooling is also easier with FPGAs and, unlike GPUs, you can theoretically use nearly all of the transistors on the card for mining. Like with GPUs, you can pack many FPGAs together and drive them from one central unit, which is exactly what people began to do. Overall, it was possible to build a big array of FPGAs more neatly and cleanly than you could with graphics cards. Using an FPGA with a careful implementation, you might get up to a GH/s, or one billion hashes per second. This is certainly a large performance gain over CPUs and GPUs, but even if you had a hundred 141 boards together, each with a 1 GH/s throughput, it would still take you longer than 50 years on average to find a Bitcoin block at the current difficulty level. Despite the performance gain, the days of FPGA mining were quite limited. Firstly, they were being driven harder for Bitcoin mining — by being on all the time and overclocked — than consumer grade FPGAs were really designed for. Because of this, many people saw errors and malfunctions in their FPGAs as they were mining. It also turned out to be difficult to optimize the 32‐bit addition step which is critical in doing SHA‐256. FPGAs are also less accessible‐you can't buy them at most stores and there are fewer people who know how to program and set up an FPGA than a GPU. Most importantly though, even though FPGAs improved performance the cost‐per‐performance was only marginally improved over GPUs. This made FPGA mining was a rather short‐lived phenomenon. Whereas GPU mining dominated for about a year or so, the days of FPGA mining were far more limited — lasting only a few months before custom ASICs arrived. However- the cycle repeats itself . ​It’s worth noting that several smaller altcoins have indeed used a different puzzle than SHA‐256, but have seen a similar trajectory in mining as Bitcoin. For ASICs there is still a long lead time between designing a chip and shipping it, so if a new altcoin uses an new puzzle (even just a modified version of SHA‐256), this will buy some time in which ASICs are not yet available. Typically, mining will proceed just at Bitcoin did from CPUs to GPUs and/or FPGAs to ASICs (if the altcoin is very successful, like LiteCoin). Personally I'm quite interested in Zcash. Much of the content for this answer was drawn from this excellent resource ."
    ]
  },
  {
    "question": "Migration from Berkeley DB to LevelDBIn 2013 a new bitcoin core was released and one of the supposed improvement was migrating from Berkeley DB to LevelDB. According to the release notes at bitcoin.org : LevelDB, a fast, open-source, non-relational database from Google, is now used to store transaction and block indices. LevelDB works much better on machines with slow I/O and is faster in general . Similar statements were done by bitcoin core developers : LevelDB - an open-source rewrite of Google's own database system - was designed for efficiency and consistency on commodity hardware, and outperforms BDB by an order of magnitude in some settings. Preliminary tests with LevelDB show very good results . However, nowadays there are several comments through the internet critizing LevelDB. According to LevelDB page at Wikipedia : LevelDB is widely noted for being unreliable and databases it manages are prone to corruption. Academic studies of past versions of LevelDB have found that, under some file systems, the data stored in those versions of LevelDB might become inconsistent after a system crash or power failure. LevelDB corruption is so commonplace that corruption detection has to be built in to applications that use it. In summary, the complaints about LevelDB are: unreliable and databases are prone to corruption several bugs due to fundamental flaws poor code quality no longer actively maintained (i.e. dead project) Question 1 Are these complaints about LevelDB correct? Question 2 What is the final balance of migrating Bitcoin Core from Berkeley DB to LevelDB? Is LevelDB working as expected? This migration was the right choice?",
    "answers": [
      "As someone who was involved in doing that migration at the time, I believe it was the right decision. LevelDB is far from perfect, but I wouldn't know what else to use. In particular: BDB is much slower for our usage (large atomic batch writes, small random reads). There were reports of database corruption as well with BDB, at a time when it was used far less intensively than LevelDB is now. BDB is very painful to upgrade. My impression is that it was designed for setups where a database upgrade only happened with professional supervision. In particular, the write log files created for durability were sometimes not readable by later versions. This is the reason why Bitcoin Core releases have for years stuck with BDB 4.8 for the wallet. BDB has many resource limits that need configuration, where inappropriately chosen values may cause network-wide failures (read up on the March 2013 incident , specifically). The official documentation on this states Reviewing the Lock subsystem statistics is the best way to determine this value. I believe that's not acceptable for our use case. While database corruptions are reported relatively frequently these days, my belief is that it's mostly hardware failures or driver issues. Bitcoin Core tends to stress disks, memory and CPUs far more than most software, which makes otherwise invisible issues pop up."
    ]
  },
  {
    "question": "How does lost BTC affect the market in the long run?I bought some bitcoins in 2012 and forgot about it. Now years later I discovered that the company who maintained the wallet went bankrupt and their website no longer works. I therefore have lost access to my bitcoins forever. I assume my story is not the single case where this happened. As there is a limited amount of bitcoins, what will happen as more and more people lose access to their wallets with time? What would be the effect on the market?",
    "answers": [
      "The price of bitcoin is affected by demand and scarcity. Scarcity decreases as more bitcoin are mined (up until the 21 million bitcoin limit is reached---this is the maximum number that can ever be mined), which decreases the price. Scarcity increases as coins are lost (e.g. through the destruction of a wallet), or just held indefinitely (e.g. the ~1 million bitcoins of Satoshi Nakamoto that 'may' never get spent). Therefore, with demand staying above the number of coins available the price will continue to increase (as people are willing to pay more to be the one able to buy the coins, beating out the others also wanting to buy them). Now obviously if we look far ahead (assuming bitcoin survives long enough), there is the foreseeable problem that ultimately the number of bitcoins in circulation will decrease to the point that eventually one satoshi (0.00000001 BTC), the minimum value one can currently hold, will be worth more than a desired minimum, e.g. one could be worth $2000, limiting bitcoin's use to only larger transactions. Thankfully the number of decimal places in bitcoin isn't a hard limit, so this could be increased in the future such that it wouldn't matter if there were even only one bitcoin in the world.",
      "Most websites offering online wallets store your bitcoins against their own private key (giving them control over them), and provide you with tools to spend the bitcoins. While you don't have the private key, this means you don't really have bitcoins any more; instead, you have bitcoin-credits through the specific business you're dealing with. When such a business goes bankrupt, it's entirely likely the bitcoins were not just abandoned; they most likely would have been used to pay debt the business owed. ie Your bitcoins may well belong to someone else now. However, in the case where nobody has access to a private key any more, the bitcoins are essentially lost forever. In the long run this would, on average, be expected to raise the market price in proportion to the amount lost."
    ]
  },
  {
    "question": "51% attack - apparently very easy? refering to CZ's \"rollback btc chain\" - How to make sure such corruptible scenario can never happen so easily?I was shocked to see binance CZ comment to literally \"roll back\" the bitcoin chain by just \"calling\" in some favors from \"friendly\" Asian miners . This ONE person could effectively do it??? I mean are we all in a bubble, in some kind of utopia then, to think that the chain's decentralization makes it \"bulletproof\" and resistant to collusion by miners? (1) This is fundamental question: How are our highly regarded and brilliant Devs of bitcoin explaining such situation where only a handful of persons´ interests could essentially be enough to do a majority 51% attack? (2) And secondly, are there active debates about how to mitigate such situation in the future, what technical aspects implemented in the btc chain (or to be implemented) could be helpful? This huge mining farms are essentially very disturbing. it is like in proof of stake , where the \"richest\" has most power. And in the PoW mining case , its similiar just that the \"biggest hardware\" has most power. we have to try somehow to eliminate such easily corruptible scenarios , right? in todays digital world, there are plenty of collusion examples of even more than 1000 different persons involved. Handful of colluding majority miners would be a piece of cake, right? Thank you for explaining to me this issue . I hope sincerely that this is taken up by our awesome dev community, or maybe I am just misunderstanding everything.",
    "answers": [
      "Disclaimer: I believe this question may be primarily opinion-based and not very appropriate for this site, but there are a number of technical misunderstandings that can be clarified along with it, so I'll give it a shot. There are many nuances involved here, and I fear that a large part of them didn't reach as much of an audience as the exchange announcing \"we decided not to do it\". I believe this was a poor choice of words, as the decision they made wasn't whether or not to roll back the chain; only whether or not to offer a bounty for doing so. I personally believe it would be very unlikely that the alternative would have actually resulted in a deep rollback. Let's analyze the situation from a number of perspectives. If we only consider miner's actions, is it theoretically possible for them to roll back the chain? Yes. If you're wondering if there is a small number of mining company CEOs in the world, which, if all together convinced, with complete disregard for their own financial interests, the health of the network, or legal repercussions, could decide to roll back the chain to a point before the theft, the answer is yes. This is the reason why people care about mining decentralization, and permissionlessness of entering the mining market. However, unless it's not just a majority of the hash rate that is on board with this, but actually close to all the network's hashrate (a substantially harder problem, as there are many small miners in addition to the few big ones), this would likely have take days or even weeks (if it's close to 50%), a time during which many things can happen - including a public outcry and a UASF-style fork to prevent the rollback from being accepted by the ecosystem. If considered over an even bigger timescale, events like this may even incentivize people and businesses to become miners, in order to reduce the influence of large pools. Assuming miners maximize short-term profit, would it be financially interesting to rollback? No. Even if we assume that everyone in the network is acting selfishly to try to maximize their own (short-term) profit, and ignores the protocol rules and the possible repercussions from doing so, it is not. By the time the information about the theft became known, the transaction was already confirmed several hours before. During those hours, miners had created dozens of blocks, which together earned several hundred BTC in subsidy and fees. The exchange would need to offer at least that amount to the affected miners, to compensate them for the income they'd lose from rolling back those blocks, before it would even be worth discussing. Let's call this the rollback cost R . As the stolen amount was in the thousands (let's call this S ), that seems like a reasonable option. However, nothing prevents the thief from using (part of) the stolen funds to do the same. Every BTC offered by the exchange above R can be countered by an equivalent amount offered by the thief. And then it becomes clear that the thief has the upper hand: the exchange can at most gain S-R by a rollback, but the thief stands to gain S by not having a rollback. A theoretical possibility is a bidding war between the exchange and the thief, where both increase the amount paid to make miners act in their favor. The end game of this is that the exchange offers S-R , the thief offers slightly more and keeps R , and miners are paid S-R by the thief, and no rollback happens. What would happen in the real world? Theoretical models are interesting to study, but in reality many more practical considerations exist. I believe those too are generally in favor of no rollback: Coordination between distrusting miners (especially close 100% hashrate) is hard, and would take time. The more time it takes, the less advantageous a rollback becomes (see the above point), and the more damage would be done to the ecosystem (see the next point). An hours-long (in the very best case) or a weeks-long (in the worst case) rollback would monumentally hurt the ecosystem, and likely undermine the public's confidence in the system to the extent that it would severely reduce the profitability of many parties involved (including miners and the exchange itself!). Even ignoring all the above, miners may not be willing to take a bribe to rollback because of legal reasons if they're publicly known (which they mostly currently are). They may equally not want to take stolen money as a bribe, so this cuts in both directions. This point becomes weaker if the mining ecosystem is more decentralized, but that would also make coordination harder. As I pointed out above, in the extreme scenario where such a rollback is actually happening, the public has time to react. If a sufficiently large group of economically relevant parties in the network refuse to accept the rollback, miners have no choice but to go along with that. This is a last-resort option, and likely damaging to the ecosystem on its own, but it is an option. So to summarize: in theory there are absolutely ways in which a rollback could happen, and it's good to be aware of those. In reality, the security of the system relies on economic incentives already which are nontrivial to analyze. It however seems very unlikely that in the case of a theft a deep rollback is a reasonable outcome.",
      "(adding some color) Some discussion I saw suggested that people promoting this believed they only needed to achieve >50% hashpower, which caused them to overestimate the feasibility. Reorging with only slightly over 50% would take weeks-- even months, creating massive disruption if successful, and virtually guaranteeing an effective public initiative to block it. In such an event once the rollback began, users would advise each other to use the 'invalidateblock' debugging command to make their nodes ignore it. [I also had multiple users ask me to review patches ahead of the fork that would have blocked it, I told them I thought they were over-reacting and that this was a nothing burger. :)-- but a patch would only be needed before a fork existed, and clearly people were ready to start responding to this only on the basis of twitter chatter]"
    ]
  },
  {
    "question": "Is there a list of core Bitcoin committers?Where can I find a list of people that can commit directly to the github project ?",
    "answers": [
      "Here is a list of people who have had commit access to Bitcoin Core. This list can also be found on Bitcointalk and on Reddit (it's the same list just in two different places). All lists are kept up to date and in sync. This list contains the names and usernames of everyone who I can find evidence for ever having commit access to Bitcoin Core, the dates during which they had commit access, sources for all of this information, and reasoning for the access. Those who currently have commit access are in bold . Satoshi Nakamoto (satoshi, s_nakamoto): 2009-01-03 - 2011-09-13 ^[1] Creator, first Lead Maintainer Martii Malmi (Sirius, sirius_m): 2009-08-30 - 2011-09-13 ^[1][2] Creator of first SVN repo Laszlo (laszloh) 2010-08-04 - 2011-09-13 ^[1] Original OSX Builds and support Gavin Andresen (gavinandresen): 2010-10-11 - 2016-05-02 ^[3] Frequent contributor; later Lead Maintainer Chris Moore (dooglus): 2011-01-21 - 2011-03-31 Frequent contributor for some time; Still contributes occasionally Pieter Wuille (sipa): 2011-05-01 - 2022-07-07 Frequent contributor Jeff Garzik (jgarzik): 2011-05-06 - July/Aug 2016^[4] Frequent Contributor Wladimir J van der Laan (laanwj, wumpus): 2011-06-05 - present^[5] Frequent contributor; later Lead Maintainer Nils Schneider (tcatm): 2011-09-19 - 2012-05-31 Frequent contributor for some time Greg Maxwell (gmaxwell): 2012-02-11 - 2015-12-17 Frequent contributor; Gave up commit access due to toxicity and drama from the community Jonas Schnelli (jonasschnelli): 2015-11-13 - 2021-10-21 ^[6] Frequent contributor; given access after becoming GUI Maintainer; Stepped down for personal reasons. Marco Falke (MarcoFalke): 2016-04-13 - present^[7] Frequent Contributor; given access after becoming QA/Testing Maintainer Samuel Dobson (meshcollider): 2018-12-06 - 2021-12-09 ^[8] Frequent Contributor: given access after volunteering to be the Wallet Maintainer; Stepped down to focus on his PhD Michael Ford (fanquake): 2019-06-08 - present^[9] Frequent Contributor; given access after being nominated by several other frequent contributors and maintainers to become a maintainer. Hennadii Stepanov (hebasto): 2021-04-19 - present Frequent Contributor; given access after volunteering to help maintain the GUI Andrew Chow (achow101): 2021-12-20 - present^[10] Frequent Contributor; given access after volunteering to be the wallet maintainer. Gloria Zhao (glozow): 2022-07-07 - presentt^[11] Frequent contributor, given access after being nominated by several frequent contributors and maintainers to become a maintainer. Footnotes: [1] The move to Github occurred before the last SourceForge commit, but the last SourceForge commit declares sourceforge as dead. Presumably those who only committed to SourceForge no longer had commit access after the move [2] Sirius was the one who created the original SVN repo on SourceForge. [3] gavinandresen was the Lead Maintainer from 2011-02-23 until 2014-04-07 [4] I was informed via IRC PM by some of the Core devs that jgarzik was removed around August 2016 after he had been inactive for several months. [5] laanwj is the current Lead Maintainer. After participating in that role for a long time, he was officially given the position by gavinandresen on 2014-04-07 [6] jonasschnelli was the GUI Maintainer. After participating in that role for a long time, he was officially given the position by laanwj on 2015-11-13 . He stepped down for personal reasons . [7] MarcoFalke is currently the QA/Testing Maintainer. After participating in that role for a long time, he was officially given the position by laanwj on 2016-04-13 [8] meshcollider was the Wallet Maintainer. He had been contributing for a while, particularly to wallet related things. When laanwj asked if anyone would like to be the role of Wallet Maintainer, meshcollider volunteered. He stepped down to focus on his PhD. [9] fanquake is currently the Build System Maintainer as well as a general maintainer. He had been contributing for a while, particularly with updating dependency versions and build system related things. He also had been doing a lot of janitorial things in the repo such as tagging issues, closing old issues and PRs, nominating things to be merged, etc. At the CoreDev event in Amsterdam which several maintainers and contributors attended, he was nominated to be a maintainer by the entire group. [10] achow101 has contributed to the project for many years, especially in wallet and PSBT-related areas. After meshcollider stepped down from the Wallet Maintainer role, achow101 volunteered to take up the role. [11] glozow has contributed to the project for a few years, particularly in the mempool and node policy areas. She was nominated by fanquake to be a maintainer with focus in those areas. Other Notes: Dates are Year-Month-Day There may be people missing and dates may be slightly incorrect. These are all that I can determine by looking at old emails and the commit history. Please let me know if anything is incorrect The start date is determined by the first merge commit made by that person. The end date is determined by the date of the last merge commit made by that person or other announcements of commit access revocation. After scrolling through nearly the entire git merges history, I have found a couple of interesting things. Satoshi did not use a Version Control System originally. The releases and source code were originally in a rar file that was uploaded to bitcoin.org. Sirius had to setup the original SVN repository on SourceForge for him. This was then later migrated to GitHub by gavinandresen. Originally patches were authored by developers and then emailed to Satoshi, Sirius, or gavinandresen who then committed the changes to the source tree with the commit message containing the attribution, but not the actual commit itself. Another interesting fact is that the giving out of commit access has become more strict. It is now a privilege held by those given maintainer positions and those whose privilege was grandfathered in (i.e. they had it previously and kept it, until otherwise revoked). Previously it was simply given out to those who contributed frequently and revoked after they stopped contributing. This appears to be no longer the case, although there are still multiple people who can commit to the repository so that there is not any reliance on one person. The maintainers are still given to frequent contributors as the maintainers are frequent contributors to the set of functionality for which they are maintainers of. They received the positions because of frequent contributions to those functionalities. Of those whose commit access was grandfathered, only Pieter Wuille remains - the rest were revoked eventually primarily for the lack of contributions (see each individual for their specific reason). Lastly, I could not find any evidence for Satoshi ever publicly announcing that gavinandresen was to be the Lead Maintainer after him. It seems that Gavin was already a frequent contributor and already had commit access for a while before Satoshi disappeared. After Satoshi disappeared and Sirius stopped contributing as much, gavinandresen simply took over the role as lead maintainer as he was the only frequent contributor with commit access.",
      "There is a incomplete list in the wiki . Sadly, the list of people who have push access to the GitHub repository is not public viewable. Core developers are listed on Bitcoin.org in terms of number of commits."
    ]
  },
  {
    "question": "How can I contribute to the open source Bitcoin project?Generally speaking, how can: A) A programmer contribute to Bitcoin? B) A non-programmer contribute to Bitcoin? Essentially; which areas are in most need of programming work / non-programming work?",
    "answers": [
      "As a Programmer You can contribute by acquiring the bitcoin source code at github . Fixing bugs, adding features and creating a \"pull request\". Here are guidelines for creating pull requests . Gavin Andresen, currently the lead developer of bitcoin, has suggested that testing is a bottleneck, so it would be helpful to compile the existing pull requests on github and test them. It should be noted that it is possible to safely test bitcoin transactions without using real bitcoins by using the testnet (see the -testnet command line option). You can even create your own self-contained testnet-in-a-box . As a Non-Programmer Learn more about bitcoin. Try using them. Learn proper ways to secure them. When you become better versed in bitcoin technology help by explaining it to others. If you have a business, experiment with accepting bitcoin. If you are a customer, ask if a business accepts bitcoin. Help to dispel the myths and misunderstandings of bitcoin whenever you talk about them. However, be careful to get your facts straight. If you have talents in other areas such as design, business, or blogging, etc. then look for ways to contribute using those skills. It has been suggested that the client needs better interface designs, businesses have expressed interest in advice on bitcoins, blogging can help address all the misinformation and rhetoric. Everyone has something they could contribute, so give it a try.",
      "Developers Join one of the many bitcoin library projects on Google Code or Github: Multibit A Java based front end client BitCoinJ A Java based support library to make developing Bitcoin based applications much easier BitCoinSharp A C# based support library (sister project to BitCoinJ) Marketers Spread the word about Bitcoin to others. Download a copy of one of the many wallet applications to your phone and demonstrate using it to buy something from someone. Speculators Spend some of your coins to encourage merchants to adopt Bitcoin. Goods and services will be encouraged by demand. So buy stuff you need on a daily basis using bitcoins."
    ]
  },
  {
    "question": "Are there any fundamental security vulnerabilities in Bitcoin?Although Bitcoin does its best to prevent double-spending, could it still happen in practice? Is it just very unlikely that fraud could happen, or is there a mathematical proof that it could never happen?",
    "answers": [
      "As David Schwartz said in 367 ; Dan Kaminsky has spent some time auditing the Bitcoin core . He is a respected security professional, and his opinion on these matters is highly regarded. He came to the conclusion that there weren't any concerning security vulnerabilities, but scalability is something that will have to be tackled as the project grows. Essentially; nothing the developers didn't already know about.",
      "The only known fundamental vulnerabilities are double-spending and 51% attacks, which are closely related. It doesn't seem likely that there are any significant unknown fundamental vulnerabilities, though of course there could be exploitable bugs in the client. (The underlying algorithms will get weaker over time, but that's not a problem.) Double-spending can definitely happen. If someone controlled 51% of the network's hashing power, they could double spend at will. How much you actually have to worry about that is a tough question though. A deeper question is whether these problems are truly fundamental or whether they could be worked around without changing the fundamentals of Bitcoin. To my knowledge, these are open research questions. Proposals have been made to reduce the impact of the 51% attack, but they introduce their own vulnerabilities that while harder to exploit have even more disastrous consequences (such as network states that are inconsistent, persistent, and require manual intervention -- and perhaps a de facto central authority -- to resolve). You can argue that with some of these suggestions, it's not Bitcoin anymore."
    ]
  },
  {
    "question": "Hardware Bitcoins (Smartcards, RFID etc.)is it possible to create a real hardware Bitcoin, e.g. a specified (and verifiable) value which is stored on a smart card or RFID which can be given directly to other people?",
    "answers": [
      "It's certainly possible. The card would basically need four functions: add/generate account, add bitcoins, prove bitcoins, spend bitcoins. The card could piggyback on external smart systems so the card doesn't need to do very much. Each function would be implemented as follows: Add Account : An ECDSA private key would either be randomly generated by the card or loaded from an external source. The card would add the key to its store of keys. This would be a secure operation that would require the card's internal key to perform. Add Bitcoins : A list of transaction identifiers and output indexes would be loaded into the card. This would also be a secure operation. Prove Bitcoins : This operation would prove the ability of the card holder to spend a particular number of Bitcoins. An external device specifies a number of Bitcoins to prove. If desired, approval is sought from the card holder via a PIN or similar mechanism. The card then forms a transaction to pay that number of Bitcoins but damages it so the transaction is invalid (for example, it adds a single transaction input for a billion Bitcoins). Then it signs it. The recipient, seeing the invalid transaction signed knows the card holder could have signed the corresponding valid transaction. (If desired, a challenge can be included to prove the signed transaction was generated on the spot.) Spend Bitcoins : This is the same as the prove Bitcoins operation except the transaction is valid, the recipient commits the transaction to the block chain, and the card updates its memory to reflect that the coins are spent. The only other thing you might need is a 'sync' operation where the card fixes any discrepancies. For example, if a spend operation is done but for some reason it doesn't make it into the block chain, the card needs to know that it still holds those Bitcoins. (And can't spend the 'change' from that transaction.) This is a minimal implementation. You can certainly add more capabilities.",
      "http://smartcardwallet.org/ claims to have a system where the wallet is stored on a smart card. A custom client is needed to access the wallet, but they say all software is open source."
    ]
  },
  {
    "question": "What does the Bitcoin client do when it receives conflicting transactions?I've been assuming that the second transaction will simply be discarded as invalid, while the first waits at 0/unconfirmed until it actually gets into a block (requiring a \"-rescan\" or similar if the second one actually ends up in the blockchain instead). But is this the case? What actually happens in the default client when two conflicting transactions are received? For simplicity's sake assume the person running the client is the recipient of at least one of the transactions, and is not mining.",
    "answers": [
      "I can't speak for what it does every time but I just tested Mr. Schwartz's comment, so I can speak for what it did this one time. I remote controlled a geographically distant machine running an identical copy of Bitcoin on it and my local PC (with identical wallets). I sent identical conflicting transactions for my entire balance within a few milliseconds of each other (atomic clock sync & timers - don't ask) and just as expected, both transactions showed in both clients at 0/unconfirmed and only one made it into a block. The other disappeared after a -rescan Curiously, after the -rescan the second transaction doesn't even show in a bitcoind listtransactions dump which seems odd to me. It seems like such erroneous transactions should be recorded and marked with a special status, similar to how orphaned block rewards are - this is an accounting system after all and under certain circumstances this could be \"destroying evidence.\" I'll make a comment next time I'm on GitHub and see if someone bites."
    ]
  },
  {
    "question": "Is the NotHaus conviction (Liberty Dollar) relevant as legal precedent?Bernard von NotHaus (the creator of the Liberty Dollar ) was convicted of violating a U.S. federal law that forbids the minting of a currency by anyone in the U.S. besides the federal government. Might it be claimed that bitcoins are also a currency and their users or creators violate that same law?",
    "answers": [
      "There are many complementary currencies in use around the United States quite openly and without government interference, including BerkShares, Ithaca Dollars and similar hyper-local currencies, various bartering or time swapping systems like LETS or Time Dollars, etc. The case you are referring to revolved around minting coins that could easily be confused with US money and allegedly circulating (and encouraging others to do so) to local businesses while passing them off as US money (by a lie of omission, if nothing else). It may well be that Bitcoin faces legal challenges in various countries, including the US, but this particular case will have set no precedent in that regard.",
      "The convictions, currently under appeal, are for making coins resembling and similar to United States coins issuing, passing, selling, and possessing Liberty Dollar coins issuing and passing Liberty Dollar coins intended for use as current money conspiracy against the United States The essenges of bitcoin is a cryptographically signed message and therefore bears no resemblance to United States coins. The Casascius physical bitcoin and Bitbills are the closest things and nowhere do they come close to a U.S. coin. The Bitcoin medals / silver 1 ounce rounds at My Bitcoin Mint or MJB Monetary Metals are simply silver commodities no different than the thousands of other silver medals and rounds produced. There are private currencies in use in certain locales. Berkshares in Massachusetts and Potomac currency near D.C. even, for instance. Their issuance has been left unchallenged. So far, there has been no determination as to what Bitcoin is. Is it a commodity? A foreign exchange currency? A stored value (regulated under the definition of prepaid access?) But there is little association between Bitcoin and a U.S. coin."
    ]
  },
  {
    "question": "Is there a way to provide the walletpassphrase to bitcoind without exposing it on the cmdline?With bitcoin 0.4.0 I have encrypted my wallet. Now when I would want to use bitcoind, the only way to send money is to provide my wallet decryption key on the cmd line first. I do not want to do that as my password will show up in the shell history. Is there a way to let bitcoind ask for the wallet passphrase?",
    "answers": [
      "Anything you can do from the command line you can also do from the JSON API which means that the same unlock command could be sent from within code just as easily. To my knowledge there is no pre-built utility capable of this, but the API is simple enough that I can't imagine it being terribly difficult to actually build such a tool. Edit: It was much easier than expected to do this in Python. Assuming you have Python's JSON-RPC module installed just use this code: from jsonrpc import ServiceProxy from getpass import getpass access = ServiceProxy(\"http://127.0.0.1:8332\") pwd = getpass(\"Enter wallet passphrase: \") access.walletpassphrase(pwd, 60) Similarly you could call access.walletlock() to lock the wallet on demand and walletpassphrasechange(old, new) to change the passphrase without ever having it see the command line. Edit 2: I also submitted an issue to the devs on github on your behalf. Edit 3: A pull request containing my python scripts has been accepted. Downloading the bitcoin source from github now includes scripts for this purpose in contrib/wallettools Edit 4: A new bug report was filed to request that the builtin command behaves properly.",
      "You can avoid having the password show up in the shell history like this: $ read x password goes here $ bitcoind walletpassphrase \"$x\" 60 $ x= $ The read x command reads the next line of text you type and puts it into a shell variable x . The x= command overwrites the shell variable; otherwise $x will hold your password until you exit the current shell. It shows up in the history like this: 2032 read x 2033 bitcoind walletpassphrase \"$x\" 60 2034 x= 2035 history I expect the password will show up in /proc/ while the bitcoind command is running, but that should be only for a fraction of a second."
    ]
  },
  {
    "question": "Gaming the \"off-by-one\" bug (difficulty re-target based on 2015 instead of 2016 block time span)?In this forum post from Gavin Andresen he writes: Second: I've written 'discourage blocks' infrastructure: https://github.com/gavinandresen/bitcoin-git/tree/discourageblocks (code reviews welcome) ... which should give us the ability to nudge miners to Do The Right Thing. Discouraging blocks that appear to be gaming the off-by-one bug should be enough incentive to prevent 50+% cartels from forming, without requiring a blockchain-splitting change. I believe the off-by-one bug refers to the difficulty re-target being based on the time taken for the previous 2015 blocks instead of 2016 blocks - please correct me if I'm wrong. What I want to know is how can this bug be gamed by miners? What can they do and what advantage does it give them?",
    "answers": [
      "The attack allows a group of miners with more than 50% of the network's computational power to change difficulty arbitrarily. When difficulty is adjusted, only the times of the first and last blocks in a retarget period (i.e., the first and last blocks with a certain difficulty) are considered. This attack works by manipulating the timestamp of one of these two blocks. Blocks are considered valid if their time is greater than the median of the last 11 blocks and less than currentTime + 2 hours, so it's legal for an attacker to create a new version of an old block with a time far in the future. If this is the first block in a retarget period, then the difficulty will quadruple after that period. If it's the last block, then the difficulty will be divided by four. (Difficulty adjustments are limited to *4 or /4.) Note that it is not possible to do these major changes with recent blocks because the time would be more than two hours in the future. It needs to be done with historical blocks, and then the attacker needs to re-do all blocks that come after that block. So this attack is only possible when you have a lot more computational power than the legitimate network. This would not be as big of a problem if there was a block of overlap between the retarget periods. Instead of using the first and last block in a retarget period, use the last block of the old difficulty and the last block of the new difficulty. Then the attacker will still be able to mess with one retarget period, but it will be corrected in the next retarget period. I think a better solution would be to look at every block in a retarget period plus maybe some blocks before the period. It just seems like a bad idea to give certain blocks \"special powers\". A discouraged block is considered valid (it adds confirmations to transactions, blocks after it will also be valid, etc.), but your node refuses to relay it or build future blocks onto it. If most of the network is discouraging a block, then it will almost certainly be replaced. Even a minority discouraging a block will hurt the block's chances. It is very unprofitable for a miner to discourage a block when most of the network is not, though. (Thanks to gmaxwell for explaining this attack to me.)"
    ]
  },
  {
    "question": "What is the maximum size of a transaction?I see from the source code (script.cpp) that there is an upper limit in the script size. It there any other limit to avoid a single transaction preventing other transactions of smaller sizes to get into a block? How is this kind of attack prevented? I've read in CTransaction::AcceptToMemoryPool the line: if .... ::GetSerializeSize(*this, SER_NETWORK) < 100) return error(\"...\"); Does this line means that the maximum transaction size is 100 bytes?",
    "answers": [
      "The maximum transaction size is the size of the block. Source . // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability) if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT) return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\"); Transactions larger than 100 kilobytes (including witness at a 75% discount rate) are non-standard. Source 1 . Source 2 . static const unsigned int MAX_STANDARD_TX_WEIGHT = 400000; ... if (sz >= MAX_STANDARD_TX_WEIGHT) { LogPrint(BCLog::MEMPOOL, \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString()); return false; }",
      "If there is a max transaction size it is much higher than 100 bytes. Not sure what that snippet is refering to but the average transaction is closer to ~300 bytes looking at the average # of transactions and block size for last 1000 blocks. What limits transaction size is cost. As transaction size (of all transactions awaiting next block) increases the min required fee increases non-linearly. 0.01 BTC fee per kilobyte of transaction, but: If the blocksize (size of all transactions currently waiting to be included in a block) is less than 27 kB, transactions are free. If the blocksize is more than 250 kB, transactions get increasingly more expensive as the blocksize approaches the limit of 500 kB. Sending a transaction when the blocksize is 400 kB will cost 5 times the normal amount; sending when it's 499 kB will cost 500x, etc. https://en.bitcoin.it/wiki/Transaction_fees So you could make a 500KB transaction but the required minimum fee would be 5BTC. The developers have indicated they intend to change transaction fee rules in the future but given block space is a valuable commodity any new rules are likely to be constructed to encourage (via larger fees) smaller transaction sizes."
    ]
  },
  {
    "question": "Why does the length of a bitcoin key vary?Why does the length of a bitcoin key vary? Why aren't they all the same length?",
    "answers": [
      "The length of a key doesn't vary. Private keys are always 32 bytes, and public keys are always 65 bytes (or 33 bytes for a compressed public key). Public key hashes are always 20 bytes. The length of addresses vary because in Bitcoin's base58 encoding, leading zero bytes are expressed as a single \"1\". Other bytes require more than one character in order to be expressed in base58.",
      "Private keys are 256 bit numbers Public keys are a pair of X,Y coordinates. Each coordinate is a 256 bit number. BUT for every X coordinate there are only two possible Y coordinates (one positive, one negative) so you can store a public key as just the X coordinate (256 bits) and the sign of the Y coordinate (1 bit) and the proper Y coordinate can then be calculated from the X coordinate and the sign. So private key = 256 bits, public key = 2*256=512 bits OR 256+1=257 bits Then there is a small amount of formatting overhead of a few bits. Then these are encoded."
    ]
  },
  {
    "question": "What function does Mt. Gox's \"Open Transaction\" withdrawal option perform?When withdrawing bitcoins from Mt. Gox, there is an option with a checkbox next to it titled \"Open Transaction (6 confirmations)\". What does this do to my withdrawal? I'm thinking this is probably a mislabeling for an option that ensures that even if the receiving address is for another customer account at Mt. Gox that the transaction will be sent through the blockchain. Otherwise, if those transactions are handled internally without appearing on the blockchain then it is difficult to prove that a bitcoin payment was sent.",
    "answers": [
      "I just asked on the #mtgox IRC channel, and was told: 06:36 < dooglus> what does the \"Open Transaction (6 Confirmations)\" option do when withdrawing BTC? 06:48 < Cory> If the Bitcoin address you're withdrawing to is a MtGox address, it will use the network and blockchain anyway. 06:49 < Cory> Otherwise, if that option is not checked, they will only internally transfer the funds. 06:53 <@MagicalTux> and instantly So there you have it. I suggested they should label it differently: 07:13 < dooglus> it would be better to use some different text for that option - like \"use bitcoin network even for transfers to mtgox deposit addresses\" for instance 07:19 <@MagicalTux> dooglus: it use to be something like that, but people were complaining it was not clear enough"
    ]
  },
  {
    "question": "What is Bitcoin?I'm a programmer, and a generally smart person, but I can't understand really what bitcoin is. Is it a new payment merchant like PayPal? Is it a virtual currency like LindenDollars that can't be really used as money? (put money In, but not Out) Is it a new currency system, where people exchange bitcoin addresses instead of real money?",
    "answers": [
      "Is it a new payment merchant like PayPal? No. PayPal is a company, Bitcoin isn't. PayPal deals with existing currencies like US dollars, Bitcoin doesn't. PayPal holds your balance for you, can freeze your account and can stop you from sending your money to people it doesn't like. With Bitcoin, nobody can freeze your account or tell you how to spend your bitcoins. Is it a virtual currency like LindenDollars that can't be really used as money? (put money In, but not Out) Whether it is a currency or not isn't clear, but it is virtual. Some say it's more like a commodity than a currency. It acts a lot like gold, in that there is a finite supply of it, it's valued by some people, and it can be used as money anywhere that accepts it. Also, it can be bought and sold for US dollars and many other currencies. At the time of writing 1 bitcoin is worth 470 USD, and there are plenty of people willing to buy them from you at just under that price or sell them to you at just over that price. The price is decided by the market . The price bitcoin trades at is the one people think it is currently worth. Is it a new currency system, where people exchange bitcoin addresses instead of real money? It acts a lot like a currency and can be used to trade with anyone who accepts it. It is very cheap to transfer between any two points in the world, and very fast compared to transferring US dollars or other currencies. See this introductory video for a slicker introduction.",
      "It's a distributed digital cryptocurrency. The key word here is distributed, i.e. there is no central authority, instead transactions are handled peer-to-peer with a complex protocol where everyone ensures no one cheats. New bitcoins are created at a predetermined rate to people who run \"miners\", which are a vital part of the protocol that checks for transaction genuinity. You can exchange bitcoins with other hard currencies using public exchanges such as Mt. Gox . You exchange them with other people willing to sell or buy them, just like on a stock exchange. For more details: http://www.weusecoins.com"
    ]
  },
  {
    "question": "How can I create a multi signature 2-of-3 transaction?Can somebody help me with step-by-step list of how to create a multi signature 2-of-3 transaction?",
    "answers": [
      "Actually, both receiving funds at and spending funds from a multi-sig address is already supported. You can find the code to do so, plus comments, by Gavin: TwoOfThree.sh",
      "It seems some partial implementation exists. Quoting Gavin : Generate a multisig address: Gather (or generate) 3 bitcoin addresses, on whichever machines will be participating, using getnewaddress or getaccountaddress RPC commands (or copy and paste from the GUI). Get their public keys using the validateaddress RPC command 3 times. Then create a 2-of-3 multisig address using addmultisigaddress ; e.g. bitcoind addmultisigaddress 2 '[\"044322868cb17d64dcc22185ae2d4493111d73244c3668f8ac79ecc79c0ba8d30a6756d0fa20157 709af3281cc721c7f53321a8cabda29b77900b7e4fe0174b114\",\"..second pubkey..\",\"..third pubkey..\"]' addmultisigaddress returns the multisignature address. Be a little careful, the public keys are raw hexadecimal and don't contain checksums like bitcoin addresses do. You can then send funds into that 2-of-3 transaction using the normal sendtoaddress/sendmany RPC commands, or the GUI (or anything that's been updated to recognize multisig addresses). Spend from a multisig address: This isn't implemented yet (RPC calls mechanism). You could gather up all addresses into one wallet, and then you would be able to spend the funds. Update March 2014 Multisig is still hard. I believe the SX library is an easy tool (by people like Vitalik Buterin and Amir Taaki) for working with multisig, but I haven't tested that myself."
    ]
  },
  {
    "question": "Is it possible to cancel an unconfirmed transaction?If you submit a transaction to the network but it hasn't yet be confirmed by a block, is it possible to cancel this transaction?",
    "answers": [
      "Bitcoin-Qt doesn't support anything like that. Theoretically: A transaction is canceled by publishing a second transaction which double-spends some of the coins used in the first transaction (this can be a send-to-self). If the second transaction is included in a block before the first one, the first one becomes invalid and can be considered fully cancelled after the second transaction receives 6 confirmations. It's normally not easy to do this. Network nodes won't accept transactions which double-spend coins used in a transaction they already know about. However, nodes gradually forget about transactions if they don't get into blocks, so a transaction could be cancelled if it doesn't make it into a block after several days and both the sender and recipient stop rebroadcasting it. Bitcoin used to have a feature called transaction replacement. A transaction could be marked as non-final, which prevented this transaction from getting into a block, but allowed the transaction to be cancelled at any time. Satoshi disabled this a while ago, though. Transactions can still be marked as non-final, but they can't be replaced.",
      "From the help of the console : abandontransaction \"txid\" That will tag the transaction as abandonned \"abandoned\": true After that, you can reselect the input(s) to send it with higher fees Tested in bitcoin core 0.12.1"
    ]
  },
  {
    "question": "When was block 210000 generated and who solved it?When was block 210000, the first block to feature halved 25BTC reward, generated and who solved it?",
    "answers": [
      "According to blockchain.info , the block 210000 was solved on 2012-11-28 15:24:38 GMT, and was relayed by Slush's Pool. The pool's Stats page also claims to have solved that block. It has also been stated that the block was solved by pool's user by the nickname of laughingbear."
    ]
  },
  {
    "question": "What is Ripple and how does it compare to Bitcoin?What is Ripple , and how does the system compare to Bitcoin?",
    "answers": [
      "This is answered in the official wiki : Like Bitcoin: ripple is a distributed peer-to-peer payment network ripple transactions are irreversible, sent over the Internet, and counterfeit proof ripple uses the same underlying cryptography as Bitcoin ripple has multi-signature support ripple has low to no transaction fees ripple servers can be run by anyone Unlike Bitcoin: ripple can send any currency ripple can automatically exchange currencies ripple transactions are fully confirmed in seconds ripple allows nicknames and gravatar icons for accounts ripple's reference client is a Firefox and Chrome add on ripple has no block chain download, clients are ready in seconds ripple has no mining or direct monetary reward for running a ripple server ripple has no currency risk as people can hold whatever fiat they want ripple solves the double spending problem with consensus instead of proof-of-work",
      "Ripple is trying to replace SWIFT, the protocol for inter-bank transfers. To me it makes sense because, those systems are (according to my understanding) quite antiquated. So blockchain hype has provided the impetus for banks to consider trying something new such as Ripple. It was started by the guy who created MtGox. Bitcoin is a mechanism for exchanging value online between any two (or more) persons who have accounts and something to trade."
    ]
  },
  {
    "question": "Are Bitcoin transactions permitted to have no outputs (i.e. all inputs become transaction fee)?I am interested in the possible use of the Bitcoin (or other altcoin) blockchain as a generalized distributed ledger, meaning that it is useful for tracking information other than coin transactions proper. A prerequisite for that would seem to be the ability to pay for transactions whose primary purpose is not moving Bitcoins from one address to another. So, can Bitcoin transactions list no outputs, thus leaving all inputs as a transaction fee reward for the miner?",
    "answers": [
      "No. If you create one, it won't be relayed or mined by Bitcoin Core. If it gets into a block, it will be rejected. From the source code for Bitcoin Core ( tx_verify.cpp:164 ): if (tx.vout.empty()) return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\"); However, you can create a vout with 0 satoshis. That isn't a \"standard\" transaction, so it will not be mined by the software by default. However, if it gets into a block, it's valid. There is another way you could do it. Using the OP_RETURN opcode. OP_RETURN in a transaction output forces anyone referencing that output to fail spending it(the script returns and transaction is invalid). Although the output exists, it is provably unspendable ."
    ]
  },
  {
    "question": "Ubuntu Linux -- How do I start bitcoind as a service to run automatically?I've got a bunch of other services set up to boot automatically when my Ubuntu server starts (services like wicd-daemon and VPN), but I can't figure out how to set up the bitcoin daemon (bitcoind) to start automatically when the system boots up. (This is on a headless system with no GUI or attached monitor.) I'm trying to learn how to integrate bitcoin with Python so I can write bitcoin-enabled services, but I want the system to automatically start bitcoind when the system boots so that I don't have to do it manually. (It's a pain in the butt to have to download a whole bunch of block-chain at once. It eats away at uptime.) If this question has already been asked, please direct me to the answer. I searched but couldn't find it. Otherwise, please help me figure this out! Thanks so much.",
    "answers": [
      "EDIT : Caveat emptor on Ubuntu distributions from 14.10 and forward - init was chosen over upstart and is being phased in the future . I don't know when that will be done nor what impact it will have on upstart scripts. Extract from the page RentFree refers to ; note that it assumes that you have created a user called bitcoinuser for the sake of security: For those running ubuntu, you may be familiar with upstart , a replacement for sysvinit style booting ( /etc/init.d/* ). Configuration files for upstart are stored under /etc/init/*.conf . I've written the following one for bitcoind: description \"bitcoind\" start on filesystem stop on runlevel [!2345] oom score -500 expect fork respawn respawn limit 10 60 # 10 times in 60 seconds script user=bitcoinuser home=/home/$user cmd=$home/bin/bitcoind pidfile=$home/bitcoind.pid # Don't change anything below here unless you know what you're doing [[ -e $pidfile && ! -d \"/proc/$(cat $pidfile)\" ]] && rm $pidfile [[ -e $pidfile && \"$(cat /proc/$(cat $pidfile)/cmdline)\" != $cmd* ]] && rm $pidfile exec start-stop-daemon --start -c $user --chdir $home --pidfile $pidfile --startas $cmd -b -m end script Put the above configuration in /etc/init/bitcoind.conf , then run sudo initctl reload-configuration . To start bitcoind , run sudo start bitcoind . To stop bitcoind , run sudo stop bitcoind . You'll probably want to change the user , cmd and pidfile to something that matches your configuration, or you can use the following as a template: /home/bitcoinuser /home/bitcoinuser/bitcoind.pid /home/bitcoinuser/bin/bitcoind Though one user suggests the following correction to the configuration: home=/home/$user cmd=/usr/bin/bitcoind pidfile=$home/.bitcoin/bitcoind.pid and another suggests setting nice for the process so it doesn't hog the CPU exec start-stop-daemon --start -c $user --chdir $home --pidfile $pidfile --startas $cmd -b --nicelevel 15 -m",
      "There's an upstart script for Ubuntu in the Bitcoin Core source tree. Using that is the most correct way. However, I just login as the user account I want to run Bitcoin Core daemon, start a terminal (if I'm in the GUI), and run the following command to edit my crontab: crontab -e Then I add the following line: @reboot bitcoind -daemon Save the file and exit. Now every time the computer boots up, Bitcoin Core daemon will be started. On shutdown, init/upstart/systemd/whatever will send it a SIGTERM signal, which bitcoind will catch and interpret as the command to start a safe shutdown."
    ]
  },
  {
    "question": "How do I send Bitcoin in paper wallet to other person?I'm new to bitcoin. Can you tell me step by step how do I send Bitcoin in paper wallet to other person. Thank you!",
    "answers": [
      "Spending money from a paper wallet is the hardest part. Making the wallets themselves is easy but spending the coins is harder than it should be. Here's a guide on how to do it safely: Create a NEW wallet on blockchain.info. Keep in mind that you will only use this wallet for the express purpose of emptying your paper wallet. You will not reuse the paper wallet and you will not reuse the blockchain.info wallet. Log into your blockchain.info wallet and go to Import/Export. You will get a warning about advanced usage. Agree to that to make it go away. Use the import private key option or the scan with webcam option to import your paper wallet private key. Once you've done the import you must spend the entire balance. Send what you need to an address owned by the other person and the rest to an address on your desktop client. Don't keep any balance in your blockchain.info wallet. You might ask why go through the trouble to do all this. That is because sometimes if you import a private key it might be reused by the wallet app/web service and change is sent back to it. You want to avoid that because if you assume you've spent all the coins in the private key and then you make the private key public and change is sent to it somebody could steal your coins. So to avoid all that you import into a temporary blockchain.info wallet and spend all the coins in one go.",
      "First you will need to import the paper wallet private key (the secret part) into a software wallet. With MyCelium (Android/iOS): Select the Accounts tab. Tap the three dots menu and pick Cold Storage . Tap QR Code and scan the paper wallet private key. With the Blockain.info app ( Android , IOS ): On the sidemenu tap Addresses : Tap the Add button ( + ). Select Import Address and scan the QR Code of the private key. ❌ Important : Once the coins are moved from the paper wallet to your software wallet, make sure you never ever use the paper wallet address again, on purpose or by accident. Don't try to only transfer part of the funds from the paper wallet — most likely you'll lose the rest (most wallets don't allow partial transfers anyway). Once you have transferred the assets from the paper wallet to your software wallet, funds can be transferred to/from another person using the Send/Receive options in the app. Keep in mind that if you are using an offline wallet such as MyCelium then the damage or loss of device will result in losing the coins, unless you backed up the seed and stored it in a safe place. Same applies to online wallets, such as blockchain.info: if you forgot your password and didn't export your secret seed, then the funds will be irrecoverably lost."
    ]
  },
  {
    "question": "What does the mining difficulty number really mean?I'm new to bitcoin; please bear with me. I'm looking into mining, how it works, and how to get started. I see a \"mining difficulty\" from many sources and list a 3 billion something number without units. What exactly does this number mean and how does it relate to the processing speed of the hardware used? For example, what predictions can be made on the number blocks you will solve with a 100 Gh/s ASIC at any given difficulty? I assume Gh/s is giga hashes per second, though I don't know what a hash is either. I found this related question , but I don't understand the answer. As an extension question, how might this relate to mining in a pool? Bitminter says it has 424 Th/s, so my 100 Gh/s is a drop in the bucket.",
    "answers": [
      "(If I may repeat myself a bit...) Mining is like having a lot of people throwing weighted coins (such that 1 millionth of the time it comes up heads) and telling you when they hit a heads. If one such \"heads\" is reported every 10 minutes (600 seconds), you can make a very accurate estimation of how many times per second the coins are being flipped. In this example: (1,000,000 flips/heads) / (600 seconds/heads) ~= 1,667 flips/second The network difficulty is how you adjust this 1,000,000 figure so that the 600 figure stays consistent as the network's total hash power ( 1,667 ) changes. To see real-world calculations of how the difficulty affects the coins discovered per time spent, see any mining profitability calculator , and change the \"difficulty\" figure. The Bitcoin wiki has details on difficulty , as well. I don't know what a hash is either. When mining , your computer creates a block of data, which has a list of all of the transactions it knows about, includes a transaction that pays you the mining bonus, and then hashes that. If the hash happens to be a small enough number (as defined by the difficulty), the block is valid. If it's not, you increment a random number called a \"nonce\" that's in the block, so that the block has the same meaning but different data, and hashes the block again. Lather, rinse, repeat. (the nonce is included from the start, of course, but I didn't mention it to avoid being confusing) The details of the block hash are explained in more detail at Bitcoin wiki's Block hashing algorithm . Gigahashes per second, then, are how many billion times your hardware can do this hash per second. If the pool you're in has 424 Th/s and you have 100 Gh/s, then you are about 1/4000th of your pool's total power. You can expect to be the one to solve about 1/4000th of the blocks (on average) that your pool finds. (technical details intentionally omitted; those are available at my various links, and your link)",
      "Miners task is to find a hash below a target T. Obviously if T is smaller, its more difficult to find the hash number. Difficulty D is defined by: D = Tmax/T where Tmax is: 2^224 The probability of finding the hash is: P = T/2^256 which is equal to 1/D2^32 So if you can make h number of hashes in t time, the probability of finding the target hash is: P = ht/D2^32"
    ]
  },
  {
    "question": "Satoshi's final statementI read some articles about Satoshi's history and stumbled upon this one: No one knows what Satoshi is up to, but one of the last emails he sent to a software developer, dated April 23 2011, said “I’ve moved on to other things. It’s in good hands with Gavin and everyone.” Source: http://www.coindesk.com/information/who-is-satoshi-nakamoto/ This sentence of Satoshi is quoted many times in the web, but I can't find a source who published it or to which developer it was send. I know there are archives of Satoshi's mails but I didn't find this statement in any of them. Does anybody have further information about it?",
    "answers": [
      "I've got an answer on Reddit : It's likely to have been written in a PM or an email to some developers, and it seems that Mike Hearn (BitcoinJ) was the one who published this statement: Mike Hearn - February 25, 2013, 12:48:54 PM He communicated with a few of the core developers before leaving. He told myself and Gavin that he had moved on to other things and that the project was in good hands. Source: Re: Could Satoshi come back and tell us what he/her thinks about the block size? Still, if someone has additional information I would be glad to know about.",
      "Ultimate necro, but it was Mike Hearn. You can find multiple emails between Satoshi Nakamoto and himself from back then at his site here: http://plan99.net/%7Emike/ The specific quote you've found is the last email in the last thread ( http://plan99.net/%7Emike/satoshi-emails/thread5.html )."
    ]
  },
  {
    "question": "Have any SPV users lost money because they accepted forged bitcoins?I'm making a list of real-life examples of occasions where bitcoins were lost to various known attacks. One of these known attacks is that lightweight (SPV) wallets can't verify whether a transaction only spends UTXOs (a requirement full nodes enforce) so lightweight wallets can be tricked into accepting bitcoins that don't really exist. Of course, only a dishonest miner would confirm that transaction, making the attack expensive if confirmations have to be involved. Does anyone know of a real-life example of a user who lost money to this attack, either involving an unconfirmed transaction or a confirmed transaction? I'd prefer an example from Bitcoin, but examples from altcoins are welcome too.",
    "answers": [
      "I run simplecoin.cz|sk|pl|eu bitcoin exchange. We use different wallets and we made 10k+ transactions. We lost some bitcoins. Most of it was human errors. Some bitcoins were lost when transactions took days to confirm during network flooding. We encountered some double spend transactions (which did not confirm) On other hand we never lost bitcoins when transaction had one or more confirmations. I'm not sure if spv wallet can be fooled when transaction has confirmation already. We trade 5k$ almost every day, our conclusion is to wait for confirmation and know your customer. There's also another risk in accepting even very small unconfirmed transaction and spending it to another customer, because like this you create whole tree of double spends which will never confirm, so you lock your funds for couple days until this toxic stuff gets pruned from memory pool. You also need to resend all this transaction again, it's paid by your time and customer happiness in the end."
    ]
  },
  {
    "question": "How to know if bitcoind synced?I installed the bitcoind and started it as daemon. After 10hours I've tried \"du -h\" ubuntu@ip-172-31-37-93:~/.bitcoin$ du -h 16K ./database 59M ./blocks/index 29G ./blocks 646M ./chainstate 30G . How to know if it synced or not? UPD found an interesting script to monitor node sync status How to check Bitcoind block chain download progress level",
    "answers": [
      "You can compare the block count from Blockexplorer with your local block count. Something like this: $ wget -q -O- https://blockchain.info/q/getblockcount; echo 359721 $ bitcoin-cli -conf=/u0/bitcoin/bitcoin.conf getblockcount 359721 As you can see above my node is synched since the counter is equal.",
      "bitcoind logs the current sync status to its debug.log file: $ tailf ~/.bitcoin/debug.log 2017-05-26 03:49:16 UpdateTip: new best=0000000000000001e0b7c8cffb8e7fa23909b8728913663decfaebffe24ca689 height=280022 version=0x00000002 log2_work=75.644236 tx=30854900 date='2014-01-12 03:50:07' **progress=0.137838** cache=312.7MiB(396972tx) … The field progress=0.137838 means that I'm currently ~13.7838% synced."
    ]
  },
  {
    "question": "Is there any way to buy bitcoins online without a fee?I'm new to bitcoins, and my experience is from something like E*Trade buying on the NASDAQ, so that's my frame of reference. I paid a small broker fee for every buy or sell, and I trusted the exchange and the software 100%. But I thought the big advantage of bitcoin was no middle man. Hence I assumed no fees. But perhaps contrary to that first assumption, in my second assumption I thought there would be this big trusted website where you go and buy / sell anonymously without having to trust the other party. You would just need to trust the exchange itself. Can I buy bitcoins anywhere without a fee? Can I buy bitcoins anywhere with 0 risk of getting ripped off, as in a flea market? Can I get both positive things in one place (ideal)? Thanks. EDIT Coinbase Pro allows me to do limit buys for free. The trick there is to set the limit price to the current price and keep changing the price if necessary to get the desired quantity purchased. Coinbase had been charging me 1% on large buys. So for small buys ok; large buys, it adds up! CEX.IO on the other hand, gave me large limits and they charge a flat fee of $10. So for a buy of $3000 this is only .33 percent; much better! Also, something I need to watch out for is the buy price. The exchanges mess with that to make extra margin I think. So I need to shop for best price before committing to buy. Compare the total price including fee based on buy price.",
    "answers": [
      "Of course you may trade bitcoins with just anyone without having to pay fees to a centralized exchange. I think Bisq (formerly BitSquare) may be the best answer to the question; decentralized, free for some definitions of \"free\", and very low risk due to the escrow system - but not completely without fees, indeed as of 2017 one may end up paying quite much higher fees on Bisq than on some of the centralized exchanges. Well, let's walk through this ... Fees and costs You probably won't get away completely without fees: There is the bitcoin transaction fee, a fee for getting the transaction included in the network. Basically, you can't withdraw your funds from the exchange or move it from one wallet to another without paying a network fee (though internal transfers i.e. on an exchange may be for free). As of 2017 it has become significant (i.e. 0.001 BTC, but can vary a lot), though not that bad if you want to turn over significant amounts of money (i.e. 1 BTC). According to the protocol the fee is not mandatory, but a regular transaction without a fee paid is very unlikely to be included in the blockchain. With many exchanges, one pays the exchange a withdrawal fee instead of paying the network fee. The withdrawal fee is usually constant, and usually higher than the average network fee paid by the exchange. Fees to the exchange ... any commercial centralized market place do eventually have costs and hopes to get investments recovered; I would be vary of a site claiming to be for free - though, some exchanges takes in most of the profits on margin traders. Sometimes market makers pays less fee than market takers - sometimes it's opposite (on Localbitcoins market makers pay the full fee). Arbitrator fee - on peer-to-peer-platforms (Bisq) where arbitration may be needed, one may have to pay a fee for that. Spread - on any exchange there will be a difference between the bid and the offer. If you need to buy bitcoins instantly, you will have to cover the spread. If you have the time, then place a bid/offer just marginally better than the competition and wait for the other party to take your offer and cover the spread. On the exchanges with highest volume, the spread will anyway be insignificant compared to the volatility. Banking fees, for converting fiat to/from exchanges and/or other peers selling bitcoins. Currency converting costs. YMMV, but for me this is a relatively significant and a somewhat hidden cost of sending fiat to an exchange. The exchange typically don't do trades in my local currency, and my bank gives me a pretty bad exchange rate when I send money to the exchange. Even meeting up with other people to trade cash may be costly wrg of transportation costs and time taken. Time is money - spend hours searching for the cheapest offers, and how many dimes did you save on it? (And how much did the bitcoin market value rise while you were searching for it?) Risks No method are without risks. Bankruptcy - as for the centralized exchanges this is probably the biggest risk - one day you send money to the exchange, the next day the exchange is gone. It does happen from time to time. Funds on a centralized exchange being frozen for other reasons. Your funds may be frozen for a variety of reasons - it does happen from time to time. Bitcoin transactions getting stuck. Not so much an issue when transferring from the bigger exchanges, but due to the block size issue a transaction may stay pending for arbitrary long if it appears the transaction fee was too low. I have personally experienced twice that a transaction from an honest seller using \"wrong\" wallet software was timing out after 72 hours. This became less of an issue in late 2017, as the default timeout has been increased to two weeks and because there is more often periods with idle capacity in the blockchain. Money lost or stalled due to other technical issues - seldom an issue, but if using a \"shitty\" exchange it may happen. Simple scams (mostly an issue if buying or selling bitcoins to random strangers without a proper escrow system in place). Some payment methods are also reversible (particularly credit card payments and paypal payments) or easy to fraud. Fake exchange scams (mostly an issue when selling btc); there exists several sites looking like legit exchanges, except they will just eat up your bitcoin if you transfer btc there. It has also happened that an attacker has managed to highjack the DNS entry and get a valid SSL certificate for the exchange (openledger.info). Money laundring; lots of the money in circulation comes from criminal sources, and you may become suspected of money laundry. This may cause your funds to get frozen on centralized exchanges. This may cause troubles with law enforcement if trading peer-to-peer. Laws may vary between different jurisdictions, unless it ought to be obvious that the money comes from criminal sources you generally should be on the right side of the law, but having to spend time answering questions from the police is still within my definition of \"trouble\". Some banks may even decide to freeze your account just because you're sending money to the exchanges. Third party scams; mostly an issue when selling bitcoins (anonymous money) for bank deposits (trackable money), not so much when buying bitcoins - a fraudster tricks a victim (or gains unauthorized access to the bank) into sending money to the bitcoin seller, and tricks the bitcoin seller into sending bitcoins to the fraudster. The victim gets angry with the bitcoin seller i.e. because he's expecting the bitcoin seller to send him an iPhone. Outright robbery - may be a risk if doing cash trades (I've encountered some attempts on robbery myself when doing cash trades), especially when appointing meetings with random strangers in dark alleys, or if counting bigger amounts of cash on a public place with the wrong person watching. If you expose that you have a lot of bitcoins i.e. through Localbitcoins and your identity and address can be found out, you may also receive threats (\"pay one bitcoin to address 1... or else something bad may happen to your family\" - I've experienced that, too). Software bugs and malicious software; can you trust the wallet software, etc? How to tell that i.e. Bisq does it's job, without any severe bugs causing bitcoins to be lost? Other answers here are focusing on the best or cheapest exchanges. I'll skip that and try to make an overview of alternative market places: Bisq (formerly Bitsquare) Bitsquare is a free and decentralized market place, it comes with a good escrow protection. It does have some drawbacks though: I managed to buy bitcoins through a \"same bank\"-offer, using my local domestic bank account. However, I did need to know the SWIFT-code for my bank, and I did need to know how to convert an IBAN to a local account number. YMMV, but I think this is a bit too difficult for quite a lot of people wanting to buy bitcoins. It's an application, not a web site - meaning you need to install special software to access it. Also, it's a graphical monolithic application that is supposed to be running 24/7, difficult to use on/from laptops and mobile devices. You can't buy bitcoins without already owning bitcoins - you will need to seed the application wallet with enough bitcoins to cover transaction fees and escrow deposit As far as I can see, there is no way to do free-text communication with the seller there. There is a max limit for how much can be transferred in a single trade Beware of the potential chain split in November - the maintainer has promised to follow the 1X-chain, so if SegWit2X should be successful, one may end up at the wrong side of a chain split. Bisq supports bank payments (including local currencies and local banks) and convertions to/from altcoins, as far as I can see cash is not an option there. You will eventually need to cover banking fees, and the bitcoin transaction fees will be higher than normal due to the complexity of the escrow transactions. (Note: the author haven't tried Bisq for quite some time, the information above may be out-of-date). IRC The IRC channel #bitcoin-otc on freenode is also place where it's possible to trade coins with no middleman taking commissions. I've never tried it though. Mycellium The mycellium wallet (android) has a cash-transaction built-in marketplace which is (as for now) without any fees - but if it ever becomes popular, the Mycellium team may decide to slap a fee on it. During the last year, I've gotten close to 0 trades through the Mycellium platform, so I've given it up. LocalBitcoins With a 1% fee (paid by the advertiser), LocalBitcoins.Com (LBC) is an unlikely candidate on this list - but still, the fee is not mandatory to pay, one can \"sneak\" away from it, without violating the ToS. If you search for offers on LBC, you will most likely find that there is a relatively big gap between the offers and bids. If you don't need to buy bitcoins immediately, you can \"turn the table\" and put out your own \"i buy bitcoin\"-ad. Telegram On the telegram chat service there is a bot BTC_CHANGE_BOT. I haven't tested it though, don't even know if it has fee structures.",
      "Some Chinese exchanges don't charge a fee. Any site that has possession of your bitcoins or dollars means there is at least some risk of getting ripped off. So unfortunately, what you ask for doesn't exist."
    ]
  },
  {
    "question": "How are different addresses generated from the same private key?I was reading in the \" Technical background of version 1 Bitcoin addresses \" that addresses are a function of the private key. More or less: Private Key -> Public Key -> Address If the public key is the only input needed to generate an address, how come a wallet generates a different address every time? What is changing?",
    "answers": [
      "Private and public key correspond to a point on the secp256k1 curve. They have a one-to-one relationship. The address is derived from the public key by performing a ripemd160 hash after a sha256 hash on the public key. Multiple public keys hash to the same address, as the address space is only 160 bit, while the public key space is 256 bit. Since both derivations ( private key > public key > address ) are deterministic, you cannot derive more than one address from one private key. * What you can do, is derive additional private keys from a \"master private key\" with a given derivation rule. These additional private keys obviously correspond to new addresses. This type of address management is called \"hierarchical deterministic wallet\". *Strictly speaking, you can create multiple addresses by differentiating between compressed and uncompressed keys. See Sven's and skaht's answers for details.",
      "With Bitcoin, a single private key will have associated compressed and uncompressed private/public key pairs. Uncompressed public key addresses are larger in size than newer compressed public addresses. (Contrast 1b and 2b below.) Uncompressed and compressed public keys shall have different associated Bitcoin addresses. Private keys encoded in wallet input format (WIF) will implicitly communicate to a hot wallet if uncompressed or compressed keys are to be used. A Blockchain records funds sent to either address uncompressed or compressed independently. Here are illustrative examples using libbitcoin's bitcoin-explorer ( bx ) command line interface using one of the absolute worst hexadecimal encoded private keys in the world 0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff that is obviously 256 bits in length. 1a) Uncompressed Private Key WIF-encoded: % echo \"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff\" | bx base58check-encode -v 128 5HpHb4pzVWwsDAHNwwUS3VViCkwzcutaSJ57T4GNFw5UBNLSrRV 1b) Uncompressed Public Key: % echo \"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff\" | bx ec-to-public -u 040d47568a5e517067a2836c3823fbc58169a7662bfae934a4d41da3e23c98d816e7202dd702ffe038147f78aee4973a581972960a1460312ffb6f3f0f13d4a52c 1c) Uncompressed Public Address: % echo \"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff\" | bx ec-to-public -u | bx ec-to-address -v 0 1NGoV1EGZrwM7yvUYqRC7TMBMj7ftpjR2B 2a) Compressed Private Key WIF-encoded: % echo \"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff01\" | bx base58check-encode -v 128 KwDiDMtpksBAcfyHsVS5XzmirtyjKWSeaeM9U1QppugixMUeKMqp 2b) Compressed Public Key: % echo \"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff\" | bx ec-to-public 020d47568a5e517067a2836c3823fbc58169a7662bfae934a4d41da3e23c98d816 2c) Compressed Public Address: % echo \"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff\" | bx ec-to-public | bx ec-to-address -v 0 1PbStXjfDNBU6FZA2iSeisVWwCFN9GK1eQ <- No bot was fast enough here to intercept my experimentation"
    ]
  },
  {
    "question": "The Bitcoin.it wiki says addresses do not carry balances...but all info suggests otherwiseThe Bitcoin wiki states, \"Addresses are not wallets nor accounts, and do not carry balances.\" Yet, there's a zillion articles online about Bitcoin address balances, the Bitcoin blockchain explorers show balances, and so on. Can you explain the Bitcoin wiki's statement to me?",
    "answers": [
      "The wiki is correct, it is a technicality. Bitcoin \"balances\" are actually just unspent transaction outputs (UTXOs, from previous transactions) which you have the ability to spend. In most cases, that means knowing the private key corresponding to an address which the transaction was sent to. But the address itself doesn't have a balance, it just \"locks up\" the UTXOs corresponding to it, requiring a private key. The important point is that the blockchain doesn't store a \"total balance\" of an address anywhere, to find the \"balance\" of an address requires looking through the chain to find the unspent transaction outputs sent to that address and summing their amounts. Then to spend bitcoins, you spend specific UTXOs, you do not just subtract the amount from your \"balance\".",
      "Bitcoin addresses do not actually exist on the Bitcoin network. They are an abstraction for humans to be able to easily send money to each other. What Bitcoin actually uses are transaction outputs. A transaction creates outputs which consist of the value and the output script. When you send money to someone, you are spending from an Unspent Transaction Output (UTXO) and creating new UTXOs. When you send to an address, you are really creating a UTXO with the value you want and an output script that is specified by the address. Addresses encode a version number and some data (usually a hash). So your wallet software takes the address, decodes it, and constructs an output script based upon the data and the version number (the version number specifies what the output script format should be). So addresses themselves do not actually exist on the network; they do not actually carry a balance nor do you actually send to or from an address. However many places will just say \"balance of an address\" and show such information as a convenience. This \"balance\" is calculated by constructing the output script an address specifies and then searching through the UTXO set for UTXOs with output scripts that match the constructed script. The values of these UTXOs are summed and that becomes the address's balance."
    ]
  },
  {
    "question": "Shortest and Longest block interval time ever recorded in BitcoinBitcoin block interval time is on average 10 minutes, that is the difficulty is adjusted in such a way that every 10 minutes a miner will manage to find the right hash. This is just an average time though, the actual distribution for time confirmation is Poissonian. What is the shortest and longest block interval ever recorded in Bitcoin?",
    "answers": [
      "(This data is current through block 535276.) Based on block timestamps (which do not have to be accurate), the longest difference between successive blocks is 463160 seconds (5 days, 8 hours, 39 minutes, 20 seconds) between blocks 0 and 1. The second longest is 90532 seconds (1 day 1 hour 8 minutes 52 seconds) between blocks 15323 and 15324 . For \"shortest\", since timestamps are not strictly enforced and can be fudged accidentally or intentionally, it is possible for a block to have an earlier timestamp than its predecessor, by up to 2 hours (7200 seconds), in which case the time difference is negative. This has happened 13828 times. The most negative difference is −7125 seconds (1 hour 58 minutes 45 seconds) between blocks 156113 and 156114 . There have been 222 blocks with the same timestamp as their predecessor, giving a difference of 0. The script I used to gather this data is at https://github.com/neldredge/bitcoin-blocks . Actual block intervals are hard to know precisely, since we have no way of knowing for sure the actual time at which each block was mined. Some sites like blockchain.info record the first time at which their node received the block, but there is an unknown propagation delay between the time a block is actually mined and the time at which some other node receives it (though for a well connected node it is probably not much more than 1 second). It is also possible to receive blocks out of order, so the difference in receive times could also be negative. Moreover, such data is obviously not available for early blocks before the existence of the site in question. In principle it could be possible to look for the longest and shortest difference between receive times, but I don't know how to retrieve that data in bulk.",
      "I'm not the author, but found this code: http://blockchainsql.io/wkeno3 Top 10 longest (using timestamp in block header, which can vary up to 2 hours from actual time) Block 1: 2009-01-03 463160 seconds (5 days, ~8 hours) Block 15324: 2009-05-22 90532 seconds (~25 hours) Block 16564: 2009-06-05 90390 seconds (~25 hours) Block 15: 2009-01-09 87157 seconds (~24 hours) Block 16592: 2009-06-06 73782 seconds (~20 hours)"
    ]
  },
  {
    "question": "How does the most recently found critical vulnerability (CVE-2018-17144) work?If you were a miner, what are the steps you would take to create the extra (21,000,012.5th) bitcoin? Where in the source code is this exactly (link)? Why can't this be done by a non-miner? Also, which forks are/were vulnerable?",
    "answers": [
      "If you were a miner, what are the steps you would take to create the extra (21,000,012.5th) bitcoin? Where in the source code is this exactly (link)? There are two components to CVE-2018-17144. There is a crash bug and an inflation bug. Both are triggered by almost the same scenario: a transaction contains an input multiple times. In general, how this would work is as follows: lets suppose a miner has an unspent output A for 1 BTC. They create a transaction with that input in twice, so input 1 spends from output A and input 2 also spends from output A. The output of that transaction has a value of 2 BTC. Note how the output's value is larger than the value of output A, but if you had output A twice, the value is correct. The miner would then take this transaction and include it in a block that he is mining. Once the miner find a block with his transaction included in it, he broadcasts it to the Bitcoin network. When a Bitcoin Core 0.14.x node receives this block, it will validate the block, but it will skip the duplicate input check because of the false parameter on this line . So the transaction the miner made will pass this step of validation, and the other transaction validation steps, including input script validation, until it reaches this loop . In this loop, the inputs to the transaction are being marked as spent in the UTXO database. The first time the duplicated input is seen, it is marked as spent. But the second time it is seen, the coin is already marked as spent so coins->vout[nPos].IsNull() will be true. This means that it will go into this if statement and subsequently hit the assert statement that follows . The assert causes the software to crash. For Bitcoin Core 0.15.0 - 0.16.2, the behavior is different. This is due to the change in how the UTXO database is structured. Everything is largely the same until the same loop is reached. Here, instead of returning whether the output was spent, SpendCoin actually returns whether the input exists in the database. So the first time, it will pass as expected, but the second time, instead of returning false , it still returns true . Looking at SpendCoin , you can see that it only returns false when it is unable to fetch the coin (object representing a UTXO) from the database. With the new database structure, this makes sense as the output should be removed from the database when it is spent. But, if you look a few lines down , you see that it only deletes the coin when it is marked as FRESH . In the case the coin was FRESH , SpendCoin would delete the object on the first pass so the second pass the coin would not be found and thus it would return false. This triggers the assert following the function call causing the node to shutdown. If the coin was not FRESH , the coin object itself is not deleted, but its contents are cleared. This means that the second time the input is seen, if the coin was not FRESH , SpendCoin would still return true as the object still exists in memory, which means that it passes the assert that follows the SpendCoin (which caused the crash when the coin was not FRESH ). Then validation continues as normal, and the output this transaction created is added to the UTXO database, which means that money that shouldn't exist now exists in the UTXO database. So now the question is, when are UTXOs marked as FRESH ? They are marked FRESH when they are added to the UTXO database. But the UTXO database is still only in memory (as a cache). When it is saved to disk, the entries in memory are then no longer marked as FRESH . This saving to disk happens after every block (as well as at other times, but that is not important). Thus, if a miner has an output that was part of a transaction that has already confirmed, and he spends the output twice in the same transaction (so the transaction has two inputs that refer to the same output), and this transaction is not broadcast to the network but instead included in a block that he mines, he is able to create a new output that has twice the value of the output that he spent, thereby creating coins. Why can't this be done by a non-miner? The reason that this cannot be done by a non-miner is because transactions that are received outside of blocks are still checked for duplicate inputs. The transaction will be rejected as invalid and not added to the node's mempool, so the transaction will never get into a block. It is only transactions with duplicate inputs that get into blocks that trigger this vulnerability, and thus only miners can do this as they must knowingly insert an invalid transaction into their block. Also, which forks are/were vulnerable? Any fork whose software includes commit eecffe50efc3944d713c701fa375dacbf17fb7cf . This would mean any software forked from or pulled in changes from Bitcoin Core after November 10th, 2016."
    ]
  },
  {
    "question": "How can one embed custom data in block headers?Some mining pool admins put custom data in block headers, like prayers . How do they do that? Where can I see that data for myself?",
    "answers": [
      "When you generate a block, the generation transaction (the one that creates new coins) has an attribute called coinbase . It's a special value you can put anything you want in to make the block unpredictable to others (and this is good). So, naturally, you can put text in this attribute, although most just put mining-related information that is not human-readable (nonce and extra-nonce). You can read this coinbase by using a patched bitcoin node that can dump blocks, for example with the \"dumpblock\" or \"getblockbyhash\" patches. Or you can just print every string in the blockchain database directly : strings -n 20 blk0001.dat Example for the 1st block: Coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73 ASCII-translation: ᝣᝣᝣᝣᝣᝣᝣEThe Times 03/Jan/2009 Chancellor on brink of second bailout for banks This is what is used by the Eligius pool ; it puts prayers in this field.",
      "Dan Kaminsky explained his method and motivations for inserting images into the blockchain at a talk at Black Hat USA 2011 - the relevant slides (12 -20) from the presentation can be found here. His basic method was to create transactions with lots of outputs and to include the message in ASCII, in pieces, in the receiving address field of the output scripts. You can see the corresponding hex codes for the ASCII in his message in the raw transaction . You can see that the message is interrupted by the other transaction fields, so you can only see the messages properly if you look with a tool (such as strings ) that filters out non-printable characters and displays printable characters in lines. His transaction required a .15 bitcoin fee, about $1.50 at the time."
    ]
  },
  {
    "question": "What's the difference between an ASIC and an FPGA? Which is better for mining?I'm a software guy with only the most basic of hardware training/knowledge so while I understand the basic concepts of ASICs and FPGAs the details are beyond me. What are the primary differences and, more importantly to my purposes, how do those differences play out for bitcoin mining purposes?",
    "answers": [
      "I co-founded LargeCoin, Inc., and we really are developing an ASIC for Bitcoin mining. As earlier replies pointed out, the unit cost of ASICs is far lower than FPGAs once you get beyond a few hundred units. The up-front cost of ASIC production varies widely depending on the process you use. On the cheap side, there is so-called \"wafer sharing,\" where your design gets populated on to a wafer with many other designs. Wafer sharing typically uses very old processes that aren't going to deliver the power and density benefits of newer processes. BTW, a \"process\" refers to a the physical process for making the transistors within the ASIC. Generally a process is referred to by its transistor geometry size - for instance 45nm is a relatively current process. Next up is \"Structured ASICs\". A structured ASIC vendor provides an assortment of standard logic components on the bottom layers of the chip. You then add a few metal layers on top of these connecting up the basic components to implement your custom logic. Structured ASICs cost between $100,000 and $500,000 (very approximately) for the first prototypes. Then there are \"standard cell\" ASICs, where the chip is designed using standard components that are sort of analogous to software libraries. And finally, there is \"full custom\". With a fully custom chip, you are designing everything about the ASIC yourself. The NRE costs for a full custom design is in the millions of dollars typically - particularly if you want to use a modern process. What process are we using? We're keeping that close to our chest at the moment. However, I can confirm that our detailed modelling at this point indicates we'll be able to mine 250 GHash/s in a single rack of mining units using 5kW of power. When you consider that this represents the computational power of about 400 AMD Radeon 6990 GPUs (which would consume close to 200 kW), you can immediately see the benefit of ASICs for Bitcoin mining. By the middle of 2012, ASIC mining will be a substantial factor in the Bitcoin economy.",
      "An FPGA is cheap in quantity one ($100-$300) but expensive in quantity 1,000 ($50,000-$3,000,000). They can mine decently (200MHash/s or so), but are not cost effective yet. (They do, however, consume much less power than GPUs.) An ASIC is expensive in quantity one ($2,000,000) but cheap in quantity 100,000 ($5,000,000). They can mine unbelievably well (perhaps 1GHash/s), but nobody (as far as we know) has gone to the expense of making one for bitcoin mining yet."
    ]
  },
  {
    "question": "What is the \"blockchain\"?What is the blockchain? I keep hearing about other \"blockchain technologies\", does this mean other cryptocurrencies or what?",
    "answers": [
      "The bitcoin block chain is the record of every bitcoin ever generated and every transfer of bitcoins from one party to another. Each crypto-currency that is based on the same type of technology as bitcoins has its own block chain. When people talk about other blockchains, they mean other currencies based on the same distributed currency / published transaction model (namecoin, Ixcoin, and so on). The phrase \"blockchain technology\" is a reference to this model of published transactions to implement currencies with no central authority.",
      "The Bitcoin \"blockchain\" is in effect the general ledger of Bitcoin. It is a recording of all transactions grouped into blocks. Each block represents approximately 10 minutes of transactions, and chaining them together has the effect of adding layer upon layer of transaction history. Chaining blocks of transactions together by requiring a new block to reference the most recent prior block makes it harder to alter blocks in the past, since all subsequent blocks up to the current one would also have to be altered. In the Bitcoin blockchain, this is combined with a 'proof of work' that each block must include (a very large amount of work at this point), to create an unalterable history of transactions that is definitive. New transactions can be evaluated against this general ledger with complete confidence that it is current, complete, and unalterable. With the entire blockchain publicly available, anyone can do this evaluation and prove that a transaction is valid or not. It is likely that someone referring to \"blockchain technology\" is talking about any system that has this type of public general ledger."
    ]
  },
  {
    "question": "What wallet / e-wallet is the most convenient for new casual Bitcoin users?I'd like to make small payments for business purposes through Bitcoin, so would like to know what the easiest method of getting setup to accept a Bitcoin payment is for a regular person, so that I can recommend it to those I want to pay. Some options I see are: Standard Bitcoin client BitcoinJ Instawallet Flexcoin These people will only be holding a few Bitcoin at most in their wallet, so security is not as high a priority as in other cases, but I would still like to avoid a Mybitcoin type fiasco where every one I pay loses their money. Which method has the best combination of convenience in getting setup and security?",
    "answers": [
      "Sorry to dig up and old question but I just wanted to add a link to My Wallet provided by blockchain.info I guess the thing that separates My Wallet from other e-wallet providers is that the site aims to feel more like an actually bitcoin client rather providing disposable addresses. I tried to design the site to be easy to use and it should seem familiar to anyone that has used PayPal or online banking. I will be adding more features soon which should be familiar to novice users such as invoices and monthly statements. You can generate up to 200 different bitcoin addresses and are free to export the private keys at anytime. In fact if you already have an existing bitcoin address you don't even need to add your private keys at all. For more information about how the site works try the faq or browse the code .",
      "The only true way to use bitcoin is of course to use the bitcoin client. It is a little difficult to use perhaps, but I would argue that's just about the same difficulty as online services at the moment. That being said you may consider using an established exchange like mtgox. The identities of the people involved are known (unlike mybitcoin), and many security issues have already come up and been addressed. Also they provide merchant services to make transactions easier on the go. It's also very easy to quickly convert your bitcoins to cash, and get paid out whenever you want."
    ]
  },
  {
    "question": "Who is Satoshi Nakamoto?Who is Satoshi Nakamoto? I have heard about him and read his paper. Why is he no-longer publicly involved in Bitcoin?",
    "answers": [
      "Satoshi Nakamoto is the elusive and private creator of bitcoin. In October 2008 he published the paper Bitcoin: A Peer-to-Peer Electronic Cash System (pdf warning) which is the basis of the bitcoin client/protocol. He has stated his nationality as Japanese and published a PGP key , has a sourceforge page and aside from that not much is known. It sort of follows that someone interested in creating a distributed pseudonymous online currency would be a very private person. It is also suspected that Satoshi may be a pseudonym for any of a number of people involved in the original development - a mask used for safety and protection against legal persecution for the creation of such a potentially disruptive product. To that end, Satoshi may still be involved in bitcoin, although as you stated, not publicly. As with everything else about Satoshi, the reason for his lack of current involvement is unknown.",
      "The two of the most important clues we have are: Based on observing messages sent by Satoshi Nakamoto, he(/she/they) appear(s) to sleep at about the same time most Americans sleep Satoshi Nakamoto owns about million bitcoins that have been worth over 64 billion dollars at one point of time, yet sees no reason to (and hasn't seen any reason to ever) convert that to an investment that has inherent yield, such as by selling bitcoins and buying diversified index funds. Most likely this is due to the fact that ever converting these bitcoins to something of value would risk revealing the identity, or it being pocket cash to whoever is Satoshi. Theoretically it could be of course that Satoshi Nakamoto has lots the crypto keys to access those bitcoins, however. The two non-clues we have are: Satoshi uses British English and has embedded references to British newspapers in the start of the blockchain Satoshi uses a pseudonym that sounds like it's of Japanese origin The reason these are non-clues are that anybody can use any language or dialect of a language, and anybody can invent any pseudonym. So most likely Satoshi wants that we believe he's British or Japanese in an attempt to conceal the identity. Also there is some speculation based on Satoshi's code that Satoshi is not necessarily a single person but could rather be a team. This agrees excellently with clue (2), since a large team might have less incentives to convert the million bitcoins to something of an inherent value than a single person would. But it would have to be a pretty large team, though (otherwise the bitcoins in there per person would favor converting that to real money), and every member of that team would need to keep that same secret. Most plausible is that the team is in fact a state actor, since something that once was 64 billion dollars wouldn't be unused even if the team would be a large company for example. As an example, if we assume Satoshi is Apple (the most valuable company in the world), that company could have paid an extra dividend for one year (edit: an extra dividend for over 4 years, as Apple seems to pay less than 15 billion/year in dividends) by converting the bitcoins to cash. So claiming that Satoshi was Apple doesn't make sense. In a civilized world people working for a company wouldn't hide the existence of something that was once worth 64 billion dollars. This leaves two most plausible explanations, the largest state actors in American time zones: United States Canada Considering that United States has done a lot to improve encryption (and in some cases embedding backdoors to encryption algorithms), this is by far the most plausible explanation. 1 million bitcoins is pocket cash for United States. However, this theory would mean there's some reason for the state actor to conceal the identity of Satoshi, and we can't know (we can only speculate) why United States for example would create bitcoin in secret. At least the United States intelligence services seem to be capable of keeping information secret at least to some extent -- true, there has been an Edward Snowden but only one Edward Snowden. But it wouldn't be impossible for Canada to be involved, however; after all, Canada is part of the Five Eyes alliance with United States and many other countries. Personally, I think it would be an excellent idea for for example NSA to create a cryptocurrency that the majority of the world's population consider more private than cash, but that actually is far more public than for example any bank transaction. The claim that Satoshi = NSA is entire speculation, though, but the incentive is there. If you want to access all Internet traffic in the world (presumably to identify something illegal from it), doing something that might give you a view to a large portion of illegal financial transactions would be very useful. After all, those contain most of the interesting transactions, the ones you want to access anyway (plus a lot of \"investors\" wanting to be rich by buying Bitcoin and then end up losing a lot of money on that speculation). Also, an observation: Tor has been created by United States, but publicly. Wouldn't be impossible for Bitcoin also to be created by United States, but this time privately. But that starts to be more speculation and less facts, so I'll end the wild theories here."
    ]
  },
  {
    "question": "Which Bitcoin escrow services are available - and reliable?For some transaction, the possibility of generating \"chargebacks\" might be very useful. For example, when trust cannot be established between both parties. In such cases, a trusted third party may be very helpful. One very well known and reputable Bitcoin escrow service was ClearCoin - however, that's currently not available. Please list one service per answer (not multiple services in the same answer) so that the votes can decide on reliability (use comments for testimonies, if there are any ;-) ).",
    "answers": [
      "BTCrow.com , operator made quite a few posts about the service, Bitcoin Escrow Service - For safer bitcoin transactions",
      "There aren't many established bitcoin escrow services yet. I suggest a new one that came up last month named mybitsafe . You can find a lot of information about the owner in the FAQ. He also made a post at the bitcointalk forums . Please note that, right now, this service does not allow a buyer to get his money back. Once the money is in the escrow, the buyer either releases it to the seller or destroys the transaction (the coins get donated to the Bitcoin Faucet). You can find a discussion about the advantages/disadvantages of this in the forum thread."
    ]
  },
  {
    "question": "Is there an easy way to give people a Bitcoin address?I see that Bitcoin addresses have built in checksums that helps prevent typos (ie. it is highly unlikely that you can mistype a Bitcoin address and have it still be valid). However, I still think the addresses are too long to easily give to someone, publish on a business card, etc. Is there any way to shorten addresses or get specific addresses?",
    "answers": [
      "Here are a few tips to help you distribute your addresses on a more readable form: Firstbits.net shortens your address to (usually) less than 7 characters. To get the full address just enter the firstbits at the website (ex: http://firstbits.net/?a=1kk5k ) Use vanity generator to create a more customized address. You can try to create an address that has your name on it or any other word that you like. Bear in mind that this will still be a long address with many 'strange' characters (ex: 1stDownqyMHHqnDPRSfiZ5GXJ8Gk9dbjL) If you use an e-wallet service, there are usually shortcodes that allow users to transfer bitcoins instantaneously between users. You can only use this if the other person uses the same e-wallet as you (ex: check Flexcoin , TradeHill or CampBX ) If you want to print your address into a business card, I suggest using QR Codes . They can easily be scanned with a smart phone.",
      "Check out btcans.org . The BTCANS allows you to register an account and post associate a payment address with it. You can hand out your payment BTCANS address and other users can query your payment address by entering q.btcans.org/your-id-here into their browser. The difference between btcans.org and an address shortener is that you can change your address at any time. Subsequent queries will return the updated payment address."
    ]
  },
  {
    "question": "How can I send Bitcoins via SMS?I am considering working on giving Africans access to trade using Bitcoins. In many ways, parts of Africa is more developed when it comes to mobile payments than the west. The success of M-PESA confirms this. Their security is based upon a special SIM card (see Step 1 in this getting-started guide ). My question Would it be possible to set up a service where one could send and receive Bitcoins securely via SMS? An additional condition to this question is that the SMS could be sent from a good old crowbar mobile phone without any access to a computer to perform encryption. One should also notice that postal services in these countries should be considered insecure. Motivation My motivation for this project is the heavy costs involved with making an overseas transaction to an individual in Kenya, because M-PESA only accepts transactions from oversees using Western Union. This is important because I know that there are huge flows of money going from Africans (and more so Asians) in Western countries to their family-members at home. Additional points It should be noted that one can send SMS for free amongst others to Kenya via Google SMS. Their only condition is that the receiver responds to the SMS occasionally in order to avoid it getting used for spam. Currencies in some African countries are very unstable (for example in Zimbabwe), so the Bitcoin currency could maybe be considered a \"hard currency\" compared to the local ones.",
    "answers": [
      "Just an account on http://phoneco.in/ because thats exactly what the service does. [Update: Phoneco.in is defunct.] Update: A new service as well to check out. http://dialcoin.com/ [DialCoin's site is up yet but has suspending service.]",
      "You can make bitcoin transaction via SMS because it's just couple hunders of symbols, but it requires internet connection to verify transaction against double spend attack. You can setup man-in-the-middle that will hold customer's bitcoins in it's database and sell or buy bitcoins for them. Customers would be able to add or withdraw fiat currency via SMS and send bitcoins via internet website. But if you want to give users control of their accounts via SMS then you would have to develop application and distribute your own SIM card."
    ]
  },
  {
    "question": "Are Bitcoins destined to forever increase in value?The idea of a currency with a limited number of units seems to me to be fundamentally different to existing currencies. While other currencies are generally based on permanent inflation - more 'units' coming into the currency pool - which causes each unit to be worth less, Bitcoin is based on a fixed number of 'units', never changing. Does this mean that, as usage increases and time passes, each 'unit' will necessarily be worth more and more and have to be split into smaller and smaller amounts?",
    "answers": [
      "In theory yes. If demand grows at a steady rate this will certainly be the case, as less coins will be produced making what is available more desirable. In reality there are other factors which could affect the value of bitcoins. Alternate chain could supersede bitcoins (unlikely at this time) Vulnerabilities like what has appeared (with hacking) already in the main markets Overspeculation of market trends Think of it more like gold than a fiat currency in the likelihood of behaviour (nb. my opinion, may not be the case) If the value does keep increasing it can split into eight decimal places to make a very large number of potential units of currency.",
      "This generally boils down to supply and demand. When the supply is fixed the value would increase with the demand."
    ]
  },
  {
    "question": "Is there data on the geographic distribution of bitcoin users?If you are a company wanting to adopt bitcoin as a payment method or an academic wanting to study the bitcoin market it is important to know as much as possible about the bitcoin users. Since bitcoin is pseudonomous it is hard to gather direct information on the users. However, if users want to make transactions then they need to broadcast to the network. Although the IPs are not stored in the block-chain, there are ways to learn them . With the IP addresses, it is possible to use IP Geolocation to get an idea of where the user is. Hence the question: Is there data available on the geographic location of users of bitcoin? Especially on volume of bitcoin transactions from given geographic areas? Or is it impossible or unlikely that such data can be gathered? If the majority of users use Tor for instance, then it would not be possible to get a good location data. Are there other technical constraints that make it impossible to use this or other approaches to learn the geographic locations of a large number of users? Meta note Since bitcoin is new, it is possible that such data is unavailable yet just due to the novelty. Please don't provide such answers, we can just wait until such a study is done and given as an answer. A 'no' answer is interesting only if it explains a technical constraint that would stop such studies from ever happening. Also, it is possible for a committed user to invest effort in order to hide their location. However, unless there is reason to believe that most users use such efforts, this is also not a very relevant answer. This question is an attempt to turn our lowest voted question into a legitimate specific question.",
    "answers": [
      "This shows bitcoin nodes based on IP address location. http://www.weusecoins.com/globe-bitcoin/ (UPDATE: link is broken)",
      "Quote from question: Also, it is possible for a committed user to invest effort in order to hide their location. However, unless there is reason to believe that most users use such efforts, this is also not a very relevant answer. It's not likely that most people will try to hide their location but it's still pretty likely that the location of nodes won't reflect the location of users. Computer usage today is more and more about web applications and less about downloading programs so it's not a wild guess that online wallets will be the choice of most \"regular users\". The best source for location data about bitcoin users in the future might prove to be visitor statistics from Bitcoin web sites (merchants, e-wallets, exchanges etc.)."
    ]
  },
  {
    "question": "Where can I sell things for bitcoins?I have old items that I want to sell for bitcoins. This includes digital content and physical objects. What websites can I use to sell them?",
    "answers": [
      "You can find an extensive list on page Trade at Bitcoin Wiki . A short list of some auction sites that use Bitcoins: Bid Bitcoins Bidding Pond Bitmit If you want to sell digital files per download, go here: http://bitcoinservice.co.uk/ . And as with anything, you can just post on an online classified ad websites, such as craigslist (thanks Thilo for the suggestion).",
      "http://bitcoinservice.co.uk/ allows you to upload a file and receive payment from people downloading it, in case your digital content is of a kind suitable for this format. Update Apr 24 2012: https://www.coindl.com is looking to become the new bitcoinservice.co.uk."
    ]
  },
  {
    "question": "Moving the Bitcoin folder from AppDataBitcoin's taking a lot of space on my C drive, and I would like to move it to another drive. I've figured out to do it using symbolic links, but the problem is that my Bitcoin client is currently synchronizing with the network. Is there a way to pause it, so I can move the data and then go back to synchronizing? My C drive's almost running out of space.",
    "answers": [
      "You can create a directory junction (as i did to move the BitCoin data folder), or you can specify a different data folder location : BitCoin-qt.exe -datadir=d:\\BitCoinData Which will be the long-term solution.",
      "On Windows, the whole %appdata%\\Bitcoin directory can be replaced with a symbolic directory link: Make sure the bitcoin client is not running. Move the %appdata%\\Bitcoin directory to its target location (e.g. d:\\bitcoinData) Run the command prompt as root and issue the command mklink /d \"c:\\users\\ \\appdata\\roaming\\bitcoin\" \"d:\\bitcoinData\" OR as answered by @lan Boyd"
    ]
  },
  {
    "question": "What is a good resource to help newbies choose their first wallet/s?While editing the Bitcoin Newb Guide , I realized I can't find a single page that covers all major clients in a Newb-friendly manner. bitcoin.org doesn't seem to mention web wallets such as My Wallet The wiki page is not IMO newb-friendly ... one big table, no clear way for a newb to decide which wallets he should try out. Yes, the features are listed in the table, but a newb won't understand them. What is the best objective resource to help newbs choose their first wallet/s? Requirements : Objective source (as much as possible) Updated Frequently, preferably user editable / reflects user votes Includes major desktop clients Includes major web wallets / mobile wallets Noob Friendly - just dumping all clients in a big table will scare off noobs. I want a page that, while giving out sufficient information, is well structured and will not scare noobs. The Wiki Page is a good counter example.",
    "answers": [
      "Essentially it boils down to the tradeoffs between security and convenience. Instawallet is incredibly convenient, but not all that secure (as no password is required, and if you lose the URL, you lose the ability to spend the funds.) Paytunia was a great shared (hosted) EWallet for a beginner, and there is a mobile app (for Android). A new version of Paytunia is in the works for a 2014 release . Blockchain.info/wallet is a great hybrid (browser-based) wallet and also has a mobile app (for Android, and for Cydia / jailbroken iPhones). Configured properly, with backups sent to your e-mail inbox, this is probably the best combination of security and convenience. If you only need a mobile wallet, the BitcoinSpinner works well also. http://en.bitcoin.it/wiki/EWallet http://en.bitcoin.it/wiki/Mobile_Payment_Apps",
      "I'd recommend to read up on Bitcoin to understand what you're doing. Then you can find an overview of wallets on bitcoin.org , but for a quick start, the fastest way to get started is: Desktop (Windows/Mac/Linux) : Electrum or MultiBit Android : Bitcoin Wallet by Andreas Schildbach iOS : Bread Wallet Windows phone : Get an Android phone instead These are all fairly easy to use, and don't bother you with all kinds of advanced options. This post was adapted from my answer on How to get started with a Bitcoin wallet ."
    ]
  },
  {
    "question": "What happens when a miner does not claim all fees/generated coins?Suppose that a miner for some reason has the generation transaction of their blocks not take all the possible coins. This can happen for a variety of reasons, almost all of which are bugs: An off-by-one error makes them think that their block should generate only 25 BTC when we're still at 50 BTC per block Some bug prevents them from noticing a transaction fee; perhaps they were mining and updating the block in parallel using non-thread-safe code. Depending on the answer to this question, they may actually decide to do this on purpose (though I can't think of an answer that would cause this in the vast majority of cases) I can think of a few possible ways the network would respond, and none really seem ideal. The block could be rejected, just as it would be if it had too much generated. The block could be accepted and the extra coins available for whoever mines the next block (in which case, somebody may do this on purpose to encourage others to mine). The block could be accepted and the extra coins lost. What actually happens?",
    "answers": [
      "The block is accepted, and the coins are lost. Poor miner. Here is a link to the part of the 0.6.3 source which checks this: https://github.com/bitcoin/bitcoin/blob/v0.6.3/src/main.cpp#L1362 Also, this has effectively happened before; block # 124724 claimed one satoshi less it than could have.",
      "the block #124724 issue seems to be a 49ers thing from star trek due to the block reward number. the code version from block 0 bitcoin v.0.1.0 still had the original poker part implemented (CPokerDialogBase in line 684 of uibase.h) . and therefore the TNG episodes makes the most sense into explaining why this could have happened. it has a big advantage cause it enables bitcoin also working for people related to such a time in the past. in this case the wild west times. before the year 1900 what was also shown in the appropriate episode to it. then there is also the fact how Data is involved into all that. the artificial AI android. see here: https://memory-alpha.fandom.com/wiki/49er found another example as well: another gap so to say that i wanna close herby! in block #526591 was someone only claiming halve the reward https://learnmeabitcoin.com/explorer/tx/bd23db7fef82fd99b27f3ddd895e72a2a5937af4c1fa3b3547972071a941d9d4 the website owner also linked the incident into this stackexchange entry from above. (what also did lead to the fact me finding this here on stackexchange in the first place and now giving the reader this valuable piece of information) well it should round the thing up for someone wanna learn more about BTC hence i would even say the information contained on the learnmeabitcoin website should give everyone the reward of becoming a full coiner pretending having read through enough and therefore running the knowledge worth a full coin. this should therefore also close the cycle and better help others to profit from this technology another idea would be seeing a resonance for those 6.25 BTC into actual course price. what isnt far away from that actual ones (apprx 65k). meaning 62,5k is relevant to resonate into this incident into the past due to being a tenth in fraction to it for the number itself (without the k). what would also add to the mentioned episode from star trek as well. due to the fact that it was a 2 episode long thing in span. in this sense the coins are not lost. they act as a bridge that will stay for everyone finding this information from this website here. while my comment here. helps understanding it better why such things happen. should do the trick"
    ]
  },
  {
    "question": "What is a private key and a public key?What exactly is a private key and public key in relation to Bitcoin? What are they, how are they used, and how does one find out what their private and public keys are?",
    "answers": [
      "Both of the keys are a part of the Elliptic Curve Digital Signature Algorithm . A private key is just a random number, while the public key is a 2D point coordinate on an Elliptic Curve derived from it. The private key is used to sign messages (in case of Bitcoin - the transactions), and the public key is used to check whether the signature is correct. The public key can either be used raw in a transaction, or turned into a Bitcoin address by means of hashing and other operations. One can use any library that supports the ECDSA curve used by Bitcoin (secp256k1) to generate the appropriate keypair. There are some online solutions for these tasks, for example my small testing suite website . However, most commonly one leaves key pair generation to the Bitcoin program. If needed be, the private key can be retrieved from the program by using dumpprivkey Bitcoin API call."
    ]
  },
  {
    "question": "Will general non-standard transactions ever be allowed?To the best of my knowledge, currently \"Satoshi\" client relays and most pools accept only standard (transfer or generation) transactions . Besides, community is working on M-of-N transaction type . Adding non-standard transaction to the blockchain is nowadays pretty problematic. While currently enabling arbitrary scripts in transactions could be disastrous due to possible bugs in code (or in the script system itself), I wonder if it is planned to allow arbitrary transactions somewhere in the future, or will most of the network always be restricted to some set of \"good\" transaction templates?",
    "answers": [
      "The current development direction (January 2013) is to tighten up the IsStandard() checks even more. For example, we would like all signatures to conform to a very strict, canonical encoding to make life more difficult for potential attackers. Allowing more opcodes or opcode patterns (or all opcodes/patterns) to be considered IsStandard() is certainly possible; before doing that I'd like to see a thorough analysis of the possibility for mischief using the current set of opcodes and a lot of prototyping on the test network (where the IsStandard() check already allows all enabled opcodes).",
      "The isStandard() check has been relaxed as of 2014. You can now include a wide variety of scripts in transactions. Read more here: What is meant by \"relaxed standards\" for P2SH redeem scripts in Bitcoin Core 0.10.0?"
    ]
  },
  {
    "question": "Can I use bitcoin as a means of bypassing Argentine Dollar restrictions?I am planning on doing some small-time buying/selling with a friend who is in the States. I am in Argentina and I do not have a way of reimbursing him in Dollars for products that he buys, sends to me, then I sell. Product and Dollar restrictions are very bad here right now, but there has to be a way to bypass these so we can do business together. Any help or advice is appreciated.",
    "answers": [
      "Put up an ad on LocalBitcoins.com . You possibly might find a tourist arriving with bitcoins who is looking for Argentine pesos. Or perhaps you'll find a local Bitcoin miner who is simply looking to cash out some bitcoins for your pesos. Are there any goods that you could pay for with your pesos and then have the goods shipped to a buyer who pays using bitcoins? You might laugh, but you might find buyers for Argentine pesos sent via the mail. If there's a market for the Zimbabwe 100 trillion dollar note, there's probably buyers wanting a set of your paper banknotes (for novelty, or maybe even speculation -- who knows. Again, travelers are a resource for you. For instance, even while visiting a foreign country a traveler might have family or friend back home that would be able to deposit cash for the purpose of buying bitcoins. The typical traveler might not need this, but if for instance, the traveler wants to buy a larger valued item and the seller only accepts cash then the traveler is in a bind. You are simply helping the traveler convert paper money (e.g., USDs) in one country for a different paper money (ARS) in another. You might also follow the Spanish board on BitcoinTalk forum to find others who might wish to trade by selling bitcoins to you. Or find some Argentine merchants who accept bitcoin (like this , this or this ) and see if they have coins and are looking to trade. Or find a merchant that does a lot of export and convince that merchant to begin accepting bitcoins. When they do, you've found your supply of coins.",
      "Yes, you could reimburse your friend with Bitcoin provided that you can find someone who is willing to sell you bitcoins in exchange for your local currency. However, when the demand for such transactions is strongly one sided in a particular region, the exchange rates may not be particularly favourable. This question might be of interest for finding someone to trade with: Is there a forum-like exchange for trading Bitcoins person-to-person? In the USA, your friend should have little trouble converting the bitcoins back to USD."
    ]
  },
  {
    "question": "How can I limit bandwidth usage in Bitcoin-qt client?I've just finished the intial blockchain download/verify in my BitcoinQt client (17 hours..) and I now see that BitcoinQt is happily eating all of my upstream bandwidth. (About 110kByte/sec on my ADSL line.) I'm going to be applying bandwidth limits to the app using Waterroof , which should probably work -- But shouldn't there be a built-in method for BitcoinQt to be more polite about its bandwidth consumption?",
    "answers": [
      "If your goal is just to get a stable Bitcoin node running, and not to contribute to the network, you can add listen=0 to your bitcoin.conf file. This generally (though not always) keeps your upload bandwidth in check. If you want to contribute to the Bitcoin network without using up too much of your own bandwidth, however, there are ways of limiting your upload speed for Bitcoin Core (Bitcoin-qt) only. Instructions depend on your OS, so what follows is a breakdown on what to do with each OS. IMPORTANT NOTE: If you limit the bandwidth of Bitcoin Core far below your actual upload speed, it can actually harm the Bitcoin network instead of helping it. To be a responsible maintainer of the Bitcoin network, you should test your upload speed and then set your outgoing bandwidth limit to be as close to your actual speed as possible (e.g. 90%). This guide is intended solely for people whose internet connections go unresponsive due to Bitcoin Core completely saturating their upload bandwidth. The following instructions are abridged from this article I wrote recently: https://www.maxlaumeister.com/blog/how-to-limit-bandwidth-of-bitcoin-core-on-windows-mac-os-and-linux/ Limiting Bitcoin Bandwidth on Windows Download and Install NetBalancer . Start Bitcoin Core if it isn’t already running. Run NetBalancer. Find “bitcoin-qt.exe” in the list of running applications in the NetBalancer dialog and double-click it to change its bandwidth rules. Under “Upload Priority” choose “Limited”, set the maximum amount of bandwidth for Bitcoin Core to use, and confirm. You’re done! NetBalancer will now sit in the background and make sure Bitcoin Core doesn’t use more bandwidth than you want it to. Limiting Bandwidth on Mac OS X OS X 10.10 Yosemite and later For OS X 10.10 Yosemite and later, there is no easy way to limit the bandwidth of a particular application, but the overall system bandwidth can be limited as follows: Visit Apple Developer Downloads and log in with your Apple ID. Search for “Hardware IO Tools for Xcode” and download the latest stable (non-beta) version. Open the .dmg and double-click “Network Link Conditioner.prefpane” to install the prefpane. From now on, you can enable/disable Network Link Conditioner from System Preferences. From the Network Link Conditioner pane in System Preferences, click “Manage Profiles”, then click the “+” button to add a new profile. Edit the profile and add your desired maximum upload speed. Save your edit, exit the profile manager, choose your new profile, and flip the big switch to enable the limiter. Mac OS will place an icon in your notification tray so you remember that it’s on. Unlike the Windows/Linux solutions, this will limit the bandwidth for your entire system, so be sure to turn it off you’re not running Bitcoin Core. OS X 10.9 Mavericks and earlier For OS X 10.9 Mavericks you can use IceFloor to configure bandwidth rules . For 10.8 Mountain Lion and earlier, use Waterroof . Alternatively, if you want a simple way to control the overall system bandwidth limit instead of just Bitcoin Core, follow the instructions above for OS X 10.10 Yosemite and later. Limiting Bandwidth on Linux Make sure you have tc installed by typing tc at the command line. If you get “command not found”, install tc using your favorite package manager. If you're on a Debian-based distribution, the easiest way to install tc is by using apt-get : sudo apt-get update sudo apt-get install iproute2 Download the tc.sh script from the official Bitcoin Core repository using wget: wget https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/qos/tc.sh Open the script in a text editor. Find the line that says IF=\"eth0\" and change eth0 to reflect the network interface that your internet connection runs through. To get a list of your computer's network interfaces, use ifconfig on the command line. My computer is connected wirelessly through wlan1 , so the IF line of my tc.sh looks like this: IF=\"wlan1\" LINKCEIL should reflect the limit of the network interface, and most likely does not need to be changed. LINKCEIL=\"1gbit\" Change LIMIT to be the maximum bandwidth you want Bitcoin Core to use (I chose 1mbit). If you don’t have any other Bitcoin Core nodes in your local network, you can delete the line that says LOCALNET. This line is there to make a bandwidth exception for port 8333 communications within your local network (i.e. not out to the internet). LIMIT=\"1mbit\" Leave the rest of the commands in tc.sh alone unless you know what you're doing. The final top section of my tc.sh ended up looking like this: #network interface on which to limit traffic IF=\"wlan1\" #limit of the network interface in question LINKCEIL=\"1gbit\" #limit outbound Bitcoin protocol traffic to this rate LIMIT=\"1mbit\" Exit your editor and make the script executable with the following command: chmod +x ./tc.sh Run the script as superuser: sudo ./tc.sh Your Bitcoin Core bandwidth will be throttled until you reboot your computer! Optionally, you can set the script to run every time you start your computer. Instructions for running scripts on boot will vary depending on your Linux distribution. On Ubuntu, one of the ways to run a script on boot is by adding the script to your /etc/rc.local file. Conclusion Hopefully this post was helpful in showing you how to limit the bandwidth of Bitcoin Core! For the full version, including images and extra information, check out the original article here .",
      "One answer mentioned in the thread is to add listen=0 to your bitcoin.conf (which is in {User}\\AppData\\Roaming\\Bitcoin). This stops other nodes connecting to you to download the blockchain, hence stopping the large upstream bandwidth consumption"
    ]
  },
  {
    "question": "What is replace-by-fee?https://bitcointalk.org/index.php?topic=199947.0 Can anyone explain what replace-by-fee means?",
    "answers": [
      "This thread explains it . It's a method that allows replacing an already transmitted transaction by transmitting another transaction with a higher fee. This only works on transactions before they are signed by miners (0-confirmations).",
      "After 6 years, Now I want to tell you what is Replace by Fee :) This feature was proposed in BIP125 and implemented in Bitcoin Core 0.12.0. In simple words, by enabling ( Replace By Fee ) RBF in a transaction, if a transaction doesn't get mined, it can be resent by the sender with a higher mining fee with keeping the input data of the UTXO(Unspent Transaction Output) same as before."
    ]
  },
  {
    "question": "Reliable, efficient way to parse the blockchain into a SQL databaseI need to generate a SQL database (preferably SQLite3) of every transaction that has occurred in the blockchain. Is there an efficient way to do this using open-source software? I'm attempting to do it myself using a Haskell script that makes system calls to bitcoind but I'm having trouble making it sufficiently fast.",
    "answers": [
      "I created a fork of blockparser with a 'csvdump' command that will generate a details dump of the blockchain in CSV format. There are also some support scripts in that repository for creation, population and periodic update of a PostgreSQL database. Be aware that the resultant database is pretty large; you might want to consider PostgreSQL over SQLite for this one.",
      "Possibly checkout ABE - Alternative Block Parser. It uses python and a SQL-based database but you can hook up other databases based on the driver. https://github.com/jtobey/bitcoin-abe"
    ]
  },
  {
    "question": "Countrywide Internet isolation, inevitable forkMany countries around the world have provisions for shutting off the Internet as well as isolating itself from the Internet (where networking within borders still flourishes), any transaction processing (mining) going on within that country will only find nodes within that country and start following its own chain. Is this a correct assumption? Secondly, if this is a correct assumption, how will the network deal with this once it comes back online? I foresee alt-chains emerging due to this, and persisting with their own exchange rates, very similar to the different fiat currencies today. So: Are my assumptions correct? What, if any, provisions does the bitcoin protocol have for forks of this size (which wouldn't necessarily be that large, but still have real consequences for people forced to use them)?",
    "answers": [
      "Your assumptions are perfectly right. Since there is no information exchange between the two partitions while the network is partitioned, and Bitcoin guarantees liveness, the global consistency suffers (see CAP Theorem ). This means that each partition will have its own blockchain fork, unaware of each other. The forks are incompatible not just because the chain is defined to be a single path from a single header block to the genesis block, but also because transactions in the partitions will contradict each other (not least the mining generation transaction in the block). Should the partition be prolonged the forks may even start to diverge in difficulty, as they will only see the computational power in their own network and adjust accordingly. As for the merge, this is still being discussed and we do not have a good contingency plan. Letting the system merge the forks by itself, i.e., dropping the fork with the least work in it, would roll back the entire transaction history in that partition. A manual intervention by making the fork persistent (the alt-coin scenario you mentioned) is also not desirable, as it results in an immediate doubling of the funds in circulation, Furthermore it is likely that one of the forked alt-coins is going to whither and eventually be abandoned anyway. For now the best we can do is attempt to avoid prolonged chain forks, but the risks you pointed out are real and worth discussing before it's too late.",
      "The answer is simple: if a country blocks off external internet access, its inhabitants effectively cannot use Bitcoin while the country is blocked. Sure, the protocol will continue with a fork ... but this fork has no hopes of ever \"reconnecting\" with the main blockchain, so any blocks generated / signed in the fork are useless. The country will have effectively prohibited its denizens from using Bitcoin. They can indeed use a specialized fork designed for this country, or even the naturally-occurring forked copy, but the value of this fork will not be tied to the value of Bitcoin. This scenario is not a real problem for Bitcoin, rather it's a problem for citizens of countries that are at risk of being disconnected from the internet. If you believe that your country will never execute such a separation, then you're safe."
    ]
  },
  {
    "question": "How to use the \"Bootstrap.dat\" file with bitcoin-qt?I have searched around, and nothing I find works for me. Downloaded the approx. 10 GB Bootstrap.dat file. Now stuck on trying to link it with Bitcoin-QT. Tried the following command in the console box in the bitcoin-qt app: bitcon-qt -loadblock=/path/to/bootstrap.dat Also tried copying the file into the AppData/Roaming/Bitcoin file... Still no luck. I'm running Windows 7, anyone have step by step instructions on how to set this up?",
    "answers": [
      "Okay, it appears after much trial and error, I figured out that you put the bootstrap.dat file in the AppData/Roaming/Bitcoin or ~/.bitcoin folder. You can leave everything else in that folder untouched, just add the bootstrap.dat file in the Bitcoin folder. I left bootstrap.dat in there, and finally Bitcoin-QT found it, and on the bottom it states \"Importing blocks from disk...\" I'm currently at 80 weeks behind on the update, compared to 240+. I was reading crap about using the -loadblock command and extracting/unzipping the .dat file.... well this wasn't needed. At least it isn't needed on the current version of QT, which I believe is .8.0.5",
      "I tried putting blockfile in .bitcoin directory and starting ./bitcoind but doesn't works. By the way, this method works best for me. ./bitcoind -loadblock=~/.bitcoin/bootstrap.dat You need to use loadbloack syntax with the ./bitcoind ."
    ]
  },
  {
    "question": "How to decode private key from Android Bitcoin Wallet?I want to import my private key from the android's Bitcoin Wallet (the one created by Andreas Schildbach) but it can export it only in an encrypted way. How do I decrypt the file so I can import the key to my Bitcoin Qt?",
    "answers": [
      "from: https://github.com/schildbach/bitcoin-wallet/tree/master/wallet The backup file is encrypted using your chosen password. You can use OpenSSL to decrypt: openssl enc -d -aes-256-cbc -a -in",
      "If anyone is trying this in 2017, openssl has now defaulted to use SHA256 instead of the MD5 assumed in the older answers. Add \"-md md5\" (no quotes) to your openssl command line string. https://superuser.com/questions/1245384/openssl-bad-decrypt-between-0-9-8o-and-1-1-0f For example, originally without that MD5 option I was seeing: $openssl enc -d -aes-256-cbc -a -in bitcoin-wallet-backup-2017-09-28 -out decrypted enter aes-256-cbc decryption password: ****** bad decrypt 140031244338432:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:../crypto/evp/evp_enc.c:535: But then with the MD5 option: $openssl enc -d -aes-256-cbc -a -in bitcoin-wallet-backup-2017-09-28 -out decrypted -md md5 enter aes-256-cbc decryption password: ****** It runs successfully and creates a file called \"decrypted\" which is mostly binary data but starts with ^Vorg.bitcoin.production^R and contains your 12 word mnemonic as text near the top of the file."
    ]
  },
  {
    "question": "Can two private keys generate the same (public) Bitcoin address?I know that private key is generated randomly by wallet. Is it possible that wallet generate the same address which is used in Bitcoin? In other words: Given two private keys k a ≠ k b , is it possible that they both generate the same public Bitcoin address?",
    "answers": [
      "Yes, you can have two keys generate the same address . There are 2^160 possible addresses, and 2^256 possible private keys, so each address corresponds to roughly 2^(256-160)=2^96 private keys. Any of these will generate the same address and thus be able to spend the money owned by that address. Since 2^160 is so large, however, it would take a near-eternity to find any collisions. Whether two private keys can generate the same public key is another question. I think the answer is yes, but I am not sure on that. The public key in uncompressed form consists of two 256-bit numbers, which are X and Y coordinates on an elliptic curve. However, the compressed form is just the X coordinate plus a bit , from which you can calculate the whole public key. This means the space is (at most) 2^257. Unless there is a one-to-one mapping due to the mathematical properties of the cryptography used, each compressed public key corresponds to roughly 0.5 private keys (with the same distribution you'd get from picking a random number from 1 to 2^257, 2^256 times), so some private keys will collide, while others will not. Actually finding any pair of different private keys that generate the same public key or address would be quite difficult. Either it would involve a huge amount of computation and/or luck, or it would be due to finding a serious vulnerability in the algorithm(s) used.",
      "private keys above the group order have the same addresses as the keys starting at 0. 0000000000000000000000000000000000000000000000000000000000000000 fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a 0000000000000000000000000000000000000000000000000000000000000001 fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142 1EHNa6Q4Jz2uvNExL497mE43ikXhwF6kZm 0000000000000000000000000000000000000000000000000000000000000002 fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364143 1LagHJk2FyCV2VzrNHVqg3gYG4TSYwDV4m 0000000000000000000000000000000000000000000000000000000000000003 fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364144 1NZUP3JAc9JkmbvmoTv7nVgZGtyJjirKV1 ... 000000000000000000000000000000014551231950b75fc4402da1732fc9bebb fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc 1HtRa3HaTfX4eDrTzkZWfnLD9cZAyhMDEd 000000000000000000000000000000014551231950b75fc4402da1732fc9bebc fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd 1FvN1jJU6kQCub9nQFuJhdfixpBdngxLme 000000000000000000000000000000014551231950b75fc4402da1732fc9bebd fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe 1JHzdjEL4xQ7yifAaQQKAfqPyAN92vfstP 000000000000000000000000000000014551231950b75fc4402da1732fc9bebe ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 12M4QznuNZH2BRVbLK8SKvNqGTPJpCpST7"
    ]
  },
  {
    "question": "Recovering private key when someone uses the same k twice in ECDSA signaturesIn this blog: https://web.archive.org/web/20160308014317/http://www.nilsschneider.net/2013/01/28/recovering-bitcoin-private-keys.html the author showed a case that using same k twice will leak private key. Many people know this method. But I find sometimes, the formula can not give the right answer(or I compute wrong). Look at this, you can verify signatures by public key: public_key = 02a50eb66887d03fe186b608f477d99bc7631c56e64bb3af7dc97e71b917c5b364 msghash1 = 01b125d18422cdfa7b153f5bcf5b01927cf59791d1d9810009c70cd37b14f4e6 msghash2 = 339ff7b1ced3a45c988b3e4e239ea745db3b2b3fda6208134691bd2e4a37d6e1 sig1 = 304402200861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d02206cf26e2776f7c94cafcee05cc810471ddca16fa864d13d57bee1c06ce39a3188 sig2 = 304402200861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d02204ba75bdda43b3aab84b895cfd9ef13a477182657faaf286a7b0d25f0cb9a7de2 So input data: r=0861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d s1=6cf26e2776f7c94cafcee05cc810471ddca16fa864d13d57bee1c06ce39a3188 s2=4ba75bdda43b3aab84b895cfd9ef13a477182657faaf286a7b0d25f0cb9a7de2 z1=01b125d18422cdfa7b153f5bcf5b01927cf59791d1d9810009c70cd37b14f4e6 z2=339ff7b1ced3a45c988b3e4e239ea745db3b2b3fda6208134691bd2e4a37d6e1 I work out: private key = eaa57720a5b012351d42b2d9ed6409af2b7cff11d2b8631684c1c97f49685fbb public key = 04e0e81185567ea58fc7e7258aa4d5c3e201a8d4ce2810c1007d87727a67eeb9a8c2ba06935280209f8bf42fc7603b65095f036044c4124ddf7c6a250cb450e4c8 However, it's wrong. I'm using this python code to compute: # this function is from # https://github.com/warner/python-ecdsa/blob/master/ecdsa/numbertheory.py def inverse_mod( a, m ): \"\"\"Inverse of a mod m.\"\"\" if a < 0 or m <= a: a = a % m # From Ferguson and Schneier, roughly: c, d = a, m uc, vc, ud, vd = 1, 0, 0, 1 while c != 0: q, c, d = divmod( d, c ) + ( c, ) uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc # At this point, d is the GCD, and ud*a+vd*m = d. # If d == 1, this means that ud is a inverse. assert d == 1 if ud > 0: return ud else: return ud + m def derivate_privkey(p, r, s1, s2, hash1, hash2): z = hash1 - hash2 s = s1 - s2 r_inv = inverse_mod(r, p) s_inv = inverse_mod(s, p) k = (z * s_inv) % p d = (r_inv * (s1 * k - hash1)) % p return d, k p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 # this case is right public_key=0x04dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff r =0xd47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 s1=0x44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e s2=0x9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab z1=0xc0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e z2=0x17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc print \"private:%x\\n random:%x\" % derivate_privkey(p,r,s1,s2,z1,z2) print # this case can be wrong public_key=0x02a50eb66887d03fe186b608f477d99bc7631c56e64bb3af7dc97e71b917c5b364 r =0x0861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d s1=0x6cf26e2776f7c94cafcee05cc810471ddca16fa864d13d57bee1c06ce39a3188 s2=0x4ba75bdda43b3aab84b895cfd9ef13a477182657faaf286a7b0d25f0cb9a7de2 z1=0x01b125d18422cdfa7b153f5bcf5b01927cf59791d1d9810009c70cd37b14f4e6 z2=0x339ff7b1ced3a45c988b3e4e239ea745db3b2b3fda6208134691bd2e4a37d6e1 print \"private:%x\\n random:%x\" % derivate_privkey(p,r,s1,s2,z1,z2) In fact, there have another one met this problem: https://crypto.stackexchange.com/questions/16615/ecdsa-how-to-retrieve-a-non-random-k But he didn't gave more infomation, maybe he figured it out. I have not found more people complaining about it, so, it's likely my fault somehow. Can you point out my error? or just point out the right way? Thank you.",
    "answers": [
      "Here is a fun thing about ECDSA signatures: you can always replace s with -s (mod N) and the signature is still valid. So when you are deducing the k value, it is possible that someone else flipped the sign of s and you will have to undo it. So, you have to make a list of candidates for k (kandidates?) and then select whichever one actually works. A good list of k candidates would be: (z1 - z2) / (s1 - s2) (z1 - z2) / (s1 + s2) (z1 - z2) / (-s1 - s2) (z1 - z2) / (-s1 + s2) I like to use the Ruby ECDSA gem to play around with this kind of stuff. Here is the code I wrote which successfully finds the private key for the first input data you gave: require 'ecdsa' public_key_hex = '02a50eb66887d03fe186b608f477d99bc7631c56e64bb3af7dc97e71b917c5b364' msghash1_hex = '01b125d18422cdfa7b153f5bcf5b01927cf59791d1d9810009c70cd37b14f4e6' msghash2_hex = '339ff7b1ced3a45c988b3e4e239ea745db3b2b3fda6208134691bd2e4a37d6e1' sig1_hex = '304402200861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d02206cf26e2776f7c94cafcee05cc810471ddca16fa864d13d57bee1c06ce39a3188' sig2_hex = '304402200861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d02204ba75bdda43b3aab84b895cfd9ef13a477182657faaf286a7b0d25f0cb9a7de2' group = ECDSA::Group::Secp256k1 def hex_to_binary(str) str.scan(/../).map(&:hex).pack('C*') end public_key_str = hex_to_binary(public_key_hex) public_key = ECDSA::Format::PointOctetString.decode(public_key_str, group) puts 'public key x: %#x' % public_key.x puts 'public key y: %#x' % public_key.y msghash1 = hex_to_binary(msghash1_hex) msghash2 = hex_to_binary(msghash2_hex) sig1 = ECDSA::Format::SignatureDerString.decode(hex_to_binary(sig1_hex)) sig2 = ECDSA::Format::SignatureDerString.decode(hex_to_binary(sig2_hex)) raise 'R values are not the same' if sig1.r != sig2.r r = sig1.r puts 'sig r: %#x' % r puts 'sig1 s: %#x' % sig1.s puts 'sig2 s: %#x' % sig2.s sig1_valid = ECDSA.valid_signature?(public_key, msghash1, sig1) sig2_valid = ECDSA.valid_signature?(public_key, msghash2, sig2) puts \"sig1 valid: #{sig1_valid}\" puts \"sig2 valid: #{sig2_valid}\" # Step 1: k = (z1 - z2)/(s1 - s2) field = ECDSA::PrimeField.new(group.order) z1 = ECDSA::Format::IntegerOctetString.decode(msghash1) z2 = ECDSA::Format::IntegerOctetString.decode(msghash2) k_candidates = [ field.mod((z1 - z2) * field.inverse(sig1.s - sig2.s)), field.mod((z1 - z2) * field.inverse(sig1.s + sig2.s)), field.mod((z1 - z2) * field.inverse(-sig1.s - sig2.s)), field.mod((z1 - z2) * field.inverse(-sig1.s + sig2.s)), ] private_key = nil k_candidates.each do |k| next unless group.new_point(k).x == r private_key_maybe = field.mod(field.mod(sig1.s * k - z1) * field.inverse(r)) if public_key == group.new_point(private_key_maybe) private_key = private_key_maybe end end puts 'private key: %#x' % private_key The output of the program is: public key x: 0xa50eb66887d03fe186b608f477d99bc7631c56e64bb3af7dc97e71b917c5b364 public key y: 0x7954da3444d33b8d1f90a0d7168b2f158a2c96db46733286619fccaafbaca6bc sig r: 0x861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d sig1 s: 0x6cf26e2776f7c94cafcee05cc810471ddca16fa864d13d57bee1c06ce39a3188 sig2 s: 0x4ba75bdda43b3aab84b895cfd9ef13a477182657faaf286a7b0d25f0cb9a7de2 sig1 valid: true sig2 valid: true private key: 0xe773cf35fce567d0622203c28f67478a3361bae7e6eb4366b50e1d27eb1ed82e",
      "r =0x0861cce1da15fc2dd79f1164c4f7b3e6c1526e7e8d85716578689ca9a5dc349d s1=0x6cf26e2776f7c94cafcee05cc810471ddca16fa864d13d57bee1c06ce39a3188 s2=0x4ba75bdda43b3aab84b895cfd9ef13a477182657faaf286a7b0d25f0cb9a7de2 z1=0x01b125d18422cdfa7b153f5bcf5b01927cf59791d1d9810009c70cd37b14f4e6 z2=0x339ff7b1ced3a45c988b3e4e239ea745db3b2b3fda6208134691bd2e4a37d6e1 h1 = r*(s1-s2) p1 = (z1*s2) - (z2*s1) h1 = r*(s1+s2) p1 = (z1*s2) - (z2*s1) h1 = r*(-s1-s2) p1 = (z1*s2) - (z2*s1) h1 = r*(-s1+s2) p1 = (z1*s2) - (z2*s1) h1 = r*(s1-s2) p1 = (z1*s2) + (z2*s1) h1 = r*(s1+s2) p1 = (z1*s2) + (z2*s1) h1 = r*(-s1+s2) p1 = (z1*s2) + (z2*s1) h1 = r*(-s1-s2) p1 = (z1*s2) + (z2*s1) print(hex((p1 *inverse_mod(h1, p)) % p)) output: 0xe773cf35fce567d0622203c28f67478a3361bae7e6eb4366b50e1d27eb1ed82e"
    ]
  },
  {
    "question": "How does one mine StellarI was able to mine Ripple for a time using boinc, will Stellar offer something like this? are there other ways to mine Stellar?",
    "answers": [
      "The Stellar network does not have a mining-based currency. At the network's genesis, 100 billion stellars were created. The only other stellar creation mechanism is inflation . To account for both economic growth and lost stellars, there is a fixed 1% annual rate of new stellar creation. These new stellars will be generated on a weekly basis and distributed via a direct voting method. Mining in the Bitcoin network: 1) creates the currency 2)distribute the currency 3) verifies transactions across a distributed, decentralized system. Stellar achieves the first by generating the stellars at genesis. Distribution of stellars is regulated by the Stellar Development Foundation, the nonprofit that supports the protocol. 95% of all the stellars are set to be distributed to as many people worldwide as possible through a series of giveaways specified in their mandate. Stellar achieves the third—decentralized agreement—with the Ripple Consensus Algorithm . In future, Stellar plans to switch to a new consensus algorithm called Stellar Consensus Protocol (SCP). The technical details of SCP are detailed in a white paper by Stanford Professor David Mazieres. One can acquire stellars by trading on an exchange, trading within the Stellar network, being a recipient of inflation voting, and/or through the Foundation's giveaway programs.",
      "\"All these Stellar Cores—the network of nodes—eventually agree on sets of transactions. Each transaction on the network costs a small fee: 100 stroops (0.00001 XLM). This fee helps prevent bad actors from spamming the network.\" https://www.stellar.org/developers/guides/get-started/index.html They collect transaction fee's and offer their core to download.. Sounds like mining fees to me. However they never mention \"mining\" So to mine install the \"core\" software I guess. Trading for XLM or being gifted XLM is not the same."
    ]
  },
  {
    "question": "What advantages and disadvantages does Ethereum have over Bitcoin?What advantages and disadvantages does Ethereum have over Bitcoin? What can you do with Ethereum that you simply cannot with Bitcoin? What price do you pay for these additional functionalities?",
    "answers": [
      "I'll answer the middle question from the White Paper . Bitcoin can allow simple scripting and a weak version of smart contracts. The scripting that you can do has these limitations (quoting from the white paper, where UTXO means \"unspent transaction outputs\") Lack of Turing-completeness - that is to say, while there is a large subset of computation that the Bitcoin scripting language supports, it does not nearly support everything. The main category that is missing is loops. This is done to avoid infinite loops during transaction verification; theoretically it is a surmountable obstacle for script programmers, since any loop can be simulated by simply repeating the underlying code many times with an if statement, but it does lead to scripts that are very space-inefficient. For example, implementing an alternative elliptic curve signature algorithm would likely require 256 repeated multiplication rounds all individually included in the code. Value-blindness - there is no way for a UTXO script to provide fine-grained control over the amount that can be withdrawn. For example, one powerful use case of an oracle contract would be a hedging contract, where A and B put in $1000 worth of BTC and after 30 days the script sends $1000 worth of BTC to A and the rest to B. This would require an oracle to determine the value of 1 BTC in USD, but even then it is a massive improvement in terms of trust and infrastructure requirement over the fully centralized solutions that are available now. However, because UTXO are all-or-nothing, the only way to achieve this is through the very inefficient hack of having many UTXO of varying denominations (eg. one UTXO of 2k for every k up to 30) and having O pick which UTXO to send to A and which to B. Lack of state - UTXO can either be spent or unspent; there is no opportunity for multi-stage contracts or scripts which keep any other internal state beyond that. This makes it hard to make multi-stage options contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary for secure computational bounties). It also means that UTXO can only be used to build simple, one-off contracts and not more complex \"stateful\" contracts such as decentralized organizations, and makes meta-protocols difficult to implement. Binary state combined with value-blindness also mean that another important application, withdrawal limits, is impossible. Blockchain-blindness - UTXO are blind to blockchain data such as the nonce, the timestamp and previous block hash. This severely limits applications in gambling, and several other categories, by depriving the scripting language of a potentially valuable source of randomness. Ethereum is designed for contracts and in fact implements a Turing-complete virtual machine on the blockchain."
    ]
  },
  {
    "question": "What is the use case of bitcoind ZeroMQ?What is the use case of ZeroMQ implementation for bitcoind which will be merged into Bitcoin Core v0.12.0? Block and Transaction Broadcasting With ZeroMQ https://github.com/bitcoin/bitcoin/blob/master/doc/zmq.md",
    "answers": [
      "ZeroMQ is a publisher / subscriber messaging system. In the case of Bitcoin Core it is a socket which other applications can connect to and get notifications of new events in real time, without having to repeatedly ask the daemon if there are any new events. ZMQ support is useful for any systems interfacing with the network like miners and wallets, which can choose to subscribe either to just transaction notifications or block notifications as their situation requires. It covers a lot of the same use area as the prexisting walletnotify and blocknotify systems, but with significantly improved performance and ease of configuration. These older systems have the unfortunate side effect of spawning a new process for every notification, which tends to incapacitate the host if not used extremely carefully."
    ]
  },
  {
    "question": "What are the trade-offs between transacting on Lightning Network and Bitcoin mainchain?Lightning network's first prototype code is online, so it's about time we learn more about what it is. (At least I wish some people would…) What are the expected trade-offs of Lightning Network to Bitcoin mainchain? Some points that would be nice if they got covered: privacy confirmation speed fees time until spendable And for the bonus: Will Lightning Network be centralized?",
    "answers": [
      "Below describes these points during what's planned to be normal operation. Once a channel needs to be torn down because of a problem with one of the nodes (evil or accidental) some of these answers are a little different. privacy - Privacy is not a linear scale, but there are a few factors that clearly improve privacy: Very few transactions actually end up on the permanent and public blockchain. And those are a payment from you to an LN node (or vice versa) and there is no record on the blockchain of the actual destinations (or sources) of the money. Routing of messages (and LN transactions) will be done in a Tor like fashion (Onion routing) with encryption of the message such that intermediate nodes can't read the transactions nor do they know the true origin or destination (IP address) of the transaction. To obfuscate your actions, you can pay to yourself from one channel to another, and I'd assume it's a lot easier to do quick and trustless mixing through LN. confirmation speed - You don't need to wait for any confirmations at all, so transactions are truly instant. Network latency (multiple hops) will be the deciding factor as all encryption and other overhead is low even for relatively low end hardware (phones). fees - Every hop will want a little bit of fee for the service of forwarding your transaction. This can be pretty tiny though, allowing for true micro payments. In some cases nodes might want to balance out their channels and give you negative fees depending on which direction the money is flowing. This will create an interesting market between all the nodes offering their services and keeping fees fair and low. time until spendable - Immediate. Any money you receive on a channel you can immediately spend again (through the same channel). If you want to settle on the blockchain and then spend the bitcoins there, you'll first have to close the channel, which under normal conditions requires the standard 10 minutes confirmation time (you don't need more confirmations, although the person you are sending the Bitcoins to might still require 6 confirmations). centralized - The software is fully open source. Any one can start up a node, put some Bitcoins in and start offering their service to the network and earn some fees for doing it. This low barrier to entry and ease of use should provide enough competition and enough nodes to make it decentralized. There are some caveats: people will have to put some funds into the node that are at risk if the device gets hacked (initially possibly through bugs in LN, but in general through any malware or badly secured and outdated operating systems). This might be a slightly centralizing force as security is relatively cheaper to do at scale. DOS protection might be something to think about too. Maybe have the option of using a 3G phone or other channel invisible to the attackers (even sneakernet!) when a true attack is underway and you need to close some channels before they expire. Very little bandwidth is necessary to do that, I'm not sure a DOS attack make uploading a few transactions impossible anyway. Also I think it's required (or maybe just wise) to run a full Bitcoin node (possibly pruning) on the LN node. LN needs to have access to the blockchain data in a trustless way and need to be able to send transactions to the Bitcoin network reliably in case it's necessary to tear down a payment channel (within a certain timeout). A pruning full node is not that bad to run, but there's a bit of cost that would be lower in a centralized situation.",
      "1.Privacy: All are better than before. 2.Confirmation speed , Good and bad. It's complicated: a) Good : If you already have a channel with other party, it's an instant transfer. b) Bad : If you are new to each other, it takes minimum 1 block time (10 mins) to create a channel and you both need to drop funds into that channel. After the lightning transaction, you need at least another 1 block time to close the channel, so the fund can be spent again to others. c) Worst : If another party transfer you the fund, but refuse to close the channel(or simply go offline before the channel close), your single-side application to close the channel will take 1.5 weeks or so, to make that fund re-spendable. d) Special : The market may lead to a situation that a \"Super Node\" may show up who already have millions of pre-build channel with everyone. So everyone can transfer fund to each other fast. I will explain below. 3.Fees Generally it will get lower, very close to 0. 4.The Centralize : a) Sooner or later, the vendors (online market or local coffee shop etc.) will encourage people to create a channel with a \"good node\" in advance, for the always faster transaction experience. It costs almost nothing to users anyway. The \"super nodes\" may start small like a \"Sydney local transaction node\". Everyone who linked to that node can transfer fund to each other without a delay. Easy for you to buy a cup of coffee in Sydney. Eventually, some nodes may get bigger, like people will find that if we all join \"Australian Super Node\", we don't need the \"sydney node\" anymore. At the end, There may be 2~6 \"super nodes\" alive in the world, who have pre-build channel with almost every bitcoin user (people link to them voluntarily) then everyone transfer to anyone will be lightning fast. b) The \"super nodes\" doesn't have your funds . The bitcoins you deposit into a channel is moved to a virtual multi-sig address, and the flow of the fund is decided by the \"smart contract\", it means: If the \"Super nodes\" got hacked, your money is still yours , since the \"super node\" doesn't have your signed contract saying you give up your money. Same as if you holding a signed contract saying you received the fund from another user B, the contract will still be valid and you will have that money. So the \"Super node\" is behaving like a \" Powerless Middleman \" who help to pass the fund around, without the ability to modify anything, even it got hacked. c) People don't need to care too much about who is the \"Super nodes\", since they are powerless and everyone can be a new super node. The only thing that worries me is in that future, if 1~2 super nodes suddenly break down one day, there will be tons of \"closing channel\" and contract reset requests go back to the main blockchain (suddenly from millions of users). How the main blocks will handle that kinds of flood is still unknown."
    ]
  },
  {
    "question": "How to build a bitcoin trading botI'd like to experiment with bitcoin technology, crypto currency, and encryption. I thought the best way to accomplish that is building my very own bitcoin trading bot. It seems like a daunting task, but I think I can accomplish this in the following outlined steps: The bot has to be connected to a wallet. I think I can accomplish this by connecting it to a 3rd party wallet with public API. My bot has to be connected to an exchange that also provides public API which allows automated buying and selling My bot has to be able to read the exchange's order book and price. Create a simple algorithm for trading. I'd like to know, what is the best way to build a wallet for my bot? And which exchange should I connect my bot to? I know I am probably missing some key points. So if someone can point me to the right direction, I'd greatly appreciated. Thanks",
    "answers": [
      "Building trading bots that interact with the exchanges is very similar to interacting with other RESTful APIs. Basically, you make query objects to whichever exchange you like to use. Here is a simple example: https://github.com/AdamCox9/nickelbot/blob/master/adapters/poloniex/poloniex_lib.php Nickelbot is development platform written in PHP that has all the boilerplate code for interacting with several exchanges. You can write a bot once, like https://github.com/AdamCox9/nickelbot/blob/master/bots/make_min_orders.php that will give you full control and it works with multiple exchanges. Take a look at all the example code on https://github.com/AdamCox9/nickelbot to see exactly what you need to do.",
      "The key steps you outlined for creating a cryptocurrency trading bot are correct. As for the daunting tasks you can also take a look at my ccxt library from GitHub . It allows to skip steps 1-3 and proceed directly to step 4 (creating your algorithmic trading strategy). But that depends on your development environment and your technical requirements. The ccxt code is in JavaScript / Python (2 and 3) / PHP. You can deploy it from PyPI, with npm (for Node.js) or by cloning from GitHub repository. With it you can access market data and trade bitcoin, ether and altcoins with many crypto currency exchanges. It provides quick access to market data for storage, analysis, visualization, indicator development, trading strategy backtesting, bot programming, building trading algorithms on top of it, webshop integration and related software engineering. The library is under heavy development right now, but already offers a quick-start for trading and technical analysis with many crypto exchange markets out of the box."
    ]
  },
  {
    "question": "Why do you use Bitcoin addresses instead of public keys?Why do you hash the public key twice? Are there security benefits to abstracting away from the public key? Is it because the address can represent multiple things? I'm missing something. Could you theoretically send bitcoins directly to the public key?",
    "answers": [
      "Yes, you could send bitcoins directly to the public key: in fact, both Pay-to-PubKey (P2PK) and Pay-to-PubKey-Hash (P2PKH) were introduced in the first Bitcoin release. IIRC, P2PK is still used for Coinbase transactions sometimes, today. P2PK transactions are slightly bigger for outputs but significantly smaller for inputs. One advantage of P2PKH is that addresses are shorter than public keys. This allows addresses to be represented with 34 characters in Base58check . If there were a standard to present public keys in Base58check, they'd probably have 51 characters. Arguably, it is easier to type a character jumble that is only 34 characters than one that is 51 characters. But really, addresses get used because there is a standard for them and there is none for public keys. Why that is so, I don't know. All credit to Pieter, who has provided the knowledge to amend my errors. ;) Also see this related question: Why does the default miner implementation use pay-to-pubkey?",
      "As @Murch correctly pointed out it is indeed possible to send bitcoin to either a public key or to the hash of a public key. The original motivation for using hashes of public keys was to shorten the size of the address. Public keys in their uncompressed form are 64 bytes long whereas RIPE-MD outputs 20 bytes (+5 bytes of checksum and version). Interestingly Satoshi did not know that public keys could be compressed to 32 bytes +1 bit ( Why does Bitcoin support both compressed and uncompressed keys/addresses? ) and thus chose hashes as a way to get compressed addresses. The security implications are interesting: Unlike public keys, hash functions like SHA-256 and RIPE-MD are believed to be quantum resistant. A quantum attacker could thus efficiently retrieve the private key for any Bitcoin public key but not for a P2PKH address. However, whenever a transaction spends from a P2PKH address it reveals the public key as part of the script. On the other hand the total number of possible address is 2^160 whereas the total number of public keys is roughly 2^256. Theoretically this means that addresses are less secure than public keys against a brute force attack. Obviously, a brute force attack is completely infeasible for either type of address."
    ]
  },
  {
    "question": "Why do we need Proof of Work in bitcoin?I know that proof of work shows that the person has put in some time and power into the processing. I also know that bitcoin mining is adding a transaction into the blockchain and then the miner will need to solve a pow problem. Why do we need this? What if we eliminated the proof of work step for the miners and what are the consequences of doing so?",
    "answers": [
      "Proof of Work (PoW) basically makes sure that miners don’t cheat. There is no way to trust that everyone in the network is honest, so there has to be some way to prevent miners from creating new blocks that benefit themselves. The way it works is that you have a bunch of people all trying to guess the answer to the math problem and no one knows who is going to get the correct answer first. Whoever does get the right answer first gets a reward, but only if all the other miners agree to accept that transactional record (If it becomes apparent that a certain miner is creating fraudulent transactions then the other miners can collectively refuse to accept their contributions). This is why the process of creating a new block is designed to be energy intensive, so that there is a cost associated with creating each new block. This prevents miners from simply creating a whole bunch of new fraudulent blocks with the hopes that maybe they’ll get accepted, because the cost of doing so offsets the potential reward. It helps to think about proof of work as a possible solution to email spam. If there was a requirement for each computer to spend a minute on a PoW problem before every piece of mail was sent, then only people with genuine messages would agree to expend the effort. One minute of computer time is a very low cost for an individual, but the guy who is blasting 10 million spam emails couldn’t afford to wait 10 million minutes to do so. So going back to bitcoin, the chance of each individual miner being the one to solve each block is pretty small, and since it takes a lot of effort to solve the blocks they can’t just spam the network with solutions. This means that they are incentivized to only expend the effort if their contribution is going be accepted by the network. Hope that makes sense. This is the best breakdown I could find ( http://nakamotoinstitute.org/mempool/the-proof-of-work-concept/ )",
      "Imagine I have 1 bitcoin. And imagine I can form a transaction to send that bitcoin to Alice or I can form a transaction to send that bitcoin to Charlie. Now, what stops me from forming both transactions? Nothing. So, if I do that, how will people know which transaction is valid? Clearly, without some reliable way to tell which of those two transactions are valid, the system is doomed. This is what PoW does. A miner cannot contribute PoW to both transactions at the same time -- he must pick one."
    ]
  },
  {
    "question": "Can someone please explain FIBRE to me like I'm 5 and why is it useful?I read the website but they imply you already know why this is valuable. Can someone please illuminate me on this issue?",
    "answers": [
      "First the \"why it matters\": Fibre (Fast Internet Bitcoin Relay Engine) is a protocol which attempts to deliver Bitcoin blocks around the world with delays as close to the physical limits as possible. This is very important because Bitcoin mining is intended to be a fair lottery: If you have x% of the hashrate you should find x% of the blocks, on average. But when it takes time to communicate blocks mining acts more like a race than a lottery: the bigger miner gets an unjust share, creating a pressure to centralize. This is because when a miner makes a block other miners can't work on extending it until they've heard of it, during that time they might make their own blocks. If you are a small miner and make a block this works against you because no one attempts to mine the successor to your block until later. If a larger miner mines a block it also works against you, because you've fallen behind. This race behavior is the same that enables selfish mining. The race effect can also benefit attackers trying to overpower the network, because they don't need to compete with hashrate lost to stale blocks. Improving propagation speeds reduces the race and makes mining more fair, lowers pressure to centralize, and improves network security. Now, \"why is it hard\": The world is a big place and a round trip from San Francisco to Australia is well over 200ms typically. These delays are substantially due to speed of light in fiber and while better routing can improve them somewhat, they aren't going away without through-earth-neutrino communications or other stuff from science fiction. International internet links frequently have packet loss. If you send a message on a 200ms RTT path you can't hear about any missed packets for 200ms, and they can't get any replacements for another 100ms. Traditional transmission protocols like TCP do a poor job of achieving link capacity when delays are high especially if there is any loss. In theory the problem is aided somewhat because 99.9% of the block data is already known because the block mostly contains transactions that have already been broadcast, but unfortunately a node sending a block doesn't know which transactions you'll be missing by the time their block shows up and you telling them will take too long just due to the above mentioned round trip times . What Fibre does do to solve it: Fiber lets you effectively build a distributed node that internally moves a block around the world very close to the lowest one way communications delay between the computers comprising it. The author of fibre used to run one such node on public systems which were well maintained and anyone could connect to. The normal Bitcoin P2P protocol, with BIP152, was used for the last mile-- since that is what BIP152 is optimized for. Similar to BIP152 (which it was co-developed with) Fiber first sends a short block sketch: A list of short hashes and lengths that allow the far end to use its mempool to lay out transactions into a block, with holes in positions where the transactions were missing or the hash was ambiguous. Then Fibre breaks the blocks into packets and sends error correction data. The error correction lets the receiver recover the block as soon as it has received as many packets as missing chunks, even though the sender doesn't know whats missing. Error correcting coding is also used on the initial sketch. This is similar to how Raid or PAR encoding works, but the implementation is made much more complicated by needing to be very fast. All of this communication happens over UDP with pre-programmed transmission rates, so it doesn't need to ramp up slowly or wait for lost packets. The sender also sends different chunks to each of its Fibre peers and those peers themselves relay the chunks among each other as soon as they get them, in order to make use of all the interface bandwidth available. When a Fibre peer gets enough to decode the block they do, and start emitting novel chunks. This process avoids any duplicated data being sent and is highly robust to packet loss as well as link and node failures and achieves very consistent delay. At every step Fibre trades off bandwidth for latency and can send several times the size of the block data in order to achieve the lowest delay across the long-haul links that it rides over. There is a lot more to the details of it, probably enough for two dozen questions. Where did Fibre come from? Fibre was built by Matt Corallo and was the product of several years of experience running earlier fast relay networks as several years of research into fast block propagation techniques. Matt took many ideas that were far too computationally slow to be practical, solved the remaining engineering challenges, optimized the heck out of it and then put the result up on a well curated public system. Good network management and sysadmin work are almost as important to getting low delays as the protocol itself.",
      "FIBRE is valuable as it allows for miners to extremely quickly propagate their blocks to other miners and to the rest of the network. The goal of FIBRE is to reduce latency in block transmission. Miners will thus waste less time on trying to mine a block that has already been found so they will reduce their stale block rates and be working on the latest block almost as soon as it is found and broadcast to the network."
    ]
  },
  {
    "question": "Sync with bitcoin-qt very slow (0,01%)I have the issue that my node's synchronisation is very slow. I am 14 weeks behind and it estimates to take 12 weeks to get synced. The synchronisation rate per hour is only 0,01%. I have a fast broadband connection and no other issues with this PC. It should be able to download the whole blockchain in a few hours. However, the average transfer rate is about 0,5 KB/s. Any idea what the issue might be? I am running v0.14.2 and the number of outgoing connections is 3. I have already changed cache memory to 800 MB but that didn't change anything.",
    "answers": [
      "Bitcoin Core sync very slow Bitcoin Core is capable of full sync in a relatively short period of time depending mainly on the hardware. Most of the work done is not actually downloading the blocks, it is validating them and every transaction that they contain. It not only depends on downloading the blocks but also on the quantity and complexity of every transaction. The downloading of the blocks themselves is usually not an issue if you are connected (outbound) to several nodes. I am able to download blocks generally in forty-five seconds each (which includes the request time etc. and validation as well as the transfer) when I have been offline and am catching up on my restricted local 256Kbps link. My upload speed is low, and latency is high. At the rate of one block per forty-five seconds, it would currently take over two-hundred-and-sixty-three days to complete the whole blockchain as there are more than 506822 blocks as of writing. From my personal experience, the initial sync actually took over five days to complete on a 2.5GHz Core i5 notebook with 4GB of RAM running Fedora with Bitcoin Core v0.15.1. For that, I used ADSL2+ and never perceived the actual downloading of the blocks to be the issue. Performance of initial sync Performance of initial sync largely comes down to the individual performance of your computer, provided your internet is fine. Always use the latest release version of Bitcoin Core (includes bitcoin-qt and bitcoind) downloaded from the official site at www.bitcoin.org . An upgrade is safe and easy, just safely exit Bitcoin Core first and make a new secure backup of your wallet.dat before you upgrade. Adjusting parameters There are some parameters that you can look at and consider depending on your system. Always make a backup of your wallet before making any changes. The parameters can be entered at the command line or generally in your bitcoin.conf file, which you would need to exit and restart Bitcoin Core in that case to see the effect. Some things to consider that could make a difference: I am presuming here that you are running bitcoin-qt which is the GUI version and not bitcoind. If parameters are used in the bitcoin.conf file, omit the leading - . -datadir= You could have your datadir on a fast drive. If you move your whole .bitcoin folder you will need to specify this parameter on the command line. Note that if you change your datadir and do not copy the .bitcoin folder over to the new location first, it will create a new wallet and begin downloading the blockchain again from the start. -dbcache= The default for this is 450. If you have 8GB of RAM, you could easily set this to 4096 par= The default for this setting is auto, but I do not know what the automatic setting does. You could try setting this to -1 which leaves one core free. -banscore= You could try setting this to 10 to kick off misbehaving nodes sooner. -listen= You could temporarily set this to 0 to disable incoming connections while you get the initial sync done. Your busy node does not need the additional work. After the initial sync, you can revert these settings to their defaults but probably leave your datadir wherever you put it. Some of these parameters are available as options in the bitcoin-qt Settings > Options menu. TLDR; The short answer if you want it fast is, get a fast computer, loads of RAM, a fast HDD and, fast internet. The same as anytime you want anything fast on a computer. In the real world, and from personal experience, using an SSD increased sync speed more than 10x on my example system from the performance noted above. Anecdotes Real life example of varying system performance: I know someone personally who had to work on a quite large, but not extraordinarily large, Illustrator file. He opened it on his ~12-month-old upper spec Mac which usually performs great and, it was virtually unusable (slow to respond). Just for kicks he thought he would try the same file on a bog standard PC, opened it in Illustrator and it was completely normal. Some hardware/software builds have bottlenecks for some processes. The opposite result is probably true for some operations. Also note, I have observed that exiting and restarting Bitcoin Core during initial sync seems to speed it up a bit for a while once it connects to nodes again. Referencing again personal experience, syncing on Windows 10 64-bit seems to be orders of magnitude faster than syncing on Linux on the same hardware - even if Windows is running in Gnome-Boxes, it easily churns through 100 blocks per second during the initial stages of download. Alternatives If you are in serious trouble waiting to sync Bitcoin Core (a full node client) and you do not need the additional features that Bitcoin Core provides then, you may consider trying Electrum (not a full node client) which does not need to do the initial sync. On Fedora 27, getting Electrum is as simple as sudo dnf install electrum .",
      "I had the same problem on a very old machine (with 4 GB RAM and an Intel Core 2 Duo E8400 CPU) running Debian GNU/Linux. I read the very helpful answer of @Willtech and derived the following command: ./bitcoin-qt -banscore=10 -dbcache=1024 -listen=0 This resulted in a sync time of roughly 2 weeks on that PC. Very long indeed but much better than having to buy new hardware..."
    ]
  },
  {
    "question": "Does blockchain without currency make any sense?I keep reading about private companies building blockchains for stuff like supply chain management, and about the billions of dollars that are going to be invested in blockchain over the next 5 years, but there is a gap in the logic here that I don't get. Distributed Ledger Technology is totally reliant on participation to establish the principle of Distributed Trust. If there are not enough independent actors in the network, you cannot rely on the immutability of the ledger. In Bitcoin, the blockchain provides a way for participants to \"profit\", thereby pulling independent participants into the network. Participants are attracted to Bitcoin as they view it as an alternative to another currency (fiat) they perceive to be weakening in value. Private and Consortium blockchains make no sense to me, but let's say some agency decided they wanted to seed a new public blockchain to do something like: verify that a particular coffee brand came from FairTrade sources. How would they incentivise independent actors to verify transactions in this chain? Is it the case that they have to create a token reward, and hope over time that the token develops some minimal transactional value, and hope that early adopters make a return? Why would such actors not just participate in standard cryptocurrency blockchains? It seems like a very hard sell, given the effort involved in running Internet connected hardware. From where I'm sitting, its hard to see how a public blockchain can have any application beyond replacing fiat currency. Is my understanding of this correct?",
    "answers": [
      "There are a number of research papers that cover the question \"Do you need a blockchain?\", e.g. the eponymous paper by Wüst & Gervais (2017) and the extensive Blockchain Technology Overview by NIST (2018) . At a quick glance, the article When do you need blockchain? Decision models. by Meunier appears to provide a survey collecting a broad range of answers to the question. The general gist seems to be that you only need a blockchain if all of the following conditions apply to your use case: an actual business problem that needs solving shared consistent state multiple authors append-only data no sensitive information participants do not agree on single trusted third party Since blockchains are complex and wasteful, they usually are not a better solution to problems that can be solved building on trusted third parties, audits, and distributed databases. If one or multiple of the listed criteria are not met, your problem can likely be more easily solved using these well-explored approaches. Blockchains tend to be the best approach only when they are the only option. Meunier concludes a bit tongue-in-cheek that the only convincing application so far is the creation of unregulated money.",
      "You don't necessarily need to \"buy\" external participants You can have a not-a-cryptocurrency blockchain that's maintained and controlled by a single mostly-trusted entity without any proof of work requirement. This makes the maintenance of the blockchain cheap and efficient, while still enforcing some technical constraints on what that entity can do, reducing the need to trust it. Of course, this assumes some external motivation (legitimate business need) for all the participants. In this case, the immutability of the public ledger is not ensured by distributed proof of work incentives, but rather out-of-bounds verification - if all the involved parties periodically download the ledger, then any tampering with past data would be immediately detectable by everyone. For example, if some shipment of coffee has its providence recorded in such a ledger, then it's not possible for that central \"mostly trusted\" party to \"go back\" and alter the database after some scandal without it being immediately detectable by everyone else. The key security factor that you're gaining is non-repudiation. You can have a shared consensus record of some financial transactions (e.g. a betting pool) on a non-proof-of-work blockchain. It won't be a currency, it won't be a settlement or enforcement mechanism for these transactions (that would happen in the physical world through legal means), but it will be a trustable shared consensus record of commitments made by all the involved parties. Such a record can be trivially verified and there's no need to spend (waste!) resources in motivating third parties to participate in that verification. The other risk factors (reliability, censorship, etc) can be mitigated by legal, non-technical means for many non-currency applications."
    ]
  },
  {
    "question": "Does bitcoin miner heat as much as a heaterIf someone want to heat a room or some water for a defined amount of time and without a worry about the sound produced. Can a bitcoin miner be a good subtitute to a modern heather with the same power consumption ?",
    "answers": [
      "A device that consumes N watts of power (and doesn't output electricity or some other form of energy) will eventually produce N joules of heat per second. Thus, if your goal is converting electricity to heat, every piece of hardware that consumes electricity is 100% efficient. It's completely irrelevant what happens with that electricity before it becomes heat. Of course, you need to take hardware depreciation/maintenance costs into account. Also of note: as heating devices, heat pumps have over 100% efficiency, as they simultaneously consume electricity (which is turned into heat) and move additional heat from a colder area to a hotter one.",
      "It may be practical to use a miner to provide some of the heat for your home, bringing some miners into your home during the cooler months and moving them elsewhere during summer. It's pretty much 100% efficient at converting electric energy into heat energy. (vs. a heat pump being about 300% efficient 1 , moving existing heat from outdoors as well). Even a lightbulb that turns some power into visible light will ultimately heat the room when that light is absorbed by the walls. (Unless some light escapes out windows). A fan moves air, but that air movement energy ultimately ends up as heat unless the moving air goes out a window. More-ordered (low entropy) forms of energy naturally convert to high-entropy non-concentrated heat; heating a room is one time the 2nd law of thermodynamics is on your side. (However, the 2nd law is why heat wants to flow from your warm house to the cold outdoors; that's why you insulate your walls.) TL:DR: pretty much any form of energy can efficiently turn into heat. Footnote 1: Modern heat pumps often have something like 330% efficiency when not too cold outside. According to this Canadian government page about heat pumps , air source heat pumps typically achieve a 3.3 ratio of heat out to input power at 10°C (cool day), or 2.3 at -8.3°C (well below freezing). So they're about 230 to 300% efficient most of the year. vs. 100% for a fully indoor space heater or computing equipment. Using electric power to run a miner instead of a heat pump is an opportunity cost, if it would be possible to install a heat pump. So the coins you mine have an opportunity cost: you could have gotten more heat for the same power input. But if you were going to be using electricity to do any mining at all, using the heat output for something useful is good, when possible. If the alternative is putting your mining rig in an uninsulated shed or something and still needing to heat your home, that's worse than having some mining power heating part of your house. As others have pointed out, you wouldn't want to try to provide all the heating via mining : heating needs are highly variable (depending on weather, sunlight through the windows, and other heat sources like using your oven for cooking), but you normally want your bitcoin mining to be on all the time. (To pay for the initial investment of buying the expensive hardware which costs much more than a dumb space heater; basically just some resistive wire that you put voltage across.) The amount of mining power you can have indoors in a given month without causing a problem is approximately the best case (smallest) amount of heating that you'll need at any time that month. The rest of the heating load should come from thermostat-controlled regular heating, like a heat pump, oil or gas, or worst case dumb electric heat that just gets hot. (And hopefully that heating system distributes heat around your home better than a miner in one spot, modulo whatever air circulation you arrange to move the mining heat around.) This \"safe\" amount of mining might be a few hundred watts, again depending on the month and the size of your home, and if you can hook it up to an existing air circulation mechanism to distribute heat around instead of making one room hot. If you had more mining power indoors, you'd need some of it on a thermostat, to shut itself down when the room gets above human-desired temperature. (Or put it in an uninsulated basement where it keeps your floors warm, but lots of extra heat can just escape into the ground. Or in the winter, an attic.) If you have some older less-efficient miners, setting up your computer to stop those first when the temperature rises could make sense. You wouldn't want to buy a lot of mining hardware that would only be on part of the time; that wouldn't be worth the investment. But some semi-obsolete gear could be worth running if the power was effectively cheaper (because you need the heat anyway, and don't have a heat pump). Bitcoin mining is arguably not a great thing to dump a lot of electrical power into (for environmental reasons), so I'm certainly not suggesting trying to max out your mining by using it to heat your house. Especially if you can get a heat pump instead, and/or your local area doesn't have more renewable energy than it can use (so extra power use means more oil or coal being burned somewhere). But if you do want to mine anyway, use some of that waste heat in the winter."
    ]
  },
  {
    "question": "Effect on economy if Bitcoin was widely adoptedWhat would the effects be on the world economy if several million people around the world would utilize the Bitcoin currency for their daily transactions? Would you expect the GDP to grow faster or slower and why? I am interested in this, because the first thing I want to get straight is whether I would contribute something positive if I supported the project.",
    "answers": [
      "GDP would accelerate because of less transactional friction.",
      "If people are worried about deflation they really need to distinguish what kind of deflation they are referring to. Asset deflation or monetary deflation. The real issue with our economy right now is the fact we have asset deflation coupled with monetary inflation which is the worst of both worlds. I believe asset deflation along with monetary deflation would be less problematic than most people think. Maybe lemonginger was right, it is a very big concept. We are not even talking about the further implications bitcoin will bring into contract-commercial law. All of which I believe are a positive personally. This is a huge subject."
    ]
  },
  {
    "question": "What are the perceived advantages of bitcoin as a means of exchange?There are lots of ways to send money - western union, paypal, bank wire, etc that are more established and fairly quick. What are the advantages of using bitcoin from a bitcoin-proponent's point of view?",
    "answers": [
      "The primary advantages are: Speed and price. You can transfer money anywhere in the world within minutes with negligible fees. No central authority. Bitcoin is not dependent on any company or government to maintain its value. You can start accepting bitcoins instantaneously, without setting up merchant accounts, buying credit card processing hardware, etc. Bitcoins are less traceable than many types of monetary transactions (though not anonymous). Bitcoins cannot be counterfeited and transactions cannot be reversed. No transaction blocking or account freezing. We have seen governments freeze bank accounts of dissidents and payment processors refuse to process certain types of transactions (wikileaks, online gambling in the US, etc). With bitcoin this is impossible. A known amount of inflation. Bitcoin is seen as a store of value because the total number of bitcoins that will ever be created is known in advance and it is impossible to create more than that."
    ]
  },
  {
    "question": "Does flattr complement or compete with bitcoin?I realise that the underlying technologies for Bitcoin and flattr are different, but do they serve the same purpose? For example: if I set up a webapp that uses micropayments for revenue (like github - being able to buy private repositories) would it make more sense to use flattr or Bitcoin? Would I use them in concert - Bitcoin for micropayments, flattr for \"charity\" like payments for people who just want to support the site, but don't need extra functionality? Does Bitcoin have a clear advantage over flattr for certain situations and clear disadvantages in others?",
    "answers": [
      "Flattr is a social micropayments system. Bitcoin is a currency. There is no reason the two could not be integrated together, pay with bitcoins and then share the bitcoins out using the same method as flattr. In fact, I would go as far as saying this would be an excellent idea due to lack of transaction fees and friction for small amounts. Flattr is the service, Bitcoin is the currency. They don't compete; they could certainly complement each other though, in my opinion.",
      "Regarding the specific questions about your website, it is up to you to decide which payment methods to accept. If you want to accept small payments, Paypal and credit cards may not interest you because of their high fees. So both Flattr and Bitcoins can replace Paypal as an alternative for cheaper micro-payments. As for advantages/disadvantages: Flatter charges 10% of your income Bitcoins are not limited to small payments (you can accept any amount of them without fees) Bitcoin price fluctuates a lot right now - you might want to consider using bit-pay if you want a steady income. Like other answers stated, you must understand that these are different systems. One is a currency and the other is a service. They can complement each other and you don't lose anything by accepting both."
    ]
  },
  {
    "question": "Why can't I get over 8 connections on my client?How do I make my client acquire more than 8 connections? What settings in firewall and operating system, or flags at execution do I need to use to allow it?",
    "answers": [
      "Typically connection counts of 10 or lower usually indicate that you are behind a router or firewall that is not configured properly. Try enabling UPnP from within the Bitcoin client's options dialog. If that doesn't work, try manually forwarding port 8333 to the computer which is running the Bitcoin client/daemon.",
      "A) To disable the half-open TCP connections limit, set the value of the EnableConnectionRateLimiting DWORD registry entry to 0 (0x00000000). To do this, follow these steps: 1. Click Start, type regedit in the Start Search box, and then click regedit.exe in the Programs list. If you are prompted for an administrator password or for confirmation, type your password, or click Continue. Locate and then double-click the following registry key: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters \\EnableConnectionRateLimiting In the Value data box, type 0, and then click OK. Exit Registry Editor. 5. Restart the computer. B) Open the command prompt and use the following opening switches, alternatively you could plug the switches into the properties of your exec. shortcut. bitcoin-qt -maxconnections=1000 -maxreceivebuffer=5000 -maxsendbuffer=128 -upnp=1 -seednode=69.246.237.30:8333 -seednode=66.103.14.157:8333 -seednode=47.221.170.251:8333 -seednode=207.172.126.186:8433 -seednode=68.99.179.170:8333 -seednode=52.54.198.224:8433 -seednode=73.252.200.173:8333 -seednode=96.249.247.157:8333 -seednode=47.147.194.182:8333 -seednode=98.206.255.202:8333 -seednode=70.62.132.134:9333 -seednode=107.189.36.4:8333 -seednode=35.198.150.233:8333 -seednode=100.8.165.86:8333 -seednode=100.11.81.93:8333 -seednode=72.224.101.65:8334 -seednode=136.61.154.117:8333 -seednode=34.225.107.142:8333 -seednode=70.181.115.20:8333 -seednode=47.88.33.248:8333 -seednode=54.175.243.122:8333 -seednode=107.23.184.33:8333 -seednode=54.183.187.249:8333 -seednode=13.56.168.64:8333 -seednode=54.183.216.238:8333 -seednode=47.88.76.190:8333 -seednode=54.215.248.143:8333 -seednode=47.88.32.206:8333 -seednode=47.88.78.14:8333 -seednode= -seednode=[2001:470:b3d5:1:641c:6bff:fe9d:bccf]:8333 -seednode=[2601:601:1380:395:c1a:622c:4dd5:363d]:8333 -seednode=[2601:240:d002:2979:69fc:f725:bdc:d8ec]:8333 -seednode=[2601:601:cf80:3e44:f34:2645:867d:f7f6]:8333 -seednode=[2601:441:4480:1618:1077:aa2c:2d9:b5e]:8333 -seednode=[2601:441:4480:1618:1077:aa2c:2d9:b5e]:8333 -seednode=2601:c0:c100:1880:21f:5bff:fe3c:6e84]:8333 -seednode=[2603:3024:181e:3200:ec4:7aff:fe6b:8826]:8333 -seednode=[2601:445:4380:3692:260a:64ff:fe92:15ed]:8333 -seednode=[2001:558:6024:8:45ab:91b9:1f6c:f673]:8333 -seednode=2601:241:301:3ca5:45ff:3590:18bb:abc3]:8333 -seednode=[2601:380:4102:abe0:c9b2:6874:d4aa:2dfc]:8333 -seednode=[2601:446:c200:3580:7161:8278:33fe:effa]:8333 -seednode=[2601:644:8600:4875:470:de72:7c3e:f326]:8333 -seednode=2601:6c3:8380:143c:134:2d28:b933:755d]:8333 -seednode=[2601:1c2:600:bb:ab55:7b10:9f49:c333]:8333 -seednode=[2603:3024:1890:0:88f7:b3ff:feda:18d5]:8333 -seednode=[2002:496d:6fc3:e472:604b:e70c:fe47:d969]:8333 -seednode=2601:408:8100:1480:8ccc:6d53:5a67:2f82]:8333 -seednode=[2601:408:8100:1480:8ccc:6d53:5a67:2f82]:8333 -seednode=[2601:40a:202:6ff0:7cb9:6352:19df:f2b6]:8333 -seednode=[2603:3022:501:7800:495c:728c:ed5d:5d75]:8333 -seednode=2601:152:4400:1d50:30d6:854e:d379:2be]:8333 -seednode=[2601:101:c100:cd69:cd5a:41e:ff56:cf5d]:8333 -seednode=[2601:646:8e80:3ff9:d250:99ff:fe83:a470]:8333 -seednode=[2002:c1c6:6623::c1c6:6623]:8333 -seednode=[2002:58de:961e::58de:961e]:8333 -seednode=[2a04:c000:ed51:917:68::1]:8333 -seednode=[2605:a601:a48:a900:3c1a:85a:1a1:120a]:8333 -seednode=[2001:470:1f12:1dd::2]:8333 -seednode=[2001:470:1f12:1dd::2]:8333 -seednode=[2001:19f0:ac01:3f7:5400:1ff:fe43:e94b]:8333 -seednode=[2604:e880:0:15:ec4:7aff:fe4a:40e1]:8333 -addnode=69.246.237.30:8333 -addnode=66.103.14.157:8333 -addnode=47.221.170.251:8333 -addnode=207.172.126.186:8433 -addnode=68.99.179.170:8333 -addnode=52.54.198.224:8433 -addnode=73.252.200.173:8333 -addnode=96.249.247.157:8333 -addnode=47.147.194.182:8333 -addnode=98.206.255.202:8333 -addnode=70.62.132.134:9333 -addnode=107.189.36.4:8333 -addnode=35.198.150.233:8333 -addnode=100.8.165.86:8333 -addnode=100.11.81.93:8333 -addnode=72.224.101.65:8334 -addnode=136.61.154.117:8333 -addnode=34.225.107.142:8333 -addnode=70.181.115.20:8333 -addnode=47.88.33.248:8333 -addnode=54.175.243.122:8333 -addnode=107.23.184.33:8333 -addnode=54.183.187.249:8333 -addnode=13.56.168.64:8333 -addnode=54.183.216.238:8333 -addnode=47.88.76.190:8333 -addnode=54.215.248.143:8333 -addnode=47.88.32.206:8333 -addnode=47.88.78.14:8333 -addnode= -addnode=[2001:470:b3d5:1:641c:6bff:fe9d:bccf]:8333 -addnode=2601:601:1380:395:c1a:622c:4dd5:363d]:8333 -addnode=[2601:240:d002:2979:69fc:f725:bdc:d8ec]:8333 -addnode=[2601:601:cf80:3e44:f34:2645:867d:f7f6]:8333 -addnode=[2601:441:4480:1618:1077:aa2c:2d9:b5e]:8333 -addnode=2601:441:4480:1618:1077:aa2c:2d9:b5e]:8333 -addnode=[2601:c0:c100:1880:21f:5bff:fe3c:6e84]:8333 -addnode=[2603:3024:181e:3200:ec4:7aff:fe6b:8826]:8333 -addnode=[2601:445:4380:3692:260a:64ff:fe92:15ed]:8333 -addnode=[2001:558:6024:8:45ab:91b9:1f6c:f673]:8333 -addnode=[2601:241:301:3ca5:45ff:3590:18bb:abc3]:8333 -addnode=[2601:380:4102:abe0:c9b2:6874:d4aa:2dfc]:8333 -addnode=[2601:446:c200:3580:7161:8278:33fe:effa]:8333 -addnode=2601:644:8600:4875:470:de72:7c3e:f326]:8333 -addnode=[2601:6c3:8380:143c:134:2d28:b933:755d]:8333 -addnode=[2601:1c2:600:bb:ab55:7b10:9f49:c333]:8333 -seednode=[2603:3024:1890:0:88f7:b3ff:feda:18d5]:8333 -addnode=2002:496d:6fc3:e472:604b:e70c:fe47:d969]:8333 -addnode=[2601:408:8100:1480:8ccc:6d53:5a67:2f82]:8333 -addnode=[2601:408:8100:1480:8ccc:6d53:5a67:2f82]:8333 -addnode=[2601:40a:202:6ff0:7cb9:6352:19df:f2b6]:8333 -addnode=2603:3022:501:7800:495c:728c:ed5d:5d75]:8333 -addnode=[2601:152:4400:1d50:30d6:854e:d379:2be]:8333 -addnode=[2601:101:c100:cd69:cd5a:41e:ff56:cf5d]:8333 -addnode=[2601:646:8e80:3ff9:d250:99ff:fe83:a470]:8333 -addnode=[2002:c1c6:6623::c1c6:6623]:8333 -addnode=[2002:58de:961e::58de:961e]:8333 -addnode=[2a04:c000:ed51:917:68::1]:8333 -addnode=[2605:a601:a48:a900:3c1a:85a:1a1:120a]:8333 -addnode=[2001:470:1f12:1dd::2]:8333 -addnode=[2001:470:1f12:1dd::2]:8333 -addnode=[2001:19f0:ac01:3f7:5400:1ff:fe43:e94b]:8333 -addnode=[2604:e880:0:15:ec4:7aff:fe4a:40e1]:8333"
    ]
  },
  {
    "question": "What protection does Bitcoin have against Denial of Service (DoS) attacks?What protection does Bitcoin have against DoS attacks? Could you bring down a node by flooding it with data? What happens if someone starts flooding the network with legitimate, yet nonsense, transactions? For example, sending bitcoins from A -> B -> C -> A -> B -> C -> A and so on in a rapid pace.",
    "answers": [
      "The network has a moderate amount of protection against DoS attacks. If you flooded a single node with data from a single source, it would just drop you. You could reconnect, of course. You would need a lot of resources and effort to knock out a node, but it's possible to knock out a single node by overloading it. The owner of an attacked node could simply stop accepting incoming connections and he could still operate. He still might, by sheer bad luck, make some outgoing connections to malicious nodes. But he'd quickly close all such connections and be left only with connections to non-malicious nodes. Transaction flooding is perhaps the DoS attack for which the network is currently best defended. Trying to flood the network with legitimate, but nonsense transactions won't work very well. To form such a transaction, you have to claim some coins. The network will only maintain one transaction that claims a given output. And to claim newer output generally requires a transaction fee. It's hard to imagine any scenario in which an attacker could maintain a significant number of concurrently valid transactions without paying large transaction fees. And even if he could, as soon as those were accepted, he'd need to be able to claim additional transaction outputs to keep up the flood. The outputs of the transaction from earlier in the flood would be too new to spend without fees. In any event, the harm would be minimal. If this were working to cause harm, that would mean legitimate transactions wouldn't be going through. This means their coins would be getting older and older while the attack had to consist of newer and newer transaction outputs. Soon, the legitimate transactions would win."
    ]
  },
  {
    "question": "Solo Mining vs Pool Mining for users with high computing powerLet's say that a user has a decent amount of computing power. At the current difficulty of 1777774.4820015, he could have for example 10Gh/s (he would earn around 5 BTC per day according to a calculator ). Is it more profitable for him to solo mine or to pool mine? What are the differences in this situation?",
    "answers": [
      "It completely depends on the \"pool fee\". Theoretically, with a zero percent pool fee, solo mining and pooled mining should, over the long term, produce precisely the same revenue. The only exception is that some (most) pools keep the transaction fees for themselves. If you mine solo, with an expected 5 BTC/day take, that will mean on average you'll mine a 50 BTC block every ten days. It will be completely random though. You could mine two blocks in a day. You could go three weeks without a block. When the difficulty changes, not only will the amount you get paid change (that always happens) but the time between payments will change drastically as well. If you mine in a pool, you take the pool fee right off the top. A 3% pool fee means you make 3% less. Also, most pools don't pay transaction fees. But your revenue is more predictable. You'll get paid on a regular basis and your payments won't vary much (until the difficulty changes, of course). One advantage to solo mining is that it's more reliable. Pools have outages and have had a problem with denial of service attacks lately. Mining solo, you aren't relying on other people's systems to keep your mining going. If you pick a very reliable pool, or use a mining proxy with a \"fallback pool\" configuration, this isn't a major issue. One advantage to pooled mining is that you get to use the pool's tools. These include things like web-based control panels, alerts, and so on.",
      "The rule of thumb I recommend is to solo mine when you have enough hash power to generate at least one block per day on average and use a pool if you have less than that. You can expect the pool to take between 1 and 3% for their service, but that's a better alternative to the prospect of being unlucky and not getting a block before the next difficulty retarget."
    ]
  },
  {
    "question": "How would the Bitcoin protocol be impacted if nodes only stored the blocks they cared about?Right now, full clients of the Bitcoin network store every block ever generated (while \"thin\" clients instead rely on a node which does so). This greatly increases first-time initialisation for the client, and also has significant implications for network overhead, amongst other things. How would the network be impacted if nodes instead stored only the headers of most blocks in the blockchain until or unless they \"needed\" the actual block? These situations are fairly common, such as: verifying the validity of each new block as it is found and transmitted to the network any time the client is sending or receiving bitcoins etc. so that in general clients would still download all blocks broadcast when they were online. However they would be able to: purge blocks they \"don't care about\" if storage space is limited in the typical case, start sending and receiving bitcoins after downloading only the few most relevant blocks (and all the headers of course) etc. Note that there are usually several entities \"invested in\" the continued availability of a given block, such as the original miner, who wants their 50 btc earned to remain valid, and anyone who received bitcoins from transactions in that block. However, one intriguing consequence of this scenario would be that miners are incentivised to include as many transactions in their blocks as possible (currently one can mine without including any transactions if one so desires). What would the other impacts on functionality and security be? Edit: I'm looking for a better answer than \"I think it would destabilize the network\" here--I want to see some estimated impacts on block availability, network overhead up or down once the lower amount of downloading is contrasted with re-downloading later, etc. Some statistics on how inter-dependent blocks are alone would go a long way towards a solid answer. Edit 2: Right now this bounty's going to Shadders in a couple of hours. But if anyone had more detailed info on the information I asked for in my first edit, they could definitely snipe it. Any takers?",
    "answers": [
      "There is proof of concept work in progress right now to solve this problem. Basically by creating hub nodes capable of handling many thousands of connections. These hub nodes are in fact a proxy backed by a real satoshi bitcoin daemon. This will relieve standard bitcoin nodes from a lot of the connections being used up by these 'selfish' nodes and allow them to continue operating as do now. Mining pools will have a strong incentive to run hub nodes as it will speed up propogation of their generated blocks as well as ensure they have the best chance of getting new blocks as quickly as possible.",
      "I think if this became extensive, this would destabilize the entire network. Since nobody wants that, it won't become extensive. The most fundamental thing the client does is decide what the current valid block chain is. Suppose I see two competing hash chains on the network. How can I know which one I should follow? The answer is to first make sure both chains are valid -- an invalid block chain can never win. How can I validate the hash chain if I can't make sure each transaction input in it validly claims a previous transaction's output? How can I do that without a full transaction table? Suppose I see a transaction that claims someone sent me 50 Bitcoins. How can I determine those 50 Bitcoins are in fact valid? Well, I have to make sure that each input in that transaction validly claims an output from a previous transaction. How can I do that if I don't have the full transaction set? In other words, a client cannot determine if it has received funds if it does not have access to a map of every unclaimed transaction output indexed by transaction ID."
    ]
  },
  {
    "question": "Can a bitcoin transaction be reversed from the receiving end?I know this seems like a duplicate of the question 'Can a bitcoin transaction be reversed?' but none of the answers there were explicit enough as they all seemed to assume reversal triggered from the sending side. I guess a secondary part of my question is 'What would happen if a merchant just sent the funds back to any one of the input addresses that was used in the original transaction?' Would the money be effectively returned to my control?",
    "answers": [
      "When sending coins, the original Bitcoin client picks the more \"secure\" coins, i.e. the oldest ones that can be used as input for the transaction. Internally, it doesn't care about accounts, although it does of course keep track of each account's balance. As a result, sending coins back to an input address will only guarantee they will go back to the original wallet , not necessarily the original account , let alone the original person . In many situations wallets are shared between different persons, e.g. in web services (online wallets, mining pools, etc.), so the difference is crucial. Thus if you're designing an application and you want to allow refund, you should absolutely not rely on the sending address in your application design. Instead, allow people to give an email, a refund address, etc. at some point. We're talking about the original Bitcoin client here. Although this behaviour is largely justified for security reasons, some current or future clients may not mix addresses between accounts and still be compliant at protocol level.",
      "(Just adding a somewhat important remark to davux answer ) It seems that free scripting for transactions will be soon activated in the real network, like it is currently in the test network. With scripts, it's possible to issue transactions that will go through completely different mechanisms than the simple one based on those standard bitcoin addresses we all know. In some cases, the receiving side might be unable to even find any addresses where to send the money back . A “standard” bitcoin address should be considered as one way to receive some bitcoins (and to spend those). It should not be considered as the universal way to receive (or send) them."
    ]
  },
  {
    "question": "How to start programming your own Bitcoin client?I want to develop my own Bitcoin client in a language that is not yet supported. Are there any resources that can be referenced to help me, or any other future developer with the task, or is the source code for the official client (and other clients) the only thing to go by? Has anyone made some cohesive documentation of the Bitcoin protocol, that if followed would guarantee the finished client would be able to operate along with the existing clients?",
    "answers": [
      "I don't believe anyone has published a detailed spec anywhere if that is what you are hoping for. There is some information on the bitcoin wiki, but your best option is to review the existing implementations. Check out BitCoinJ (a from scratch bitcoin implementation in Java) and BitCoinSharp (a C# port of BitCoinJ). They are not full implementations yet, but they are very far along and can do most of the tasks of a bitcoin client. No matter what language you plan to create your implementation in, looking at these is very valuable because they are very thoroughly commented and much easier to understand than the official C++ client.",
      "You could investigate the work of Amir Taaki (genjix) from http://bitcoinconsultancy.com who wrote a separate bitcoin client. The source code is available at https://gitorious.org/libbitcoin/libbitcoin and http://libbitcoin.org is the project site. He is super active and responsive on irc at #bitcoinconsultancy"
    ]
  },
  {
    "question": "Will mining significantly increase the power consumption of my PC?I have a PC that is always on 24/7. I use it as an SSH and backup server, and it has a modest, not-too-great GPU that sits idle most of the time. I hear a lot of talk about mining not being cost-effective for most people because electricity isn't free. However I'm already paying the electricity bill for my PC. I might as well let it sit and mine all day while it's on, right? Maybe help pay the electric bill? Or will mining increase my PC's power consumption so much that it's still not worth it?",
    "answers": [
      "Yes it will. The component you're likely to use for mining is your video card (GPU) which consumes very little power when idle but can consume a great deal under load. Check this list of common cards and consult the Watts (W) column for how many watts your card is likely to draw. Any card worth mining on will probably draw at least 100 Watts under full load. Depending on the electricity costs in your area, it may cost you more in electricity than your coins produced are worth. There is at least one good calculator to estimate your proceeds but you'll need to find out how much your local utility company charges per kilowatt-hour for electricity to determine if it's profitable. For reference Kilowatt-hours per day = Watts * 24 / 1000.",
      "Yes, it consumes more power. You can see, for example, by using a notebook from the battery. Turn on mining and you will see how your battery time goes down. But unfortunately I don't have any data to provide you (saying for example that mining will consume 10%, 20%, 50% more power energy)... That depends how power-efficient is your computer processor, motherboard, etc. Maybe you should get a Kill A Watt Electricity Usage Monitor and test 24 hours with and without the mining. In my opinion, if your computer is turned on all the time without high CPU usage, turn your mining on. If you are running a Unix-based OS, it should run on nice 19 mode, which means that any other task that the processor receives will have higher priority -- so you can SSH and/or backup just fine."
    ]
  },
  {
    "question": "When building bitcoind, I receive error \"headers.h:36:20: fatal error: db_cxx.h: No such file or directory\"When building bitcoind on LinuxCoin (Debian based), I receive this error \"headers.h:36:20: fatal error: db_cxx.h: No such file or directory\" following the instructions at https://github.com/bitcoin/bitcoin/blob/master/doc/build-unix.txt I believe the error is caused by the package \"libdb4.8++-dev\" being non-existant for the distro, as when attempting to \"apt-get install\" that, I get: Package libdb4.8++-dev is not available, but is referred to by another package. This may mean that the package is missing, has been obsoleted, or is only available from another source E: Package 'libdb4.8++-dev' has no installation candidate NOTE: libdb4.8-dev and all other dependencies are already installed. It's probably a silly mistake on my part but any help is appreciated! Thanks.",
    "answers": [
      "I did the following command on Ubuntu and it worked. sudo apt-get install libdb++-dev",
      "You need to add -I to the end of the CXX=g++ line in the Makefile . The directory should be the one that contains the db_cxx.h file from your BerkeleyDB installation. So, change: CXX=g++ to CXX=g++ -I /usr/local/BerkeleyDB.5.1 You may need a /include or something like that on the end of that. It depends exactly which directory holds the db_cxx.h file."
    ]
  },
  {
    "question": "What happens if my transaction is not accepted because I did not pay fees?I was reading this thread about a client fork that does not force transaction fees and I noticed the big red warning saying that some coins might get lost if I am not careful. What does this mean? What should I do if my transaction is not accepted?",
    "answers": [
      "If your transaction does not get accepted, you have a few options. Right now, at least for Bitcoin itself, there are still enough miners willing to include any valid transaction. So if you just keep waiting, it should eventually get confirmed. You may also wish to stop your client and then restart it, manually forcing it to connect to a client known to accept transactions without fees . It can help to disable incoming connections to maximize the chances your transaction will go to the client that will accept transactions without fees. It can take several hours for the transaction to get out, even if you do everything right. (The client intentionally 'dribbles' out transactions to try to hide their origin. This completely fails for transactions with too-low fees, but the client still tries.) Otherwise, you can abort the transaction attempt. Stop your client and then make sure the transaction is not in limbo by checking the list of pending transactions . If it's not there, you can stop attempting the transaction to recover the coins. Ideally, you made a backup of your wallet before you attempted to make the transaction -- reverting the wallet and restarting the Bitcoin client with the -rescan option will remove the transaction. Otherwise, you'll have to (ouch) edit your wallet file to remove the transaction.",
      "David's answer is outdated by now. Today, transactions without fees generally don't get any confirmations. A new startup flag for Bitcoin Core has been added since, which removes unconfirmed transactions: -zapwallettxes Note, that unconfirmed transactions that were propagated in the network and do get confirmed later will be rediscovered by your wallet if they are confirmed and included in a block."
    ]
  },
  {
    "question": "Can I damage my computer by mining bitcoin?I have been mining Bitcoin for a while on a few systems, some CPU mining (which has proved to be basically useless) and some GPU mining. The GPU miners are workstations, which have midrange graphics cards built in. I have not done any modifications or built high-end mining/gaming systems. One is an Apple iMac with an AMD Radeon HD 6770M 512 MB built in. I typically mine with the Phoenix miner and AGGRESSION=3 for at least 12 hours a day. Can the GPU handle this load, or is it possible I will damage my computer by mining bitcoins without a dedicated high-end GPU?",
    "answers": [
      "It is possible to damage your computer by mining in the following ways: the computer will degrade more, as it is used more (you will have to replace it sooner than normally) the computer will overheat and some components will fail because of that (if for example, the computer is dusty. If the parts are well-maintained and the computer is not boxed in, this shouldn't be the issue) you will overload some part of your computer with the mining and it will short circuit or blow a fuse (mostly relevant if your power supply is weak, this happened to me once) Number 3 you should notice quite fast if you run your miner at top speed, full load. If you are already mining, this probably won't happen unless you increase your load, or are operating close to the limit of your hardware. If something flashes, smokes, or the computer doesn't turn on any more, this was probably the cause. Replace hardware. Number 2 you should notice if you run your miner for about an hour, once everything heats up well. Again, if you are already mining and this doesn't happen, it probably won't if you keep your computer clean and give it some air. If your computer turns off suddenly, but runs fine after cooling down, this probably was the cause. Clean your computer chassis, possibly add some fans or replace hardware. Number 1 you won't notice for months or years. Mining with lower-end GPU should be fine in all the regards, asides maybe 1 (leaving your computer on for longer to mine will ear it down more). Usually it means you won't use as much power and generate as much heat, so you should be fine.",
      "It is heat that kills. You need sufficient airflow and good case design to keep the GPU and VRM (voltage regulators) cool. Most commercial workstations have insufficent airflow. Likely it has one or two small intake and one small outtake fans. Sufficient airflow generally requires much larger fans and more open case design. Things like cases which mount powersupply upside down (so it exausts hot air outside the case), large diameter case fan mounts, and side panel cooling is especially useful in getting enough cool air into the case and hot air out of it. \"Reference\" card designs (more below) also help with proper airflow. You need a utility to monnitor your temps. Be sure to use a utility like \"GPU-Z\" which provides VRM temps. The VRM control voltage supply to GPU and memory and under load get very hot. With insufficient cooling they can exceed 100C which reuduce their lifespan. You need to also check the other temps in your case. While you aren't stressing the CPU and motherboard if the case design isn't properly exuasting the hot air outside the case the ambient temp around CPU and motherboard will rise making cooling less efficient and could lead to damage to those components. CPU are far more suspetible to instability at high temp than a GPU. While 90C can be considered a high temp for GPU a CPU temp should generally be kept below 70C for long term stability. Unrelated to heat an poorly built powersupply may be insufficient to handle the high 24/7 load but any premature failure is more a manufacturing defect (promising more than it can deliver) than an issue with mining. Some lower quality manufacturers bet on the fact that most computers aren't run at 100% load 24/7 and users buy larger powersupplies than needed and use that to cut corners. Mining can be brutal on a powersupply. It will be pushed ot high % of it's peak power and the load will be continual with no breaks. Cheaper built powersupplies just can't handle that abuse. Stick to major brands with good reviews and solid warranties. About AMD \"reference designs\": These cards are usually the first design released by AMD and are designed to handle high load with multiple cards in a single case. They tend to be more expensive to build so card companies are always look for ways to cut cost as more users with single card don't need that level of overengineering. The reference design is visually very easy to identify as it will have a single squirrel cage fan near the interior end of the card, a closed heat shroud, and a vent which exhausts hot air outside the case. (source: bestofmicro.com )"
    ]
  },
  {
    "question": "Is there a historical timeseries of market depth & transactions available?Has anyone stored the historical market depth & tick data from MtGox? Is it available publically? Would be useful if you were making a bot.",
    "answers": [
      "Current market depth available at https://mtgox.com/api/0/data/getDepth.php?Currency=USD All trades which happened in the last 24 hours available at https://mtgox.com/code/data/getTrades.php Retrieves 100 trades that happend after specified transaction https://mtgox.com/code/data/getTrades.php?since= \"transaction tid\" A script is required to retrive all historical data, like the one posted by mizerydearia . The idea is to cycle download request while incrementing \"transaction tid\" aka \"lasttrade\" to download all data in steps. #!/bin/bash outputfile=data lasttrade=0 while test -n \"$lasttrade\";do wget --quiet https://mtgox.com/code/data/getTrades.php?since=$lasttrade if test \"\" != \"[]\";then cat getTrades.php\\?since\\=* >> $outputfile; echo >> $outputfile; lasttrade=; lasttradets=; echo \"$(date -d @$lasttradets) tid $lasttrade\" else echo Finished fi rm getTrades.php\\?since\\=*; done See MtGox - API for more http API calls.",
      "To get ALL mtgoxUSD trades since the start you can use the following url: www.bitcoincharts.com/t/trades.csv?symbol=mtgoxUSD&start=0 WARNING. This generates a 49mb csv at the moment and can take some time, so please only follow the link if you actually need the data. Visit http://bitcoincharts.com/about/markets-api/ for more information."
    ]
  },
  {
    "question": "What are the differences between Bitcoin and Litecoin?What are the differences between the Bitcoin and Litecoin algorithms and protocol?",
    "answers": [
      "Litecoin is exactly like Bitcoin, but: The hashing algorithm is CPU-friendly, meaning that having powerful GPU doesn't let you mine fast. The difficulty of the blocks is set so they would be mined about every 2,5 minutes, instead of 10. Other differences are cosmetic, like aiming to generate more Litecoins than there will be Bitcoins, using different port, etc."
    ]
  },
  {
    "question": "Bitcoins & SomaliaMinneapolis has a large community of immigrants from Somalia. They have been accustomed to sending money to relatives there. One person among them sent money to a terrorist organization that had an agent in Somalia. Seemingly in response to that incident, local banks, fearing liability, stopped providing the service of wiring money to Somalia. One person abused the system, so it's made unavailable to everyone. Could bitcoins be used instead? Could that service be quickly made available to the Somalis? E.g., how much access to the internet in Somalia would be needed? Would it be sufficient for those who were in the business of receiving wire-transfers there to have internet access? What liability issues might arise for those who inform those in need of this system of how to do it?",
    "answers": [
      "The system the Somalis (and many others) have been using to send money around the world for centuries is called hawala. Monetary futurist Jon Matonis calls Bitcoin a potential replacement for hawala. Right now, I suspect that Somalis would be hard-pressed to use Bitcoin for personal remittances, owing to the lack of local exchangers and Bitcoin-accepting merchants on the ground. However, traditional hawaladars might well use Bitcoin as a means of settling accounts among themselves, while taking receipts and making payouts in the locally-preferred fiat currencies.",
      "Hawala (sometimes referred to as hundi) involves a trust relationship between the two hawaldars. The hawalder who receives the funds (in Minneapolis, for example) is a trusted partner to the other hawalder who disburses the funds (in Somalia, for example). With Bitcoin, this relationship between hawalders becomes unnecessary. These hawalders simply become exchangers operating independently. There are plenty of methods in which bitcoins can be acquired by the person wishing to send money, so the remaining gap is finding an exchanger who will trade shillings, dollars, euro or whatever for bitcoins within Somalia, for example. Bitcoin is uniquely positioned to make this possible however, due to its properties where transactions are non-reversible, extremely low in cost (transaction fees), and where funds become available for spending right away (in about an hour, for example). This makes it possible for a network of individuals to do the grunt work function where the exchange involves transaction sizes as low as $20 worth of bitcoins, for example. With transaction fees being trivially low, small, independent exchangers can trade bitcoins with each other for immediate needs but when the supply of shillings, dollars and euro needs to be replenished they can trade with slightly larger exchanges. Those larger exchanges would then trade bitcoins either directly or indirectly with Bitcoin exchanges that interact with banks or with parties that essentially offer these banking services. When bitcoins then are seen as something with value because they can easily and inexpensively be cashed out, on demand, they might then start being used for trade alongside shillings, dollars and euro. And that is where things start to become interesting."
    ]
  },
  {
    "question": "Are there Bitcoin password crackers I can use to recover forgotten passwords?I've lost the password to one of my wallets (it's a small one, don't worry). I was sure I remembered the password ... but evidently I don't. Is there a program that I can use to brute-force my password, given hints? Meaning, suppose that I remember that my password was \"abc\", but in fact maybe it's \"Abc\" or \"Abc0\". I would give the cracker program the string \"abc\" as a hint, and it would try a lot of permutations on it until it finds the real password. Does such a cracker program currently exist? (Reliable sources please, hopefully open source)",
    "answers": [
      "Revalin made available a sript that you can try running: http://bitcointalk.org/index.php?topic=85495.msg942171#msg942171 There may not yet be anything else, but you'ld probably find someone willing to write one if you offered to send your wallet along with what you think the pass phrase might be and ask only for a fraction of the wallet's bitcoins back once cracked.",
      "Another alternative is btcrecover, available on GitHub here . From the Tutorial : btcrecover is a free and open source multithreaded wallet password recovery tool with support for Armory, Bitcoin Core (a.k.a. Bitcoin-Qt), MultiBit (Classic and HD), Electrum (1.x and 2.x), mSIGNA (CoinVault), Hive for OS X, Blockchain.info (v1 and v2 wallet formats, both main and second passwords), Bither, and Bitcoin & KNC Wallets for Android. It is designed for the case where you already know most of your password, but need assistance in trying different possible combinations. It also supports seed recovery for deterministic wallets: seedrecover.py is a Bitcoin seed recovery tool which can take a seed with one or more mistakes in it, and recover the correct seed if not too many mistakes have been made. Full disclosure: I am the developer of btcrecover."
    ]
  },
  {
    "question": "Was a timejacking attack ever performed?The timejacking attack appears to be a pretty straightforward attack to pull off successfully. I was wondering, whether it was ever performed and documented somewhere, or was it just theoretically described?",
    "answers": [
      "For those of you who are wondering what TimeJacking is, please consider the following: In order for computers and machines, separated by vast distances, to work in tandem, they usually have to be synchronized. If the time and date aren't isn't synchronized, this can lead to issues relating to security, usability, and overall response time. According to NTP.org: http://www.ntp.org/ntpfaq/NTP-s-def.htm \"If you have communicating programs running on different computers, time still should even advance if you switch from one computer to another. Obviously if one system is ahead of the others, the others are behind that particular one. From the perspective of an external observer, switching between these systems would cause time to jump forward and back, a non-desirable effect. As a consequence, isolated networks may run their own wrong time, but as soon as you connect to the Internet, effects will be visible .... Even on a single computer some applications have trouble when the time jumps backwards. For example, database systems using transactions and crash recovery like to know the time of the last good state.\" This also applies to online security certificates (in browser). If the time and date is wrong, strange things may happen (invalid certificate error). While this appears to apply only to the Network Time Protocol, I assure you otherwise - networked systems need to stay synced in order to function. BlockChain and other cryptocurrency handlers have this exact issue because they are handling electronic transactions over vast distances, across time-zones. Oh wait - in case you don't know what a bitcoin node is: http://www.coindesk.com/bitcoin-nodes-need/ Now that we know how the system crack can occur, let's delve into the process (good source, BTW - ThePiachu): (Presented by culubas: Timejacking and BitCoin - Blogspot) \"Each node internally maintains a counter that represents the network time. This is based on the median time of a node's peers which is sent in the version message when peers connect. The network time counter reverts to the system time however if the median time differs by more than 70 minutes from the system time. A very reasonable way to estimate the median network time. An attacker could potentially slow down or speed up a node's network time counter by connecting as multiple peers and reporting inaccurate time-stamps. (A relatively small number of Tor clients could send enough messages to take over the node's median time.)\" As usual, time is used for security and validation on these monetary hardware servers and nodes. If the time is off, bad things can happen. For more info on how an actual cracking attempt could occur, read the section labeled \"Creating a 'Poison Pill' Block\" of culubas blogpost cited above. In short, an attempted hack would create a perceived time gap between the mining machines and node targeted, by lagging part of the system until one of three things occur: either an unaffected node or the target itself creates a block, clocks are reset, or operators intervene. As such, valid blocks could be dropped, and money could be lost or stolen. Please read the original article for more info. Now, as for the question at hand, I wasn't able to find any confirmed instances of TimeJacking so far. That could be due to a variety of reasons, but I personally think that no one has chosen to target the cryptocurrency yet. In that case, I can't wait to see what a new API update would look like - especially with some new security patches for P2p time-keeping and network certificates. Sadly, it could be just a matter of time."
    ]
  },
  {
    "question": "What is the longest known vanity address generated?Anyone can generate a vanity address of arbitrary length with appropriate tools, it's just a matter of performing enough computations. What is the longest known vanity address anyone has generated?",
    "answers": [
      "It's impossible to say for sure what's a vanity address and what's generated purely at random, but 1CFBdvaiZgZPTZERqnezAtDQJuGHKoHSzg is 34 characters with no digits in it other than the initial '1'. That may well be a vanity address. Then again on average 1 in every 515 34-character addresses you generate won't have any digits in them other than the leading 1, so possibly not. The address with the longest initial list of lower-case letters is 1yaniraswqyghuJKCRrGwJUA2HakWtRad , and is clearly a vanity address since it appears in the same transaction as many other vanity addresses. Edit: I just found this one: 1QBDLYTDFHHZAABYSKGKPWKLSXZWCCJQBX It belongs to etotheipi, author of the Armory Bitcoin Client , and was found using vanitygen, as he said in a bitcointalk forum post : Yessir! I got a little crazy with vanitygen and succeeded. It should've taken about 70 days of computation time but I got lucky and found it in about a week... (notice no digits either, only uppercase letters). Unfortunately, it's so cool that people don't even recognize it as a Bitcoin address :)",
      "There's this thread on bitcoin talk: https://bitcointalk.org/index.php?topic=90982.0 I personally generated this address: 1 Boyishness fwHq3wSkCkJ7iafUdjhghfU which is the longest one I'm aware of that's not mixed case. It was generated by feeding oclvanitygen a large number of potential prefixes from a large wordlist."
    ]
  },
  {
    "question": "What is the status of hierarchical deterministic wallets (BIP32)BIP32 specifies hierarchical deterministic wallets, where a master seed fully determines a whole tree of keypairs that can be arbitrarily branched. It also introduces the notions of internal and external keypair chains that can be used independently to generate public or private keys. Now I know that for example Armory uses deterministic wallets, but I cannot seem to find any implementation of the branching feature as described in BIP32. In particular, I want to generate a chain of linked addresses which are spendable using only one of the keys from my wallet as seed of a new branch (roughly the use case described in Recurrent business-to-business transactions ). Are there any other implementations of BIP 32 I am not aware of? Are there any plans to (fully) implement BIP 32 in Armory or any other client?",
    "answers": [
      "I started implementing BIP32 for the reference client myself, but as there were more urgent matters to deal with, I have temporarily stopped working on it. I certainly plan to complete this, but I can't give any target date or version right now. As far as I know from Alan Reiner (Armory's developer), he plans to switch to BIP32 as soon as the reference client implements them as well."
    ]
  },
  {
    "question": "How does the 'move' command work?I have so far enjoyed the experience of learning about Bitcoins, mining, etc. I've setup a bitcoin daemon in hopes of developing a few apps and services in the near future. However, there is one thing that has been bothering me for a few days now and I can't seem to find an answer for. There is a 'move' command in the client/API calls list that will \"Move from one account in your wallet to another\". I read somewhere that this DOES NOT flow through the block chain. If that is the case, then HOW can you actually use those coins in the new account/address when there is no public record of the transfer. Thanks for your help",
    "answers": [
      "Accounts are an internal bookkeeping mechanism of the Bitcoin client. They are not the same thing as addresses. When you move from one account to another, the coins remain in the same address, and if you need to spend them they will be spent from the same address. The only thing moving does is subtract a number from one account and adding to another - both of which are just things the client displays and nobody else on the network has any knowledge of. An account balance can also be negative. Accounts are good if you run a shared eWallet and want to track users' balances (and \"move\" can be used to make an intra-bank transfer), or if you want to keep track of different purposes of savings (so you can direct all incoming coins to an account called \"unallocated\" and then move 100 BTC to the account \"college fund\"; if you make sure to designate all outgoing transfers as coming from \"unallocated\", you will not accidentally dip into the college funds, no matter in which addresses your bitcoins physically sit)."
    ]
  },
  {
    "question": "How to sign a transaction using only an offline computer?I think it is possible to generate keys on an offline computer and sign. To create a transaction I need to input transactions detail, and somehow I have to transfer signed transaction from offline computer to a online computer to relay the transaction. Is it possible to do this without using USB storage? I can use a keyboard, or barcode reader to transfer the input transaction hash to an offline computer and the signed transaction back to the online computer. So that private key stays with the offline computer. What are step-by-step instructions to do this, with any required error check / correction?",
    "answers": [
      "You're correct that the offline node needs to how to claim its funds, so it can't be totally isolated. Currently, the most mature offline wallet solution is through a client called Bitcoin Armory . Here's what your workflow looks like with offline wallets: Online node creates transaction -> USB key -> Offline computer signs transaction -> USB key -> Online node broadcasts transaction You can use Windows, Linux, or Mac for your offline wallet, but I'd recommend Linux, as it's difficult to disable AutoRun/AutoPlay on Windows. Download: Windows/Linux Mac - Beta This page explains offline transactions in greater detail.",
      "I'm working on this right now. Currently, I have online and offline armory set up to use the USB key as has been described here before. I just created a new android app that will peer with the bitcoin network, and allow you to scan a QR code representing ANY signed transaction, and broadcast it to the peers. This makes it so you can do this: Make an unsigned transaction in armory Create a QR code from it Scan it with phone (so far, QR Droid and Barcode Scanner work) Take phone to offline wallet Display QR code for unsigned transaction on phone (using history in QR droid works well) Scan using webcam in offline wallet computer (I successfully did this with the zbar Linux application in Ubuntu - package details to follow) Sign tx with offline armory Display QR code for signed tx (more packages to follow) Scan with new android app to broadcast This is almost done - the app is currently peering with bitcoin nodes and will scan the QR code and send it to a broadcasting activity, but the broadcast part and the parsing of the armory format remains. UPDATE: Implemented. Watch the video Python code here Android app code here"
    ]
  },
  {
    "question": "Where is Double hashing performed in Bitcoin?where in the Bitcoin Protocol is SHA256(SHA256(x)) performed and why?",
    "answers": [
      "Bitcoin uses double hashing almost everywhere it hashes in one of two variants: RIPEMD160(SHA256(x)) called Hash160 which produces a 160 bit output hashing the public key to generate part of a Bitcoin addresses SHA256(SHA256(x)) called Hash256 which produces a 256 bit output generating the checksum in a Bitcoin address hashing the block in a merkle tree linking transaction outputs and inputs hash of the block header (and thus the proof of work and the link to the previous block) It seems like Satoshi chose Hash256 whenever collisions are a problem, and Hash160 when only (multi target) second pre-images matter. This is consistent with a goal of achieving 128 bits of security. You need a 2*n bit hash to achieve n bit collision resistance, and you need a t*n bit hash to achieve n bit second pre-image resistance. If we assume a conservative 4 billion targets, and a 128 bit security level, this leads to 256 bit hashes for collision resistance and 160 bit hashes for multi-target second-preimages. So why does he hash twice? I suspect it's in order to prevent length-extension attacks. SHA-2, like all Merkle-Damgard hashes suffers from a property called \"length-extension\". This allows an attacker who knows H(x) to calculate H(x||y) without knowing x. This is usually not a problem, but there are some uses where it totally breaks the security. The most relevant example is using H(k||m) as MAC, where an attacker can easily calculate a MAC for m||m'. I don't think Bitcoin ever uses hashes in a way that would suffer from length extensions, but I guess Satoshi went with the safe choice of preventing it everywhere. To avoid this property, Ferguson and Schneier suggested using SHA256d = SHA256(SHA256(x)) which avoids length-extension attacks. This construction has some minor weaknesses (not relevant to bitcoin), so I wouldn't recommend it for new protocols, and would use HMAC with constant key, or truncated SHA512 instead. Some related reading: Hashing or encrypting twice to increase security? on crypto.SE Cryptographic reasoning for double-hash? on bitcointalk",
      "Here's the main hashing function: template inline uint256 Hash(const T1 pbegin, const T1 pend) { static unsigned char pblank[1]; uint256 hash1; SHA256((pbegin == pend ? pblank : (unsigned char*)&pbegin[0]), (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&hash1); uint256 hash2; SHA256((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2); return hash2; } I'd say anyplace that calls that uses SHA256 twice. As for why, see this ."
    ]
  },
  {
    "question": "What is proof-of-work?Please explain the proof-of-work concept. And how does it relate to Bitcoin mining in general, and to the proofs of work (aka shares) of mining pools?",
    "answers": [
      "Bitcoin miners find a random number (called a \"Nonce\") that when inserted into the current block makes the hash be below the current target. They then send that current block around the network and everyone checks their work (the proof-of-work) by hashing the block and checking if the result is below the current target. In mining pools, miners do the same thing, but the current target is much higher (so it's easier). When they find one of these, it's called \"mining a share\". A small percentage of the \"shares\" will actually have a hash below the actual target, and the pool will make it's 25BTC profit, then distribute it out to the miners who found a share (normally using some über-complicated method to prevent cheating/pool hopping)",
      "Due to the very low probability of successful generation, this makes it unpredictable which worker computer in the network will be able to generate the next block. http://en.bitcoin.it/wiki/Proof_of_work This is what makes proof-of-work based cryptocurrencies like Bitcoin different from any other form of electronic money. With access to mining being open to all, there is no way to control (or corrupt) the transaction verification process. For instance, let's say there was a law passed everywhere mandating that no payments to Wikileaks would be allowed -- that any miner including a payment to the Wikileaks payment address would be punished. That is a form of centralized control and some miners would comply. But because other miners would continue verifying those transactions regardless, the worst that would happen is that payments to Wikileaks might get ignored by a block or three of miners who did comply with the law until another miner ignoring the law gets a block. The economic advantage goes to the uncorrupted miners (who recognize the laws of math and ignore the laws made by man)."
    ]
  },
  {
    "question": "How do nodes verify Bitcoin Transactions?I am trying to understand the role played by various nodes in the Bitcoin Network in verifying the transactions that are taking place in real time. I think that I understand the process of Transaction (using Input and Output Scripts) and how the Transaction is formed. However I am trying to correlate it with how a Transaction is Broadcasted to other nodes and then verified? Consider an example: if A wants to send some BTC to B, then 2 things will occur: (a) A will form the input script of the new transaction. It will reference the output script of a previous transaction where A received some BTC (in the past). It will prove the ownership of those BTC by using its Public Key and verifying the Signature. (b) The output script for the new transaction will be formed by A's client. It will store the hash of the BTC Address of B and enable it to spend these BTC in future. Now, my questions are: All these actions are performed by the Bitcoin Client of A and it does not require any interaction with the Peer to Peer Network. It has its own local copy of the Block Chain which it can use to perform the step a. So, isn't the transaction verified by the bitcoin client of A? I am guessing that this new transaction that was created (input and output scripts formed as described above) will be broadcasted to the entire Bitcoin Network. Now, what type of verification is being performed by other nodes on this transaction? On what basis is a Transaction accepted by the Bitcoin Network and integrated into the Block which is a part of the Block Chain? Thanks.",
    "answers": [
      "Yes, but that doesn't mean that the network has accepted it. There are rules for accepting a transaction. Miners only include blocks that don't break the rules. The rules include checking that the inputs are valid, that a coin isn't double-spent, that the output isn't more than the input, etc. A miner can choose to include a transaction or not. A miner could even choose to include a transaction that breaks the rules! But if he does that, other miners that are following the rules won't accept his block and he won't get his mining reward. So he has incentive to follow the rules."
    ]
  },
  {
    "question": "How to check Bitcoind block chain download progress levelI have installed bitcoind on ubuntu server, and when I run screen -x for btc it says error -10 blockchain is downloading . How do I know the progress level? currently 125600 blocks are downloaded, but how many blocks yet to go? where do i check the blockchain download progress level? does it has capability to resume if the server is powered off?",
    "answers": [
      "Do cd /home/ then nano block.sh copy the code below and paste (right click if you use putty) to the script. #!/bin/bash while true ; do clear echo \"Press enter to break loop. Script will loop every 3 seconds\" echo \"script by Nixsy 18th august 2013\" echo \"If loop freezes press CTRL+C\" echo \"\" echo -e \" \\033[31mdownloaded\\e[0m/\\033[32mavailable\\e[0m\" echo -e \" \\033[31m\"\"\\e[0m\"/\"\\033[32m\"\"\\e[0m\" read -t 3 -n 3 && break done When you have copied the text to nano hold CTRL+X and then press Y to save. In terminal type or copy from below followed by the enter key. chmod +x block.sh to start the script type. ./block.sh This is just a little edit of the script from Lohoris, It will clear the screen then loop the script every 3 seconds until a key press. Credit to Lohoris for the original script.",
      "As of 2019, you can use the following script echo /"
    ]
  },
  {
    "question": "How do SPV (simple payment verification) wallets learn about incoming transactions?I try to understand a SPV implementation. I read the wiki pages on Protocol Specification and Thin Client Security as well as the white-paper's chapter 8 . What I don't understand: Assume user A has Bitcoin address X . User A can do getheaders and load all block headers and then have all block hashes and timestamps. So: how does a SPV client then find possible transactions to the user's Bitcoin address X without loading all blocks (and all transactions)?",
    "answers": [
      "You are right that SPV as described in the Bitcoin paper does not explain how to discover payments to yourself, without downloading full blocks. My guess is that Satoshi either planned to develop this later, or that he assumed you'd just be told about payments to yourself (pay-to-IP, as existed next to pay-to-pubkeyhash as is used now). Practical implementations of SPV nodes today however use a protocol extension called bloom filters, described in BIP 37 . They use getheaders to fetch block information prior to their wallet's birth timestamp, and request filtered blocks afterwards. To do so, they submit a bloom filter that describes the addresses and transactions they are interested in to the peer. The peer then only includes the relevant transactions in blocks it submits, together with their Merkle paths to prove that these transactions were indeed part of said block.",
      "If it helps https://gist.github.com/TOMOAKI12345/7e0aa1c6b8ace4a70ca6 Breadwallet source code is really good source to learn about the network protocol of SPV wallet."
    ]
  },
  {
    "question": "How does blockchain.info calculate the \"Estimated Transaction Value?\"Consider the following transaction: https://blockchain.info/tx/aa5eb27652bd85dc444ea2508bf0ff6ff1b484141e2d7e69f31976fafb21e06e Each of the output addresses has never before been used, and there is only one input address. Why does blockchain.info guess that 0.7695 BTC has been transacted with 3.7216 BTC as change rather than the reverse (see \"Estimated BTC Transacted\")? Does it just pick the second address as the change address? In other cases, I am able to guess similarly to blockchain.info, for example: (1) If multiple input addresses are used, the change address should not be greater than the lowest input address (unless, of course, this is being purposely obfuscated). (2) If both of the output addresses have been used before, they may run a degrees-of-separation query to try to connect one of the output addresses more closely to the input addresses, more closely identifying it with the input addresses and therefore as the change address. (3) If only one of the output addresses has been used before, it is more likely to be the change address according to the heuristic in (2) because by definition the used address is more closely \"connected\" than an address that has never been used. But what heuristic could be used if each of the output address is new? The spending pattern of the input address? Randomness? Thoughts? You can see how this question affects views of the total/daily volume on Bitcoin in aggregate by comparing/contrasting both of the \"Estimated Transaction Volume\" charts available on http://www.blockchain.info/charts . They claim the second chart adjusts for change, but provide no details about the algorithm.",
    "answers": [
      "For transactions with one input it is hard to guess what is the change and what is the real payment. However because they may be have statistics so they can may be guess that for a ~4 BTC input there are 70% of probability that the change is the bigger output and the money spent the smaller one when both output addresses are new. Now if you have a transaction with several inputs (Like ou have already explained in your question) it is much more easier to guess. If you have : As input 1Pi87D6NUPB5BxcuowYN4Lj3WLCSFGsuLN (0.24379822 BTC) 1PgBMDggd7GGCifDd1881vdvNe8pkn5BWk (0.08787591 BTC) And as output 1B6tvnE3oP3mwoA4RMrYXWVup4Z73G6bDw - 0.05377413 BTC 1DswmdznL6exZzN6akJpsPUc4ZWRZo9JQc - 0.2778 BTC In this case you can be pretty sure that the spent address is '1DswmdznL6exZzN6akJpsPUc4ZWRZo9JQc - 0.2778 BTC' and the change '1B6tvnE3oP3mwoA4RMrYXWVup4Z73G6bDw - 0.05377413 BTC'. Because otherwise there would be only one input."
    ]
  },
  {
    "question": "What would it take to create my own Bitcoin exchange?I'm looking into creating a Bitcoin / crypto currency trading platform (say, like Tradeking), as I've noticed there are a few sites out there already, except they all have pretty hefty fees. So, to reduce fees, is it possible to create my own Bitcoin exchange? What is involved in setting one up? I'm pretty sure I'll need to develop an API, which I can do (I am an experienced software developer). I'll also need a business entity and a business bank account to use for transactions. What else? I see this thread ...is there anything else I should consider? Also, if I do set up an exchange, can I control of the fee rates? Other sites have rates averaging around 0.5%...can I set mine to whatever I want (considering my costs), or am I limited in some way by some third-party entity?",
    "answers": [
      "Setting up and operating an exchange can be quite involved. A few tiers to start thinking about: legal, banking, tech+security, and volume. Legal The first question is whether you want to operate globally (e.g. Bitfinex or BitStamp) or focus on a national market (e.g. FlowBTC, meXBT). The next step is to seek legal counsel to help decide where you want to locate and how to incorporate/structure your business. You want to think about how you can limit your liability and exposure to litigation, as well as what regulatory/compliance requirements are in your jurisdiction, and what they are likely to be in ther near term. Merkle Tree offers a useful high-level global map of the regulatory landscape. Banking What sorts of banking relationships do I need and how can I secure them? Note that banks can be heistant to provide services to digital currency exchanges. Tech + Security You or a partner need to build and maintain complex architecture that pairs orders, executes transactions, and manages deposits and withdrawals. Major componets are: Matching engine Risk management system Accounting/audit system Wallet management Payment gateways Security is understandably paramount. Some things to consider: Sound internal security procedures among your team - see, e.g. CryptoCurrency Security Standard (CCSS) (incredibly important, and often overlooked) Network and hardware security (secure data center, etc.) KYC (Know Your Customer) + AML (Anti-Money Laundering) solutions Two-Factor Authentication for users Volume Without lots of live volume, all the above is for naught. It is well worth your time to actively consider all of the below: Channeling liquidity from large exchanges like Bitfinex to your exchange Messaging, media presence, brand creation and maintenance, ads and retargeting User definition (is this a retail exchange, for advanced users?, etc.), and using this to inform UI design and to prioritize features for product differentiation Hope this is helpful for getting started! Disclosure - I work at a firm called AlphaPoint ( http://alphapoint.com ) - we provide white label tech to many of the largest Bitcoin exchanges in the marketplace, including full stack tech and hosting, as well as order routing for day-one liquidity.",
      "You need three components: A user account system that allows users to register, maintain a balance, deposit and withdraw BTC and other currencies, and place buy and sell orders. You'll need to integrate this with a payment processor to support currency deposits and withdrawals. A matching engine that looks at the current buy and sell orders and matches orders together and executes the trades. A Bitcoin wallet to actually store each user's BTC balance. You should use a hot/cold wallet system that keeps most of the BTC offline. Some challenges: You need to track each user's Bitcoin balance so you'll need a way to keep the Bitcoin wallet in sync with a database like MySQL or MongoDB. A good way to do this is to combine the blocknotify command with the listsinceblock() JSON-RPC call. The biggest challenge is keeping your bank account from getting closed. Many banks are wary of Bitcoin and navigating local, state and federal laws can be tricky. Best of luck!"
    ]
  },
  {
    "question": "How do bitcoin exchanges work?I'm relatively new to the world of Bitcoins and understand the basic principles of wallets and addresses etc, but was wondering how exchanges (like Coinbase) work exactly. Is the entire exchange basically one large wallet with each user having their own address? That would mean that an exchange would hold a wallet containing all their users Bitcoins, no? When you buy Bitcoins from an exchange using a bank transfer or credit card, where are the Bitcoins you're buying sourced from? It was my understanding that you have to buy Bitcoins from an individual who's actively selling their Bitcoins. Do they just buy a massive amount of coins all at once and slowly sell them off?",
    "answers": [
      "First of all, Coinbase is a little different from the main concept of an \"exchange\". Real exchanges, like MtGox or Bitstamp, are really just a medium between traders. People can set limit orders to buy / sell bitcoins for a certain price. The exchange will match buyers and sellers when conditions of both the buyer and the seller are met. More concrete, there are two types of orders: limit orders and market orders. Limit orders allow a trader to buy bitcoins at a price lower than the current price or sell bitcoins higher than the current price. However, these orders will only be executed once another user accepts them. Market orders will just find the best matching limit order. So, let's say the last trading price is 100 EUR/BTC. Two people want to sell bitcoins but not for 100 EUR. One sets a limit order for 105 and the other for 110. So the best price to buy bitcoins for is then 105. When a person places a buying market order, it will look for the best price and it will buy from the one trader for 105 EUR. If the buyer wants to buy more than just one bitcoin, he will continually take the lowest price available. Doing this, the \"price\" of bitcoin will increase as the lower-price sell orders are no longer available. Coinbase is different because it, as far as I know, does not allow for limit orders. I'm not sure how they implement trading, but it's possible that they charge a little higher price and take the risk for themselves or they may just make your order at another real exchange they partner with. But in any case, if no limit orders are supported, it is not a real person-to-person exchange like most others are.",
      "An exchange is where buyers and sellers conduct their business. A seller of BTC deposits BTC with the exchange's address. He can then use his positive BTC balance in the exchange to sell his BTC for Dollars (or other coins). Similarly, a buyer of BTC deposits USD with the exchange and then uses the balance to buy BTC from sellers."
    ]
  },
  {
    "question": "The Bitcoin scripting system is purposefully not Turing-complete - why?Can somebody explain to me why the Bitcoin scripting system is purposefully not Turing-complete? To make malicious programs difficult to develop (I guess)? Or because it was difficult to make it Turing-complete? Bitcoin uses a scripting system for transactions. Forth-like, Script is simple, stack-based, and processed from left to right. It is purposefully not Turing-complete, with no loops. Retrieved from: https://en.bitcoin.it/wiki/Script .",
    "answers": [
      "As others have said, there is no real need for Bitcoin scripting to be more complex than it is, as its complexity is more than enough for its intended applications; but the main reason is that not allowing some features (such as loops) in a language makes it completely deterministic: you can know for sure when and how a given program will end; you can't f.e. have infinite loops if you don't have loops in the first place, thus you don't have to worry about programs getting stuck and blocking/crashing the interpreter which is running them (in this case, the main Bitcoin software). Not having to deal with the halting problem is definitely a plus for a tiny, embedded, purpose-specific language such as the one used for Bitcoin scripts.",
      "It's easier to meter and restrict if it's not Turing complete, remembering that every node in the network needs to execute every script to ensure validity, we want it to be lightweight. It's not like it needs to be any more complex, nobody uses what we have to do anything interesting. Most of the opcodes are completely disabled and there's been no requests for them to be re-enabled. There's so little use of script that I have manually inspected every single instance of a non-standandard transaction to see what they do. Other than the hash collision competitions and a lot of broken p2pool outputs, nobody to date has done anything even approaching interesting. In other words, it's not complex because it doesn't need to be."
    ]
  },
  {
    "question": "Why doc says importing private keys is so dangerous?There are a lot of applications when someone would like to import a private key. However in wiki documentation they say it is very dangerous: https://en.bitcoin.it/wiki/How_to_import_private_keys WARNING Before reading this page, users should note that messing with ECDSA private keys is very dangerous and can result in losing bitcoins, even long after the import. It is recommended that outside of self-generated vanity addresses, users should never import (or export) private keys. and Note that importing a key to bitcoind and/or Bitcoin-Qt may be dangerous and is not recommended unless you understand the full details of how it works. Why is it that dangerous and what are the alternatives if you are using cold storage, a paper wallet or generating vanity addresses? Related: Why so many warnings about importing private keys? (but it is about warnings on blockchain.info and not bitcoind ). I'm not sure if the warnings are due to the same reason.",
    "answers": [
      "Key import by itself (from a trusted source of keys, such as your own cold storage or backups) isn't a dangerous thing. However, the vast number of ways one can cause problems for themselves through key import leads to these warnings. Many such warnings appear to address more complex situations beyond bitcoind's scope. In this case, there can be many situations in which a weak key (e.g. from a brainwallet with bad password), or leaked key (suspicious origin, or generated by someone else) might be imported into bitcoind. For example, the following may happen (with sample keys, of course): 5KVFiYbW5qbFfuDwrhPdsA3ALH3PmrEdQnQrpDWrqpygncbpPY4 is generated insecurely someplace (used on a physical coin, or otherwise bad origin), translating to address 1CD2nyv22gAGs8GAsdNa1rW3KinkCHgTFd . User imports 5KVFiYbW5qbFfuDwrhPdsA3ALH3PmrEdQnQrpDWrqpygncbpPY4 and uses it in their wallet, as 1CD2nyv22gAGs8GAsdNa1rW3KinkCHgTFd in the UI. Dumpster-diver digs up improperly-erased hard disk owned by FooPhysicalCoinForge, digs up 5KVFiYbW5qbFfuDwrhPdsA3ALH3PmrEdQnQrpDWrqpygncbpPY4 and sweeps it. Even if the address had 1 BTC on it originally and received 20BTC more, the attacker now has access to all of the funds received to it and currently spendable.",
      "Perhaps a distinction between importing and sweeping a key needs to be considered. The aforementioned warnings deal with the importing of keys, and does not refer to the sweeping of keys, which moves all the coins to a new address. This method is inherently secure."
    ]
  },
  {
    "question": "Why is Bitcoin defined as having 8 decimal places?At the protocol level bitcoins don't actually exists, but rather base units (recently called “satoshis”). Bitcoins are defined as 10 8 base units, meaning that for a 50 BTC mining reward, you are actually earning 5 000 000 000 units. So, why was 10 8 chosen as the value of one bitcoin relative to the base unit?",
    "answers": [
      "When developing Bitcoin, Satoshi had already come with the idea that no more than 21 million of them will ever be made. However, there was an unsolved issue: how to accomodate all bitcoins in case it was actually used as a worldwide currency? Comparing to the current (2008?) world's M1 supply, it was determined that 8 decimal places was enough to cover the supply and still have the smallest division smaller than enough for daily usage. 1 It's also worth noting that this decision means the total Bitcoin supply is approximately 2 50.89 , which means it's smaller than the maximum value for a 64-bit integer (2 63 -1), and smaller than the first integer that can't be exactly represented in a double-precision floating-point number (2 53 + 1), so that standard programming languages can deal with Bitcoin amounts without requiring custom implementations or dealing with overflowing. 2 Ray Dillinger's response to: Why 1BTC should equal 10^8 satoshi ? Satoshi’s Genius: Unexpected Ways in which Bitcoin Dodged Some Cryptographic Bullets",
      "The world GDP is $74 trillion footnote: a according to the World Bank in 2017. The max supply of Bitcoin with 10 8 base units is 2,100 trillion Satoshis. If Bitcoin is to back the world's money, markets and real estate, not including debt nor derivatives, then the valuation of Bitcoin might be: Global Stock Markets: $73 trillion Global Broad Money: $90.4 trillion Global Real Estate: $217 trillion Total: $380.4 trillion footnote: b With a $380.4 trillion economy and 2,100 trillion satoshis in existence there will be plenty to go around. Additionally, because of the scarcity model built into bitcoin (21 million max supply), we won't need additional bitcoins or more decimal places, the valuation of Bitcoin will naturally change with our economy. I believe we will use Bitcoin as a form of digital gold to back other digital currencies and online marketplaces, allowing people and businesses to move credits from one online marketplace to another or from one currency to another. a The $74 Trillion Global Economy in One Chart : http://www.visualcapitalist.com/74-trillion-global-economy-one-chart/ b All of the World’s Money and Markets in One Visualization : http://money.visualcapitalist.com/worlds-money-markets-one-visualization-2017/"
    ]
  },
  {
    "question": "Is it chain of headers rather than a chain of blocks?We know widely used explanation of the blockchain: \" Every block contains a hash of the previous block \". The sentence above implies that since every block contains a hash of the previous block, therefore every block should have a knowledge about transactions included into the previous block because every block has a following structure: Block: Magic No Block Size Block Header Transaction counter Transactions Block Header: Version hashPrevBlock hashMerkleRoot Time Bits Nonce However, every block does not have knowledge about transactions incuded into previous block correct??? As fas as I understand there are two chains in the Bitcoin: a chain of blocks headers (a block chain) a chain of transactions ( Prev Tx Hash ) Hence just to clarify, rather than saying: \"every block contains a hash of the previous block\", would not it be correct to say: \"header of every block contains a hash of header of the previous block\"? Please correct my assumptions if I am wrong. Thanks.",
    "answers": [
      "Blocks contain a header, and headers are chained, so blocks are chained also. Note the merkle root from your question: this attaches the transactions in the block to the header, making them a logical combined unit: That is, you can't attach an arbitrary block to an arbitrary header---each header only attaches to one set of transactions. You are correct that this expression is wrong: \"every [valid] block contains a hash of the previous block\". That phrasing may be useful for non-techies, but if you find it in any editable technical documentation, you should probably change it."
    ]
  },
  {
    "question": "Where to find help understanding Bitcoin's source code in C++?I am looking to understand the Bitcoin C++ source code on GitHub . The Python one is simpler, but even that is too complicated for a beginner. Could someone guide me to some good resources on the actual implementation and its details? The actual C++ techniques used seem to be quite complicated.",
    "answers": [
      "I am not aware of an extensively commented version of the Bitcoin sourcecode, but you could check out the Bitcoin Developer Reference and you can read online the book Mastering Bitcoin by Andreas M. Antonopoulos, which covers Bitcoin's technical aspects extensively. There is also Princeton's Free Online Bitcoin course , which goes into details on some technical aspects, which might in turn help you understand the sourcecode better. Besides that, try searching Bitcoin.SE for specific questions, there are a few here that have been asked about already, if you can't find something, feel free to ask a new question here.",
      "My new book \" A Dissection of Bitcoin \" examines the original Bitcoin source code written by Satoshi. As for now, it is the first and only book available that helps you read the Bitcoin source code."
    ]
  },
  {
    "question": "bitcond v0.12.1. \"UpdateTip: 6 of last 100 blocks have unexpected version\"I replaced my bitcoind from v0.11.2 to v0.12.1. Then I found \"UpdateTip: 6 of last 100 blocks have unexpected version\" in debug.log. This error occurs at new block generation. Can I ignore this? If not, how can I fix it? I downloaded the new bitcond from https://github.com/btcdrak/bitcoin/releases https://github.com/btcdrak/bitcoin/releases/download/v0.12.1-addrindex/bitcoin-0.12.1-addrindex-linux64.tar.gz",
    "answers": [
      "Yes. You can ignore this. This means that some miners have mined (still compatible) blocks with a version number unknown to Bitcoin Core. Generally this indicates that some miners have mined blocks that signal non Bitcoin Core compatible soft- or hard-forks. Very likely a 2MB hardfork after BIP109 implemented by Bitcoin Classic."
    ]
  },
  {
    "question": "Why can't we fight Bitcoin thieves by not accepting payments from hacked accounts?Why won't we simply stop accepting payments from hacked accounts? We know their public addresses, right? Sure, hackers still will be able to compromise user's accounts, but at last that money won't be spendable, right?",
    "answers": [
      "Fungibility . Money needs to be fungible, otherwise it's not money at all. Blacklists allow censorship and confiscation of wealth by centralized/powerful players (like governments) which will be abused to screw over innocent people Or (hopefully) scare those people away from Bitcoin in the first place: why would you invest in Bitcoin if you know you could end up on a blacklist someday? It weakens the lesson the victims needed to learn the hard way: if you don't hold the private keys securely yourself, you don't hold the bitcoins.",
      "It wouldn't work. Imagine if you get to a grocery store and try to pay in cash and they say, \"Sorry, your dollars are no good, their serial numbers are on a list of bills that have been stolen\". You might have gotten those dollars in change yesterday from that very same grocery store because that's where the thief spent them before they got on the list. The result of such a system imposed on dollars would be that people could not hold dollars without high risk. After all, even if they know how they got those dollars and maybe even how the person who they got them from got them, they won't know their history. And it's absurd to argue they should investigate the provenance of all the funds they handle. Thieves would just make sure to make their money change hands as quickly as possible, sticking innocent people with the tainted funds. Eventually, people would just stop considering the funds tainted or abandon the currency that had these unworkable rules. There are lots more problems with this scheme. For example, say you have an account with 100 bitcoins in it. You accept a payment of 0.1 bitcoin from someone that is later discovered to have been stolen or otherwise tainted. But by the time the theft is uncovered, that tainted 0.1 bitcoin is mixed in to numerous payments you've made from the pile of 100 bitcoins you added it to. Are all your payments not tainted? What if tainted funds are used to pay a transaction fee? Perhaps the miner colluded with the criminal, perhaps not."
    ]
  },
  {
    "question": "UTXO model vs. account/balance modelI understand that Bitcoin uses unspent tx output and Ethereum account balance based. However, recently there are lots of discussions on that Bitcoin's UTXO database has become too big. Does this mean account balance based transactions are better in scaling than UTXO based?",
    "answers": [
      "The choice between the UTXO model and the balance model is primarily one between privacy incentives and apparent intuitiveness. If one follows the standard advice of not reusing addresses/outputs/scripts, as to not gratuitously reveal which coins belong to the sender and which belong to the receiver, the two models are actually equivalent. In this case balances would be single use anyway, and there would be as many balances as there would otherwise be UTXOs, removing both the apparent size advantage and convenience. However, the balance model effectively incentivizes reuse. As the cost to the system (possibly in fees, but certainly in node operation costs) for a balance update is lower than the creation of a new balance, such a system inherently incentives revelation of transaction sources. And even though balances are more intuitive, they do complicate reasoning about the security of the system. One issue is the problem of replay attacks. Assume X paid Y, and Y pays Z. Now W pays Y again. In a naive implementation, Z can rebroadcast his earlier transaction from Y, and could take the money from W's payment to Y. One solution is by putting sequence numbers on balances, and requiring transactions to list the sequence number of the transactions they take money of. Unfortunately, this requires maintaining the sequence number even for balances that went to zero, meaning that the balance database needs to maintain some data for every balance that was ever nonzero; a result that's far less scalable than the UTXO model was in the first place (which can forget outputs as soon as they're spent). In short, my view is that the balance model reduces the fungibility of the currency as a whole for a short term gain that disappears.",
      "In UTXO model, each transaction spends output from previous transactions and creates new output that can be spent by transactions later on operated by full nodes. Your wallet maintains a list of UTXOs associated with all addresses owned by the user, and the balance of the wallet is calculated as the sum of these unspent transactions. Take a look at this example : A has 2.5 btc i.e. one UTXO of 2.5 btc. A wish to send B 1.0 btc. A uses 2.5 btc as input to the trxn and sends 1.0 bitcoin to B, 1.5 btc sent back to A as a new UTXO with new address. So If B has 1 btc then total is 2 btc (sent by A) and having two UTXOs: one already of 1 btc and other one is of 1 btc by A. Bitcoin blockchain uses this model, there is another model which is being used by Ethereum blockchain i.e. Account Model which is quite simpler than the previous model. Lets see the example : A has 2 ethers, A wish to send B 1 ether, so the network will reduce 1 ether from A i.e. A has 1 ether now and network adds 1 ether to B. If B has 2 ethers already then total is 3 ethers. Both models has different pros and cons. Every transaction in account model make one output which leads to space savings. Any space savings is a benefit. As the network full nodes are meant to be operated by individuals rather then data centers the lower the data requirements the more potential participants. But UTXO provides a higher level of privacy as the users use new addresses for each transaction and will be difficult to link accounts to each other."
    ]
  },
  {
    "question": "Bitcoin Cash: how to check address balance / transactions?BlockExplorer ( https://blockexplorer.com ) provides a way to check bitcoin balances. What is the alternative to check for transactions in Bitcoin Cash addresses?",
    "answers": [
      "Bitcoin Cash block explorers are (sorted by usefulness and features): ✯ BlockChair: blockchair.com/bitcoin-cash/blocks ✯ BTC.com: bch.btc.com ✯ ViaBTC: www.viabtc.com ✯ Bitcoin.com: explorer.bitcoin.com *✯Coin Dance: cash.coin.dance/blocks ✯ BitInfoCharts: bitinfocharts.com/bitcoin%20cash/ ✯ BitBox: explore.bitbox.earth BlockDozer: blockdozer.com Blockexplorer: bitcoincash.blockexplorer.com CoinSpace: bch.coin.space BitPay: bch-insight.bitpay.com Yours: insight.yours.org/insight * Shows only blocks, doesn't show transactions. ✯ The ones without star use the same Insight UI, so that websites may not show interesting data."
    ]
  },
  {
    "question": "Is there a reason to why Bitcoin Core does not implement BIP39?Is there a specific reason to why BIP39 isn't added to Bitcoin Core? Seems very trivial to add and am confused to why it isn't there.",
    "answers": [
      "BIP 39 is not in Bitcoin Core largely for implementation reasons and because BIP 39 is not as secure as it could be. The structure of Bitcoin Core's wallet doesn't really allow for BIP 39 to be implemented. The current structure doesn't allow for 512 bit seeds as BIP 39 specifies, and adding it would require some significant changes to the wallet code. Implementing BIP 39 would also require implementation of PBKDF2, although that isn't very hard. Also, more generally, many Bitcoin Core contributors don't consider BIP 39 to be secure. It uses PBKDF2 which is generally regarded to be a fairly weak KDF so it isn't considered to be good for the secure storage of all of your Bitcoin. Some software (such as Electrum) used BIP 39 in the past but have switched to using their own mnemonic algorithm because of this weakness in BIP 39. BIP 39 mnemonics have some other issues as well such as version numbering (or rather lack of) and the use of a fixed wordlist. Electrum has documented their reasons for why they don't support BIP 39, and those reasons are the same for Bitcoin Core."
    ]
  },
  {
    "question": "Recipient has “not received” the Bitcoin I sent, but the transaction is confirmedI sent bitcoins to the address I was given (double checked). The recipient is claiming they did not receive it. I sent them a different payment yesterday at 8:30p and they didn't get it until 4:00am so could there be a lag also with this payment? Or are they lying? Please see below for btc address. I sent it this morning at 8:30am. 1LGSCBLrrX8pBehwRxUvZU29UAmVAX6jjZ. This is a canonical question for a frequently occurring line of questions regarding a recipient denying that they received a payment that’s confirmed . Please help by building out and revising the answers on this topic and using this canonical question as a duplicate target for new instances of these questions.",
    "answers": [
      "It's not completely clear what the situation is, but from what I gather it seems that you're the sender and the recipient is not acknowledging a payment you have sent. Given that you have already tried to clear it up, the most likely explanation is that you're getting scammed . I assume that you have verified that the credited address 1Gouzjo9Jav1k4AmRoUJJMzidVfnMoSieS matches the one that you were supposed to pay to, and that the amount matches the invoiced amount. The address 1Gouzjo9Jav1k4AmRoUJJMzidVfnMoSieS has received 0.02661900 BTC in transaction b36157a7ca9630a88d98125fca91de81f488ef7d9a60f9e57af055d4d91f7a50 . This transaction has been written to the blockchain more than a day ago and is confirmed. Given that this is the correct address, the receiver did get paid , whatever they may be claiming. Secondly, the money already got spent again which means that they must be fully aware the money arrived . Assuming that you have paid the right address, the issue is on the receiver's end: Either they gave you the wrong address which you paid correctly and someone else received the money (unlikely), they do not understand that they already got paid or incorrectly accounted for your payment (unlikely, since you already tried following up with them), or they're lying to you . You should follow up with them and firmly assert that the requested address in question has been paid (after you have verified that it was the correct address) and ask them to check that their systems are working correctly. Perhaps that will prompt them to \"suddenly find your payment\". Do not under any circumstances send them any more money if they don't acknowledge that your payment has succeeded and deliver their side of your agreement. Often scammers will make up nonsense excuses to get you to pay even more money. If they do not acknowledge your payment, you may need to decide to write-off that money, report the incident to law enforcement, and/or sue them.",
      "The address received 0.07014343 BTC in 3d727e3f4565e011c0348f813c2d5480210b6bae2003a0f7abaa949d1a7c599a . These coins have already been spent, so at the very least the recipient's wallet provider is aware of the transaction. Depending on the type of wallet, the recipient's account may not have been credited due to internal system issues. Alternatively, the recipient has received the funds and is trying to scam you for an additional payment. In either case, your initial transaction is successful, and the recipient needs to work with their wallet provider. You should not send them any more funds. Checking if a transaction is complete Due to the attention this question is receiving, I'll go through some of the best practices when checking the finality/completion/status of a transaction. For a Bitcoin transaction to be complete and irreversible, it must be mined into a block. To check if a transaction has been mined, you can check a block explorer. Block explorers are websites that read information from the blockchain and make it accessible to people who are not running their own node. Some commonly used explorers for Bitcoin are blockchain.com, blockchair.com, blockstream.info, and btc.com (no affiliation to any of these). When you look up the transaction, such as with the link above, you're presented either with a page detailing the transaction, or some form of a not found error. If a transaction is not found, it has almost certainly not been mined - in this case, you should aim to rebroadcast the transaction instead of sending a new one. It is possible that the transaction has actually been broadcast and just not picked up by the explorer yet, so sending a second one may result in a double payment. If a transaction is found, it may be listed as unconfirmed. In this case, just wait until it is confirmed. If a transaction is already confirmed, you should see some indication of the block it was mined into (either in the form of a block number, or a block hash starting with a bunch of 0s). If a transaction is confirmed, then it is complete and irreversible. The recipient says they didn't receive the coins There are a handful of scenarios in which the recipient may not see the coins even after the transaction is complete: The recipient's wallet is out of sync/not updating correctly - this is a more common scenario when using exchange or other hosted wallets, or using a regular wallet with a spotty or weak internet connection. In this case, the recipient must check with their wallet provider to locate and credit the coins. The address is incorrect - Either you made an error while copying the address, or the recipient provided an incorrect address. In this case, you should work with the recipient to figure out who needs to absorb the loss as the coins are most likely irrecoverable. The recipient is attempting to scam you - once a transaction is complete, only the recipient can access, locate, or otherwise try to work with the coins. If they insist they haven't received them, it is not due to an issue on your side, and you may be getting scammed. Things to note Do not use an explorer recommended to you by the recipient - it is trivial to build an explorer that hides certain transactions and makes you believe they are not complete when they are. Always use multiple third party explorers if you must. Ideally, you should run your own instance of Bitcoin Core with -txindex enabled and check the transaction yourself, but that is not feasible for many users on short notice. If you really do need to resend the coins, first make a transaction to your own wallet that sends the entire balance to yourself and wait for that to confirm. This prevents you from accidentally paying twice if the initial transaction was simply not broadcast properly. Be patient - transactions with low fees can take a couple of days to confirm during high network activity periods - if you see an unconfirmed transaction, just wait."
    ]
  },
  {
    "question": "Is there a 'BTC Refund Department'?I have been scammed 6 months ago. Now someone is calling me from BTC REFUND DEPARTMENT. He said that I have under my name the bitcoins that have been scammed. But the way to take this amount is to synchronise my wallet with the address that the amount is under my name. The issue is that he is asking for 10% of the amount to be added in the wallet and send the new bitcoins to blockchain and then after 15 minutes all the funds will be in my wallet. Has anyone had a similar experience? Is this true or is just another scammer?",
    "answers": [
      "I have been scammed 6 months ago Then criminals expect you to be gullible and foolish. You are a prime target for them. So they'll try new ways to trick you. BTC REFUND DEPARTMENT No such thing. Note that Bitcoin is not centrally controlled by any organisation. It is a peer to peer currency designed to be usable for one person to send money to a second person without involving anyone else as a trusted intermediary . Any business can use words like bitcoin or blockchain as part of their name. Having bitcoin in a business name does not mean you control bitcoin. Just as dollar.com has the word dollar as their name but are a car-rental business with no control over the US dollar. Nobody polices who may or may not use words like bitcoin or blockchain in websites or email addresses. Many criminals do. synchronise my wallet with the address They want to fool you with a watch-only address, where your wallet shows an amount of money that belongs to someone else not to you. Addresses are not secret. Anyone can add any bitcoin address to their wallet but that doesn't give you any control over money. Bitcoin wallets do not actually contain money. Wallets contain a secret number called a private-key that a wallet can use to control money. Importing an address doesn't give your wallet this secret number. the amount is under my name That's not how bitcoin works. Some businesses that sell bitcoin might ask buyers to set up a named account but that's outside the real Bitcoin system. hi is asking 10% of the amount to be added This is often called \"advance fee fraud\". Don't be tricked. There is never a need to pay any fee to release money. If there were, it could just be deducted from the amount being returned, you wouldn't have to pay it first. This is a favourite trick of confidence tricksters. Is this true or is just another scammer It's not true. It is just another scam. See also answers to questions about watch only addresses non-spendable addresses fraud (Bitcoin) scams (Personal Finance)"
    ]
  },
  {
    "question": "Is Bitcoin future-proof?As I understand things, the security and integrity of Bitcoin rely on the assumption that its hashing is \"hard\" in some sense. However, in the past, processing power has increased exponentially. This has made some problems solvable in a reasonable amount of time that were not solvable before. How does Bitcoin account for the possibility that processing power will continue to increase in the future?",
    "answers": [
      "BitCoin is futureproof , because in the event that processing power (or more relevantly, mathematical advances) make its algorithms weak or obsolete, the protocol can simply be upgraded. Copied from Stack Overflow : Upgrades to the Bitcoin protocol that break compatibility are implementable by social mechanisms but not by any technical process, which is by design. In order to change the hashing or signing algorithms in the event that new techniques weaken them, the following process could be followed: As soon as the existing algorithms are discovered to be weakened, have a trusted entity sign a copy of the existing blockchain, marking it as authoritative via a non-weakened algorithm. Create a new protocol that 'respects' the existing blockchain (which contains all records of bitcoin ownership), and allows for an upgrade path to exist indefinitely. Implement the new protocol dormantly in one or more clients, with a designated block number to switch over, and the trusted version of the blockchain hardcoded in. Convince the vast majority of Bitcoin users that your trusted entity is trustworthy, and to switch to the new client(s) before the designated block is mined. There really is no equilibrium allowing both versions to coexist, since people who own bitcoins will be able to spend them in both communities. Unless the modified client achieves near-universal adoption before the designated block is mined, users will switch back before the change goes live.",
      "The bitcoin network constantly adjusts itself to account for increasing amounts of computational power applied to securing the network. Thus, faster computers will not adversely affect the integrity of bitcoin. However, there could be problems should the integrity of the underlying cryptographic algorithms be compromised. It is possible to move bitcoin to newer cryptographic algorithms, but it would require a high degree of planning and coordination. The good news is that there would be a strong economic incentive for everyone that uses bitcoin to make that transition happen as quickly and smoothly as possible."
    ]
  },
  {
    "question": "Will forks and alternative block chains cause hyper-inflation of decentralized digital money?Great effort has been put into Bitcoin's concept of money supply and that there will never be more than 21 million units. However, it's relatively easy to fork it and create alternate block chains. SolidCoin, IXCoin, IOCoin etc are much less worth, but they can easily be traded against Bitcoin. Does this increase the over-all supply of Bitcoin-like money to well beyond 21 million units? Some believe yes, and that this is one reason already for the recent price drop. Also, the concept of open and decentralized P2P money is still young. Chances are that a lot of other such currencies will pop up in time. Is there a risk that Bitcoin will be thwarted by an inflation of other currencies, rendering it and all other open, \"free\", decentralized money worthless and useless? EDIT: One thing to consider in this context is that the number of traditional currencies will always be limited as there are only so many nation states on this planet (and they are consolidating, e.g. Euro), but the number of decentralized digital currencies is potentially unlimited.",
    "answers": [
      "It depends entirely how much those alternate block-chains get utilized. In the recent examples of ixcoin and i0coin, a small portion of btc miners and users switched over, sold their stash and went right back to bitcoin. It's essentially a case of network effect - whichever block-chain has the most users will be the most attractive to new users, and those new users themselves contribute to that effect. Bitcoin is by no means beyond the \"tipping point\" where forks can no longer threaten it, but short of a fork with some superior feature or another it remains the preferred fork and probably will for some time. Even namecoin hasn't touched bitcoin's user-base much despite having a definitive use built into the protocol.",
      "A competing digital currency will have to convince people that it is better and worth more than bitcoin. That's unlikely to happen if it shares all the properties of bitcoin since bitcoin would have a lead in terms of adoption and infrastructure (but with enough marketing muscle might happen). Should the value of the competing currency rise high enough relative to mining difficulty, then miners can make more money by mining the new coins and then selling them in exchange for bitcoin. This caps the upside potential of the new coin to the same potential that bitcoin itself has. And there is a high downside risk of your investment going to zero. For speculators, this is not likely to be very appealing and if it's not appealing to speculators, it's not likely that a new coin could get very far off the ground before being abandoned. However, if the new coin offers some new innovation or is perceived to have some other advantage that will cause it to surpass bitcoin, then this dynamic could be inverted."
    ]
  },
  {
    "question": "Apart from the official bitcoin client what other clients are there?Apart from the official client found at the bitcoin.org site what is the list of alternative bitcoin clients? And what OS do they work on?",
    "answers": [
      "There is a current list of clients here http://en.bitcoin.it/wiki/Category:Clients There is development discussion around alternative clients here http://bitcointalk.org/index.php?board=37.0 Currently the \"Official Client\" (more specifically, the Satoshi client) is the most widely used and has implementations that run on Windows, OS X, and Linux. However, multiple alternative clients have been developed, including ones that run on Android, and this is currently a high priority for the bitcoin community. The current most popular alternative clients are BitcoinJ, written in java http://code.google.com/p/bitcoinj/ and BitDroid, which runs on Android https://github.com/cdecker/BitDroid-Network",
      "LoveBitcoins.org has a list of clients for various platforms."
    ]
  },
  {
    "question": "Are there scientific studies related to the Bitcoin technology?Besides “ Bitcoin: A Peer-to-Peer Electronic Cash System ”, which is more like a brief description of the general framework, are there other ‘scientific or research grade’ studies about Bitcoin technology? Can similar decentralized crypto-currency models be found in the literature?",
    "answers": [
      "Bitcoin is a relatively new phenomenon and the peer-review process takes a while, so there is not much out there yet. The most notable is a network analysis of bitcoin transactions done around the alleged \"allinvain\" theft earlier this year. http://arxiv.org/abs/1107.4524 Other than that, there are currently a few articles published in academic journals that focus on bitcoin (as well as pop-sci and pop-compsci articles in various places) For example Grinberg, Reuben, Bitcoin: An Innovative Alternative Digital Currency (April 21, 2011). Available at SSRN: http://ssrn.com/abstract=1817857 The best answer may be to do this in the form of a community wiki where articles published in academic journals can be posted by subject, as if bitcoin survives it will obviously start to receive a lot of attention.",
      "Yes, there are studies about decentralized digital currencies. Some of them use ideas very similar to what Bitcoin chose, for instance refer to chapter 2 of this thesis . The following Google scholar serarches will give you more reading: http://scholar.google.ca/scholar?q=Decentralized+digital+currencies&hl=en&btnG=Search&as_sdt=1%2C5&as_sdtp=on and http://scholar.google.ca/scholar?q=related:hCw5g5lkHWcJ:scholar.google.com/&hl=en&as_sdt=0,5 The basic premise of a decentralized mint is not a new idea, and has been studied for a while."
    ]
  },
  {
    "question": "What is a good mining pool/payout model for infrequent mining?I usually mine only, when I do stuff using my PC so it is on anyway. So far I used Slushs Pool but they have a score based reward system, which seem to punish casual mining. If a long round ends >15 minutes after leaving the pool (due to shutdown the system) you'll probably get nothing at all. What are better payout models for the casual miner and what pools can be used?",
    "answers": [
      "There are multiple approaches to pooled mining, each with its own benefits and detriments. Assuming you are a dedicated miner who does not pool hop then the scenario you describe should be an \"edge case\" that should rarely if ever occur. That said, common payout schemes include: PPS - Pay Per Share. Each submitted share is worth certain amount of BTC. Since finding a block requires shares on average, a PPS method with 0% fee would be 50 BTC divided by . It is risky for pool operators, hence the fee is highest. SMPPS - Shared Maximum Pay Per Share. Like Pay Per Share, but never pays more than the pool earns. ESMPPS - Equalized Shared Maximum Pay Per Share. Like SMPPS, but equalizes payments fairly among all those who are owed. CPPSRB - Capped Pay Per Share with Recent Backpay. Prop. - Proportional. When block is found, the reward is distributed among all workers proportionally to how much shares each of them has found. PPLNS - Pay Per Last N Shares. Similar to proportional, but instead of looking at the number of shares in the round, instead looks at the last N shares, regardless of round boundaries. Score - Score based system: a proportional reward, but weighed by time submitted. Each submitted share is worth more in the function of time t since start of current round. For each share score is updated by: score += exp(t/C). This makes later shares worth much more than earlier shares, thus the miner's score quickly diminishes when they stop mining on the pool. Rewards are calculated proportionally to scores (and not to shares). (at slush's pool C=300 seconds, and every hour scores are normalized) The important factor is that you avoid Proportional payout systems as they are vulnerable to pool-hopping so you will probably lose some portion of your revenues to hoppers on those pools. For your concerns, SMPPS, ESMPPS or PPLNS would be good choices, but there are other factors to consider and it is ultimately up to you to choose a payout scheme and pool that best fits your needs.",
      "Flat pay-per-share may be best. These tend to have the highest percentage fees, but the payout is 100% predictable. There are a few PPS pools, such as abcpool.co and btcserv.net with no fee. The only thing they keep are the transaction fees, so your payout per submitted share is 50 divided by the current difficulty."
    ]
  },
  {
    "question": "Is there a way to undo transactions with a \"too low\" fee?Suppose we reach a state where only transactions that pay a fee are accepted by miners. Further supposed that someone created a transaction using an old/odd client that allowed them not to send any fees. In this case, what would happen to the transaction? Could it be undone? Would the coins be lost forever?",
    "answers": [
      "The transaction would have no effect. A transaction that wasn't accepted by the network has no effect on the ability to spend coins. The person whose coins were affected could simply delete that transaction from his own database. There's no need to undo the transaction since it was never committed to the block chain anyway.",
      "I have successfully used the methodology described here to delete a transaction which didn't go anywhere because of a too low fee. In short, the process is as follows: Configure Linux machine with db4.8-util and bitcointools . Ubuntu works fine. Run following command on your data folder: ./dbdump.py --datadir ~/.bitcoin --wallet-tx > tx.txt Open tx.txt using text editor. Find transaction in question. Should look like: ==WalletTransaction== 12a75d48a002ab920 ... block: 00000000000000000000000000000000 ... 2 tx in, 1 out TxIn: value: 0.007640 prev(c09e92cb94ff1fb6d4 ... TxIn: value: 0.000050 prev(7dcda75e6ad8b5adc7 ... TxOut: value: 0.007690 pubkey: Script: DUP HA... Reverse the 12a75d48a002ab920... value, get something like 92ab02a0485da712 . Don't need to reverse the whole line, just a few hex values from beginning. You will need to search for this in the database dump. Dump the database using following command: db4.8_dump ~/.bitcoin/wallet.dat > dumpfile Using text editor open the dumpfile and search for that 92ab02a0485da712 line you found earlier. There will be two lines - key and value, you need to delete both. Save the file. Re-import the database using the following command: db4.8_load ~/.bitcoin/wallet2.dat < dumpfile If all went fine, the wallet2.dat will have a database without transaction in question. All of this, of course, only works if transaction was never accepted by the network, which is likely the case if you already waited a day, and nothing happens. There is no way to undo transaction which was already accepted by the network. I tried this technology twice and both times worked fine."
    ]
  },
  {
    "question": "Is it true that Paypal banned Bitcoins, while Google Checkout did not (yet)?Paypal claimed they were not allowed to sell Bitcoins, while currently it seems Google Checkout is a viable option. So ... what's the story on this? Is this true, and if so does anyone know why?",
    "answers": [
      "I can't speak for why Google Checkout seems to have no problem, it may simply be that they are unaware of Bitcoin as of yet. Edit: A Google Checkout employee has replied that they explicitly allow virtual currencies - at least for the time being. PayPal, on the other hand explicitly bans \"the sale of traveler’s checks or money orders, currency exchanges or check cashing\" in section 3(f) their acceptable use policy .",
      "We don't have any official word from PayPal about why they prohibit these kinds of transactions. The usual conspiracy theory is that these types of commodities could ultimately compete with PayPal so PayPal wants to hold them back. This really doesn't make all that much sense -- PayPal is not going to decide whether Bitcoin succeeds or fails. The likely explanation is that these types of transactions have a very high fraud rate, particularly buyer fraud. The buyer simply claims he never got his Bitcoins, and PayPal then has to figure out how to verify the transaction. You'll notice that most of these sites charge a huge premium (25% or so) over exchange rates. This tends to suggest that they're falling victim to a \"fraud spiral\". When an exchange has a high fraud rate because of its more liberal policies, they have to raise their rates. Legitimate users just use other exchanges because they prefer to comply with the more restrictive policies rather than paying a 25% premium. Of course, those trying to commit fraud don't care that the rates are terrible, they're not paying them anyway. So high fraud leads to bad rates which leads to legitimate users leaving and thus a higher percentage of fraud, and so on."
    ]
  },
  {
    "question": "Is the timestamp in the genesis block relevant?Bitcoin's genesis block contains this text published in The Times on January 3rd, 2009: The Times 03/Jan/2009 Chancellor on brink of second bailout for banks According to the Bitcoin Wiki , this guarantees that the block was only created after this date. What would be the problem of using any other random quote?",
    "answers": [
      "The newspaper quote proves that Satoshi did not mine a large number of blocks before the public announcement of Bitcoin on January 10. The block chain creator could for example create a chain of 1000 blocks before publishing just the first one. He now has a head start for mining and can invalidate the public block chain at any time by announcing the blocks he kept secret as long as his chain is longer. The block headers contain timestamps but these can be manipulated if no one else is verifying the blocks."
    ]
  },
  {
    "question": "How can I transfer all funds to new keys?My wallet.dat (bitcoin-3.4) has maybe been left on a work machine, leaving it accessible to the admins there. I would like to transfer all my current funds to a new wallet. How do I do this and how can I make sure that: I still will be able to receive on the old keys (in case someone sends something there) Not all my funds are transferred to the same key, making me more traceable.",
    "answers": [
      "Easiest way I can think of: Use up all of the addresses in the keypool by requesting 100 new addresses. If you're comfortable in the command-line on Mac or Linux: for i in {1..100}; do bitcoind getnewaddress; done Then perform a bunch of sends-to-self using MORE freshly-generated addresses. Again, if you're comfortable on the command line and had (say) 10 bitcoins in your wallet you wanted to send in 10 different transactions over the course of an hour you might do: for i in {1..10}; do bitcoind sendtoaddress $(bitcoind getnewaddress) 1; sleep 360; done This wallet will still get coins sent to the old addresses, although if somebody at work DID have a copy they could also spend coins that came in to the old addresses. There's not much you can do about that.",
      "Any public bitcoin address has corresponding private key that is used to control funds sent to that public address. So you can receive on the old keys as long as you don't lose corresponding private keys from the old wallet. It is also possible to export information from old wallet to new wallet with Pywallet , but of course make sure to have backups and use the program at your own risk. Patched version of bitcoin client from Coderrr ( bitcointalk thread ), allows to choose Send From addresses for transaction to increase anonymity, but you would still have to manually enter different Send To addresses. TLDR: this patch allows you to … see all addresses, including change see which addresses are linked together (does recursive expansion of address linkages) select which address(es) to send from, rather than letting the client to chose (randomly) for you Complete anonymity is achievable, but complicated task when sending bitcoins, Bitcoin Wiki - Anonymity has good tips for that."
    ]
  },
  {
    "question": "Has anyone attempted to make a working voting system using a bitcoin based system?It occurred to me the other day that the difficult problem of electronic voting could possibly be solved quite nicely using a bitcoin system. I believe it's transparent enough to be trusted. I found a few threads discussing this already. Has any work been done in this area yet? I think it's worth investigating. Some threads I seen are here and here",
    "answers": [
      "The bitcoin concept has no method to limit anything to a single entity. I am one person yet on bitcon network I have multiple addresses, I have multiple wallets which contain multiple addresses, I make up multiple nodes, I have multiple rigs with multiple GPU each, I use multiple IP addresses. Everything about the bitcon network was designed to allow such a scenario to take place. evoting requires multiple concepts which are incompatible with current bitcoin network 1) authenticate the person voting (is this person a valid registered voter). 2) keep the authenticated person anonymous. 3) ensure votes can't be duplicated 4) ensure vote count is public, verifiable, and immune to abuse by central authority eVoting not be solved \"easily\" by bitcoin network. I would say eVoating can't be solved \"easily\" period. There are some very non-trivial issues with the combination of the above requirements. The bitcoin network doesn't help to ensure that any of the 4 principles above are met.",
      "At least one group has at least claimed to develop a voting system based on Bitcoin. http://www.newscientist.com/article/mg21328476.500-bitcoin-online-currency-gets-new-job-in-web-security.html According to the article: The pair have used their method, known as CommitCoin, to close a loophole in a voting system they helped develop. In the Scantegrity system, voters receive a confirmation code from the list that is cryptographically linked to their selected candidate and can be used to check on the election website that their vote is counted."
    ]
  },
  {
    "question": "How does the Bitcoin client encrypt the wallet.dat file?What is the algorithm used for encrypting the wallet.dat file?",
    "answers": [
      "A detailed explanation can be found in the application's README: https://github.com/bitcoin/bitcoin/blob/6b8a5ab622e5c9386c872036646bf94da983b190/doc/README In short: The passphrase is converted to a key/iv pair using EVP, with a dynamic number of rounds This key/iv pair is used to encrypt a randomly-generated master key, using AES-256-CBC The secret part of wallet keys are then encrypted using that master key, again with AES-256-CBC",
      "Pieter's answer covers the technical details so I won't repeat any of that. I would add that users should remember that the weakest point in Bitcoin-core wallet or any cryptographically strong encryption system is the passphrase. The system converts a passphrase to an AES-256 key and that password derived key is used to encrypt a randomly generated master wallet key. The master wallet key can not be brute forced barring a compromised or flawed PRNG however attackers can attempt to brute force the passphrase itself. The client adds attempts to harden against this attack by using both a salt (random number) and multiple rounds of hashing. The salt prevents a precomputation attack as the same passphrase with different salts will produce different keys. The use of multiple rounds of hashing slow down brute force attacks because the attacker will also need to perform multiple rounds on each passphrase attempted. The client uses dynamic key hardening. This means the number of rounds varies based on the computational power of the client (to keep time to encrypt or decrypt below 1 seconds). The more computing power your hardware has the more rounds it performs, and the more difficult it will be to brute force the password. When you change your passphrase the client will adjust the number of dynamic rounds based on your current hardware's computing power. By updating your password periodically you can ensure the password derived key keeps up with Moore's law. Key hardening through the use of salt and key stretching can only go so far. If your password is \"p@ssw0rd!\" or some other known commonly used password it will still be trivial to brute force the wallet. To illustrate why lets assume the attacker has hardware which can attempt 100M hashes per second and your wallet is using 100,000 rounds of hashing. This means the attackers hardware (100M hashes) can attempt 1,000 passwords per second. So the wallet does slow the attacker down but if the password is weak then it can't slow it down enough. There are lists of previously compromised/stolen/hacked passwords publicly available with tens of millions of passwords. Without key stretching an attacker could attempt all possible known passwords in less than a second. Key stretching slows that down to a few hours. On the other hand lets say that your password was unknown and strong enough that with a single hash it would on average take one day to brute force. With 100,000 rounds that increases the time to centuries."
    ]
  },
  {
    "question": "ECDSA r, s encoding as a signatureAn ECDSA algorithm when signing a given messages produces a pair of outputs, r and s . How, given a sigStr from a Tx can one extract r and s? Are they just concatenated byte arrays of a specific length, or is there more to it?",
    "answers": [
      "If you want, you can pay $100 for the standard, ANSI X9.62 . Or, you can cheat and look at RFC3278, section 8.2 . It is in DER format consisting of a SEQUENCE of two INTEGERs. The first INTEGER is r , the second s . If you look at this transaction you can see that one of the signatures is: 3045 0220 316eb3cad8b66fcf1494a6e6f9542c3555addbf337f04b62bf4758483fdc881d 022100 bf46d26cef45d998a2cb5d2d0b8342d70973fa7c3c37ae72234696524b2bc812 01 If we parse that as DER, we get: 0:d=0 hl=2 l= 69 cons: SEQUENCE 2:d=1 hl=2 l= 32 prim: INTEGER :316EB3CAD8B66FCF1494A6E6F9542C3555ADDBF337F04B62BF4758483FDC881D 36:d=1 hl=2 l= 33 prim: INTEGER :BF46D26CEF45D998A2CB5D2D0B8342D70973FA7C3C37AE72234696524B2BC812 You can also peek at the OpenSSL source code, file ecdsa/ecs_asn1.c : ASN1_SEQUENCE(ECDSA_SIG) = { ASN1_SIMPLE(ECDSA_SIG, r, CBIGNUM), ASN1_SIMPLE(ECDSA_SIG, s, CBIGNUM) } ASN1_SEQUENCE_END(ECDSA_SIG)",
      "R and S are visible in each of the tx inputs. You can see them already extracted on this site. I also provide the Z value. https://2xoin.com/tx/711b6457b4b2b51e56b94ab541a75d02908648a9de26a3c0ce5b2c3b10573d4e See the bitcoin protocol specification for more info about the byte order. https://en.bitcoin.it/wiki/Protocol_specification#tx Below is an example of a TX input hex, 4830450220657912a72d3ac8169fe8eaecd5ab401c94fc9981717e3e6dd4971889f785790c022100ed3bf3456eb76677fd899c8ccd1cc6d1ebc631b94c42f7c4578f28590d651c6e0141049b5506df53ff5eff7dc553131043bb993f55d2b0fddd866984f593777023c8226920ff05747ccb963f0fe459cb217d502e57dcf8afec786c3dcee4d1558f85fa Now separated to make it easier to read, 48 3045 0220 (The Hex 20 says the next 32 bytes are the R value) 657912a72d3ac8169fe8eaecd5ab401c94fc9981717e3e6dd4971889f785790c 0221 (The hex 21 says the next 33 bytes are the S value) 00ed3bf3456eb76677fd899c8ccd1cc6d1ebc631b94c42f7c4578f28590d651c6e 0141 (The hex 41 says the next 65 bytes are the public key) 049b5506df53ff5eff7dc553131043bb993f55d2b0fddd866984f593777023c8226920ff05747ccb963f0fe459cb217d502e57dcf8afec786c3dcee4d1558f85fa"
    ]
  },
  {
    "question": "How is the exchange rate for Bitcoin established?I noticed that there are exchange rates for Bitcoin to other given currencies. How are these rates established?",
    "answers": [
      "You have people that have BTC or currency already in their accounts. Those people can claim: \"I will buy/sell X amount of Bitcoins for Y amount of currency\". If you divide one by the other, you have the exchange rate for that particular transaction. If a buy and sell transaction overlap, they are executed and removed from the system. After all such transactions are removed, you have a gap between the exchange rate at which people want to buy Bitcoins, and that at which people want to sell Bitcoins. Average the closest buy-sell pair of transactions and you have the exchange rate, halfway between those two, or the price of the last trade may be used. In both cases, it's only an estimate of the price that the next trade will take place at.",
      "Most exchanges use the double-auction market system for price discovery. Read more at http://www.investopedia.com/terms/a/auctionmarket.asp In economics-speak, the auction market converges where supply and demand intersect."
    ]
  },
  {
    "question": "How to calculate new \"bits\" value?Every 2016 blocks one needs to calculate new bits value. What is the formula to calculate it?",
    "answers": [
      "What does the bits field represent? First of all, we need to understand what the 'bits' field means. Bits is in 'compact' format. This is kind of like a floating point format, but it represents big integers rather than arbitrary real numbers. The first byte indicates the number of bytes the represented number takes up, and the next one to three bytes give the most significant digits of the number. If the 2nd byte has a value greater than 127 then the number is interpreted as being negative. To convert a positive integer to 'compact' format, we: convert the integer into base 256. if the first (most significant) digit is greater than 127 (0x7f), prepend a zero digit the first byte of the 'compact' format is the number of digits in the above base 256 representation, including the prepended zero if it's present the following three bytes are the first three digits of the above representation. If less than three digits are present, then one or more of the last bytes of the compact representation will be zero. Example 1 - Convert 1000 to 'compact' format For example, to represent 1000 in 'compact' format, we convert to base 256: 1000 = (0x03)*256 + (0xe8)*1 So we have a 2 digit base 256 number: 03 e8 The first digit is not greater than 0x7f, so we don't prepend a zero digit: 03 e8 Then the compact representation becomes: 02 03 e8 00 Example 2 - Convert max target to 'compact' format The minimum difficulty has a target of 2^(256-32)-1. Let's represent that in 'compact' format. First we convert it to base 256: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff That's 28 0xff digits. The first digit is greater than 0x7f, so we prepend a zero digit: 00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff Now it's 29 digits long. hex(29) = 0x1d. So the 'compact' representation of this is: 1d 00 ff ff Notice we've lost a lot of 'ff' digits there. We've only kept 2 bytes of precision, what with the size byte and the prepended zero byte using up two of the four available bytes. If we were to convert back from 'compact' format to see what number we've actually stored, we get: ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 which is in fact the maximum target used by Bitcoin. This is what a difficulty of 1 sets the block hash target to be. How is the value of the bits field calculated? Now that we know what the bits field means, we can look at how its value is decided. In the official client, the bits value is calculated by function GetNextWorkRequired() in src/main.cpp , which does the following: if we're working on a block that's a multiple of 2016 (every 2 weeks) look at the timestamps on the last block, and the block 2015 blocks before it calculate the difference in these two timestamps if the difference is greater than 8 weeks, set it to 8 weeks; this prevents the difficulty decreasing by more than a factor of 4 if the difference is less than half a week, set it to half a week; this prevents the difficulty increasing by more than a factor of 4 multiply the difference by the current target (ie. the current bits converted from 'compact' representation to the target it represents) divide the result by 2 weeks if the result is greater than the maximum target ( 2^(256-32)-1 ), set it to the maximum target convert the result to 'compact' form, and use that as the new bits value otherwise (we're working on a block that's NOT a multiple of 2016 if we're on testnet and it's later than 15 Feb 2012 if it's been more than 20 minutes since the last block was found set bits to its highest possible value, 0x1d00ffff , which represents a difficulty of 1; this is the ' special-min-difficulty rule' otherwise set bits to the same as in the last non- special-min-difficulty rule block otherwise (we're not on testnet, or it's before 15 Feb 2012) set bits to the same as in the last block",
      "Here is the relevant code from main.cpp: static const int64 nTargetTimespan = 14 * 24 * 60 * 60; // two weeks static const int64 nTargetSpacing = 10 * 60; static const int64 nInterval = nTargetTimespan / nTargetSpacing; ... // Go back by what we want to be 14 days worth of blocks const CBlockIndex* pindexFirst = pindexLast; for (int i = 0; pindexFirst && i < nInterval-1; i++) pindexFirst = pindexFirst->pprev; assert(pindexFirst); // Limit adjustment step int64 nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime(); printf(\" nActualTimespan = %\"PRI64d\" before bounds\\n\", nActualTimespan); if (nActualTimespan < nTargetTimespan/4) nActualTimespan = nTargetTimespan/4; if (nActualTimespan > nTargetTimespan*4) nActualTimespan = nTargetTimespan*4; // Retarget CBigNum bnNew; bnNew.SetCompact(pindexLast->nBits); bnNew *= nActualTimespan; bnNew /= nTargetTimespan; if (bnNew > bnProofOfWorkLimit) bnNew = bnProofOfWorkLimit; ... return bnNew.GetCompact(); So the important steps are: Translate the bits of block n+2015 to a BigNum target. Calculate the timespan between blocks n and n+2015 (as an integer number of seconds). Multiply the old target by the timespan. Divide the result by the desired timespan 2 weeks = 1209600 seconds. This is integer arithmetic so it's rounded down. The result is the new target. Convert the target to bits. The code for the CBigNum class is at bignum.h."
    ]
  },
  {
    "question": "How can I buy Bitcoins with Australian Dollars?Please! I just want to get them! How hard does it have to be? I've spent some 5 hours today trying to figure it out. I am in Australia.",
    "answers": [
      "This question answers the more general question \"How do you obtain Bitcoins?\" Most commonly, people use a Bitcoin exchange to exchange local currency for Bitcoins. Here is a list of exchanges split by currency and whether they're currently active or not.",
      "LocalBitcoins.com has buy and sell online in AUD and also AUD cash trade: https://localbitcoins.com/country/AU If you buy from a trader with good reputation history and fast response times you can get bitcoins within an hour."
    ]
  },
  {
    "question": "What are the safety guidelines for using the Sign Message feature?bitcoin-qt's dialog box states, \"Be careful not to sign anything vague, as phishing attacks may try to trick you into signing your identity over to them. Only sign fully-detailed statements you agree to.\" What would this kind of attack look like? What are some examples of statements that would be safe to sign agreement to?",
    "answers": [
      "The signing mechanism is a way of proving that a particular message was signed by the holder of an address' private key. A merchant could ask that you sign a message stating where you want your order shipped to, using one of the addresses your payment originated from. You should sign a statement saying \"I, Jane Doe (jane.doe@email.com) sent 1.23 BTC to Acme Corp at 12:34pm, 1st Jan 2012 in payment for product XYZ for delivery to 456 High Street, Anytown, USA\". You shouldn't sign a vague statement saying \"yes, I sent that money; send the product to the address I emailed you\", because anyone seeing a copy of that signed message can then pass that on to the merchant with his own postal address and get the product you paid for, in the same way as you wouldn't put your signature to a piece of paper saying \"I agree to the above\" where the above was left blank. The postal address part won't be signed, but perhaps the merchant won't care.",
      "You could really use any address for that matter, as long as whatever address you choose + the message itself + the verification signature are all the same. So it doesn't prove that your the owner of the address, it just proves that message you sent is the one you expect the receiver to be able to verify. Seems a bit useless to be frank."
    ]
  },
  {
    "question": "Why is Bitcoin so susceptible to credit card fraud?I understand that you can't buy Bitcoins with a credit card due to massive fraud problems involving chargebacks. Why is Bitcoin more susceptible to this then the thousands of other businesses that take credit card payments for non-physical products (say, RPGNow, Bandcamp, iTunes and so on).",
    "answers": [
      "Bitcoin strongly enforces two concepts - high anonymity and no chargebacks. Because of high anonymity, it is nearly impossible to be 100% certain who you are sending Bitcoins to. In the end, the Bitcoin address is just an arbitrary string of characters. Because of no chargebacks, once you send someone Bitcoins, they are irreversibly theirs (assuming no double-spends and no 51% attack). You can't later recall the money you sent this way. When someone would buy Bitcoins with a credit card, they could wait until the coins appear in their wallet, and then claim that their credit card was stolen used by someone else to purchase Bitcoins without their intent. They could get away with their chargeback claims, as it would be impossible for the seller to prove that they sold the coins legitimately to the person. Moreover, the seller wouldn't be able to get their Bitcons back due to \"no chargebacks\" rules. What makes it different from services like iTunes and the like, is that the value of the Bitcoins is close to how much it costs the seller to aquire and sell them, whereas iTunes' costs are marginal. For example, buying a 1$ song from iTunes would mean that they have to probably spend less than a penny processing everything and providing you content (logging transaction, letting you download the song, etc), whereas if you send 1$ in Bitcoins, you are sending about 1$ worth of goods. When iTunes gets charged back, they lose a penny and can still sell the song any amount of times. When a Bitcoin seller gets charged back, they lose a dollar and can't sell the same coins again. Bitcoins can't be copied and distributed to multiple people at marginal cost, that's what makes chargebacks so costly for any potential sellers.",
      "It's because bitcoin transactions are final, and exchange margins are low. Businesses selling something for download can afford to be hit by fraud without incurring any real loss (other than potentially an opportunity cost, but even that is likely to be minimal as fraudsters would be unlikely to pay even if they couldn't defraud). ie margins are high. However, when bitcoins are purchased with a credit card, it's more similar to a physical cash withdrawal from a credit card. Once physical cash or bitcoins are handed over the transaction is final. The party that hands over the cash or bitcoins has a lot to lose if the credit card transaction is reversed. They can't get their cash or bitcoins back. Fees charged for performing an exchange are low, so can't cover the cost of fraud. Other types of businesses that sell physical goods online and ship them are probably careful to ensure they have validated identification or a physical address so that they have something to pursue in case of fraud. In some cases, the cost of the physical goods may be low enough that some risk of fraud is acceptable."
    ]
  },
  {
    "question": "What is a block withholding attack?How can a block withholding attack be performed, what would be its purpose and who is it a danger to? Edit: when I posted this I was thinking about withholding a block you mined in a pool. But withholding blocks can form the basis for many different attacks. I think this is still useful as a broad question. It is a central concept in bitcoin security.",
    "answers": [
      "The simplest form of it called Finney attack, named for Hal Finney who first described it. The attack is variation of a double-spend attack involving accepting 0-confirmation transactions. An attacker would generate a valid block but will not broadcast it, and then broadcast transaction A as a payment for a good or service. A merchant will see transaction A with nothing conflicting with it and accept the 0-confirmation transaction. Right after that the attacker would broadcast the generated block with transaction B which will conflict with transaction A, the Bitcoin network will accept his block and invalidate transaction A. The attack is quite costly because there is a time gap between generation of the block by the attacker and completing transaction A, during which someone else on the network could generate a valid block and broadcast it, thus invalidating the valid block generated by attacker. Therefore it is practical only if the merchant sells the product online and it could be release immediately, e.g. a key for a software product. A general form of this attack was described by Satoshi Nakamoto: White Paper, section 11 . In theory, an attacker could pre-generate any number of blocks, e.g. if a merchant requires 1 confirmation before releasing a product an attacker would pre-generate 2 blocks ahead of the network and only then broadcast transaction A to double spend. But with each block the cost increases exponentially, and the practice of accepting 6 confirmations before releasing the purchase makes this attack possible only in case where the attacker has close to 50% of network hash rate or more.",
      "There are two types of block withholding attacks. One, known as the Finney Attack, aims for financial gain when a double spend occurs. The second is to cause financial harm to a pool operator. A miner that solves a block can withhold a valid hash after finding one. The cost to the miner is trivial (from not being awarded the share) but the cost to the pool is large as the pool loses a chance to earn the 50 BTC block award subsidy."
    ]
  },
  {
    "question": "Can casual people still mine for bitcoins, now that the difficulty is much higher than it was?Can casual people still mine for bitcoins? As of October 2012, the difficulty seems very high, being over 3,000,000. I've seen a ad for bitcoins, and watched the video. It said I could mine for them with my computer, so can I?",
    "answers": [
      "Well, you can TRY mining. To see how much coins you can expect, check your computer's GPU on the Wiki page , get its hash rate, and plug that into a profitability calculator, such as mine . This can give you an idea of how many coins can you expect to mine and whether you would get any profit from that. Unfortunately, most likely you won't be able to mine at a profit using a PC. Bitcoin's difficulty is quite high, the reward will be dropping by half soon, and with the introduction of ASIC miners, GPU mining will be outclassed. However, if you are willing to invest some money into custom hardware , you can still start your career as a full-time Bitcoin miner. But again, you ought to check if it calculates for you . However, if you want to try your luck at a newly emerging trend of using your GPUs to \"mine\" for split-key vanity addresses, you can check out my Vanity Pool , or its topic on BitcoinTalk . The process is quite similar, but the profit margin can be better.",
      "Normal people can mine but normal computers can't mine profitably. At least not any longer. Right now, in mid-October 2012, some people are doing OK mining on GPUs, particularly those who don't pay directly for electricity. However, roughly sometime around the end of November the mining proceeds get cut by half instantly -- something that happens every four years. After that point, there will not be many GPU miners who can continue to mine -- unless, again, they aren't paying for electricity. Others have bought specialized hardware known as FPGAs (a BFL single is an FPGA). Those use less electricity than GPUs so they will still mine at a profit. But a gamechanger is likely coming from ASIC manufacturers . Several are accepting pre-payment on orders now, though not a single ASIC design has shipped yet. There's no harm that occurs from using your computer (with GPU) to try to learn mining -- if you are looking for a hobby. But to mine for profit will generally only make sense from the purchase of mining hardware."
    ]
  },
  {
    "question": "Where is a comprehensive list of websites for getting free bitcoins?Up till now I know two websites where one can get free bitcoins: http://www.bitvisitor.com/ https://freebitcoins.appspot.com http://freebitco.in http://takefreebitcoin.com/ Is there a comprehensive list of all such websites available somewhere?",
    "answers": [
      "Constantly updated list: https://bitcointalk.org/index.php?topic=90718.0 Free Bitcoin sites: The Bitcoin faucet. One time payout per Google account. Explanation available at the site. Daily Bitcoins. Can be used once an hour now, and not just once a day. CoinAd.com. Can be used once an hour with registration. Bitcoin Addict Bitcoiner Bunny Run. See here for more info. Free bitcoins - netlookup.se Nakabot's Bitcoin Faucet (Tor hidden service) NakaBot pays out a portion of its winnings in 0.001 increments. Free BitCoin Daily Scratchcard kickme.to/goxkeygen MtGox account needed to redeem the code one receives. bitcoinpixels.com 0.01 BTC free when signing up to betfair. See here for more info. memorydealers Learn how here. Omnicoins Learn how here. cointicket.org BitCrate * bitcoins.so * Roll dice : same numbers - win 0.01 Paperco.in faucet * Scan a QR code to reveal a MtGox code for 0.0007 BTC. Gambling sites that give out free bitcoins ( freerolls etc. ) after you join Dragon's Tale A casino site, but gives out small amounts for free that you can use to gamble with or withdraw to your own Bitcoin wallet. Seals with Clubs Seals has a free poker tournament every hour with a .05BTC prize. There are larger free tournaments from time to time. See here for more info. Strike Sapphire See here for more info. Not exactly Free but popular \"earn\" Bitcoin sites BitVisitor Earn Bitcoins for visiting websites CoinTube.TV Earn Bitcoins for watching TV",
      "You can also check out this site: http://earnfreebitcoins.com EarnFreeBitcoins.com is a website in which you earn small amounts of Bitcoins in exchange for visiting websites for a designated period of time. You may be required to spend anywhere from one minute, up to five minutes or more on the sponsored website. You must spend the full amount of required time on the website in order to recieve payment."
    ]
  },
  {
    "question": "Is it possible to figure out whether two addresses are in the same wallet?I'm wondering, if I sent some bitcoins from one of my own addresses to another address in my wallet, will it be possible for someone to figure out that both addresses are in the same wallet? Or can I claim the other address is not my own and no one can find out?",
    "answers": [
      "It is possible to tell that two addresses are in the same wallet if they both appear as an input of a transaction. This indicates that one person owns both of them as they can spend both of them. It is also quite likely that when you are sending a transaction that has one neat input (say, 1BTC), and one not so neat (say, 0.59721364BTC), that the latter is most likely a change left over from a transaction you sent to someone and is being sent to another address you own from the same wallet. This claim could be possibly deniable, but should be true in most cases.",
      "No, it is not possible to determine definitively if two addresses are in the same wallet. The protocol does not have the concept of the wallet. The wallet is a concept within the client. That is to say, that the client presents the concept of a wallet as a collection of addresses. The only relation between addresses that the protocol knows about is senders and receivers, or, really, inputs and outputs. It may be possible through a thorough analysis of taint to determine within a reasonable amount of certainty that several addresses are related to each other in a wallet."
    ]
  },
  {
    "question": "How many confirmations do I need to ensure a transaction is successful?As a regular user of Bitcoin, I often send bitcoins to other, or receive BTC from others, sometimes this might be a trade or deposit. Some traders require at least 6 confirmation, some require at least 3. I want to how many confirmation is enough to ensure the transaction is successful?",
    "answers": [
      "It depends on your risk model. If you can trust the person paying you, you can accept payment on 0/unconfirmed if you want. As a merchant or trader, you want to use the configuration that is more secure (no incoming connections permitted, explicity connect to well-connected nodes). With zero confirmations you are vulnerable to the race attack and the Finney attack, as well as the 51% attack. With one confirmation you are vulnerable to the 51% attack. There could also be a miner with a lot of hashing power who could get a couple blocks in a row, so three confirmations removes most of them. With six confirmations it is essentially mathematically impossible for an attacker with less than 51% of all mining capacity to get six blocks in a row. and still surpass the longest block chain. With 51% or a lot more than 51% the attacker can get six confirmations by creating a parallel blockchain in which only transactions approved by the attacker get included in blocks. A merchant like a retailer can likely accept even on 0/unconfirmed in most instances (e.g., purchases up to $100 worth). A merchant that ships e-commerce might hold off until the transaction has three confirmations. A cash, face-to-face cash trade will probably be best if three confirmations for a large amount, maybe one confirmation for small amounts. Any recommendation would need to come only after determining which risks are deemed acceptible.",
      "The lesson of the recent v0.7/v0.8 fork issue is that simply waiting for 6 or more confirmations is insufficient. You also need to satisfy yourself that there are no competing blockchain forks e.g. this thread discusses a double spend proof-of-concept that was executed during the chain fork: https://bitcointalk.org/index.php?topic=152348.0"
    ]
  },
  {
    "question": "Do USA-based miners need to register with FinCEN?As seen in recent news, FinCEN has issued a statement on its classification of virtual currencies: http://www.fincen.gov/statutes_regs/guidance/html/FIN-2013-G001.html Hypothetically suppose I mine BTC and sell it on MtGox for USD. Do I need to register with FinCEN as a Money Transmitter(MT)? My interpretation of the above document indicates yes, I do; but I could also see MtGox (which is registered with FinCEN) maintaining my regulatory compliance, via proxy.",
    "answers": [
      "No, the fincen guidance you posted has it in plain english that you do not. A miner is simply a user. c. De-Centralized Virtual Currencies A final type of convertible virtual currency activity involves a de-centralized convertible virtual currency (1) that has no central repository and no single administrator, and (2) that persons may obtain by their own computing or manufacturing effort. A person that creates units of this convertible virtual currency and uses it to purchase real or virtual goods and services is a user of the convertible virtual currency and not subject to regulation as a money transmitter. By contrast, a person that creates units of convertible virtual currency and sells those units to another person for real currency or its equivalent is engaged in transmission to another location and is a money transmitter.... On the exchange you are buying/selling bitcoins. The exchange carries the burden of giving you legal tender or a different cryptocurrency. The exchange carries the burden of regulation, according to the FinCen regulations. In the US, the equivalent of real currency is only treasury bonds. Also, Fincen regulations only take affect at certain dollar amounts, if you feel you need to be concerned about them. You can also try to get even further clarification from the Treasury yourself, because on this matter it doesn't matter what kind of legal counsel you ask, nobody knows all the semantics until an issue comes up that is actually decided in the courts.",
      "Maybe - check with a lawyer You don't have to register if You use a website (MtGox or Coinlab) to buy coins You use coins to buy \"stuff\" (Namecheap, alpaca socks, etc) You might have to register if: You run a wallet hosting company The FINCen law requires people to register if they Are a mixing service Participate in the Bitcoin OTC market and issue one on one trades with people for cash (or cash substitute) Run an online trading site (MtGox, or similar) I suspect the same requirements apply for Money Orders: Anyone who accepts Bitcoins for any software or service ( over $1,000 ) However, I do understand your concern in this sentence: By contrast, a person that creates units of convertible virtual currency and sells those units to another person for real currency or its equivalent is engaged in transmission to another location and is a money transmitter So what does a Bitcoin miner actually do ? It performs a service for the Bitcoin network and gets paid for it in the form of transaction fees. This value increases over time. It is hardware that competes to solve a math problem and wins new coins for that block. This value decreases over time. Here is an example of a Miner that probably MUST register: A solo miner is configured to not broadcast Tx to other hosts. The miner accepts a Tx with a huge fee. This money substitute in exchange for a service is covered not by the FinCEN note in the OP's post, but implied by this link. I think it's a grey area that isn't well described, and we should look for more guidance. Aside: I don't like saying mining \"creates units of this convertible virtual currency\". I think the actual creation occurred in 2009 when the Bitcoin Protocol was launched. I would argue that the protocol \"creates\" the coins, and USA based miners are just claiming them."
    ]
  },
  {
    "question": "Are there alternatives for proof of work?Bitcoin uses proof of work to secure the network, Ripple uses a global consensus system and PPCoin uses proof of stake. Are there any known alternatives to the above methods?",
    "answers": [
      "A really quick answer is this: The proof of work system is a solution to the distributed synchronization issue; in another guise it is called the Byzantine Generals' Problem . Thus, any solution to this problem is an acceptable alternative, however the proof-of-work solution is particularly suited to distributed systems. You can read Satoshi Nakamoto's discussion of this here .",
      "Another alternative is proof of burn ."
    ]
  },
  {
    "question": "How do I specify in which directory Bitcoin blocks and other data should be stored?I am on Windows and installed the Bitcoin wallet. The block folder seems to grow bigger everyday and is stored on my C drive in the roaming directory. I would like to set this to some other folder on another drive, which has more place. How would I go about doing this?",
    "answers": [
      "I believe you can specify this directory using the datadir configuration in bitcoin.conf . -datadir= Specify data directory See Running Bitcoin ."
    ]
  },
  {
    "question": "How can I transfer a Bitcoin-qt wallet to Electrum?I am switching from bitcoin-qt to Electrum, and it seems as if I will need to download the blockchain again. Can I copy and paste my wallet.dat into Electrum's files?",
    "answers": [
      "Start Bitcoin Core with the wallet.dat you want to export Dump all wallet keys via Bitcoin Core's Console using dumpwallet wallet.dump , where wallet.dump is the name of the dump file to be created. If you get an error, try specifying an absolute file path with a dir to which Bitcoin Core has the permission to write to, e.g. you can specify the same dir as the one where your wallet.dat is located. You'll get a list of private key to address pairs in the following format: L4ysibEFMBQc3hfr7tvUyV4nBP1YQ3AgDewszoYq5czMtXotmmro 2020-08-21T14:36:58Z change=1 #addr=bc1qpw40dkvcj23zt3efvdwqr7ddfunwktx11f3tjf Extract all the private keys (they are in the first column, e.g. L4ysi..mmro ). I remove unnecessary stuff at the beginning and at the end of the dump file manually, then use cut -c -52 wallet.dump > private_keys.dump to leave out everything except of the private keys. Create a new Electrum wallet, select \"Import Bitcoin addresses or private keys\", convert your keys according to the rules available by clicking on \"Info\" button (you may not need to convert them if your wallet.dat is quite old) and you're good to go! The above is tested on Bitcoin Core 0.21.1.0 and Electrum 4.1.5.",
      "According to this FAQ : In Electrum 2.0, you cannot import private keys in a wallet that has a seed. You should sweep them instead. If you want to import private keys and not sweep them you need to create a special wallet that does not have a seed. For this, create a new wallet, select “restore”, and instead of typing your seed, type a list of private keys, or a list of addresses if you want to create a watching-only wallet. You can get the private keys from Bitcoin Core using dumpprivkey as described in Using dumpprivkey to make a paper backup ."
    ]
  },
  {
    "question": "What's the status of alternative full node implementations?In \" Does running an alternative full node implementation benefit the Bitcoin network? \", I asked about running an alternative full node implementation for the benefit of the Bitcoin network. What is the current status of different alternative full node implementations with regard to maturity (alpha/beta/stable) performance compatibility tests code review suitability for different purposes: experimentation merchants as a wallet as a lightweight wallet back-end solely for the benefit of the network? Update: Moved the list of implementations into an answer.",
    "answers": [
      "Update: Coin Dance has an excellent table of node implementations with descriptions and links at the bottom of their Bitcoin Nodes Summary page. Below are the implementations I've found. I'm not sure if all of them qualify as full nodes. btcd (in Go, by Conformal Systems LLC) Bits of Proof (in Java, by bits of proof zrt.) bitcoinj has a fully verifying mode (in Java, by Mike Hearn) picocoin (in C, by Jeff Garzik) libbitcoin has an example full node implementation , also advertises to be a completely independent and full Bitcoin stack albeit only pre-alpha proof-of-concept with no GUI (in C++, by Amir Taaki) caesure (in Python, by Sam Rushing) Electrum-server , uses bitcoind as a back-end (in Python, by thomasv@bitcointalk) Ufasoft Coin (in C++, only for Windows, by Ufasoft) Bitcore (in JavaScript. Note that it needs parts of Bitcoin Core to function) (Sources: Core Development Update #4 by Gavin Andresen, Jun 21 2013 on the Bitcoin Foundation blog; bitcointalk.org forums) Updated bitcoinj and libbitcoin status (based on information from this bitcointalk thread ); Electrum backend Added Bitcore"
    ]
  },
  {
    "question": "Does a wallet containing multiple addresses have a single private key?Title says it all. Would one private key enable you to recover all the addresses in your wallet? Or does a wallet just contain a series of key-pairs?",
    "answers": [
      "There are three main types of wallets: non-deterministic (random) wallets sequential deterministic wallets hierarchical deterministic wallets With a non-deterministic (random) wallet, all the private/public keypairs are generated randomly. The wallet may generate 100 random private keys as soon as it is initialized, for example. With a sequential deterministic wallet, a passphrase or sequence of characters is randomly generated to act as a seed. It is then repeatedly incremented and hashed to generate new private keys. With a hierarchical deterministic wallet, a single keypair is created initially and is known as the master keypair. This master keypair is used to generate child keypairs (remarkably, new bitcoin addresses can be generated using just the public key). Here's a more in-depth explanation: What is a deterministic wallet? Also, here's my python implementation of a sequential deterministic wallet . And here's a good example of a hierarchical deterministic wallet .",
      "There's two types of wallet. A conventional wallet is just a collection of random keys, Bitcoin-QT and Multibit fit into this category. A Hierarchical Deterministic like Electrum or Armory generate all the keys in the wallet from a single key, so that one backup is permanently associated with a wallet no mater how many new addresses and change addresses are used. https://en.bitcoin.it/wiki/BIP_0032"
    ]
  },
  {
    "question": "Why so many warnings about importing private keys?Blockchain.info and other products make you read dire (but vague) warnings that \"you must be an expert\" before you can import private keys. What's that all about?",
    "answers": [
      "Importing a private key can lead to non-intuitive behaviour, and that can be exploited by an attacker. Imagine I'm evil. I give you a paper wallet with 1 mBTC on it. You're happy and import it. I keep the private key and wait. Depending on the client/user, maybe someday you'll put some real money on there as change/received funds. Then I can swipe them right off from you. If you don't bother moving the original money off the key, I can also steal that back. If not, then at the very least I can trick you next time into thinking you were paid by sending funds to that address. Then I can steal them right back. Importing also tends to break backups, especially deterministic key schemes. Armory gives you one line of text for all your keys, and then 1 line per imported key . Every time you import, you'll need to redo all your backups. Because most users don't understand these implications, wallets tend to discourage importing, and instead offer sweeping (moving the funds to an address that was generated by the wallet itself). Supports 90% of the use cases with none of the issues.",
      "because exposing your private keys on your computer will expose them to all the viruses and keyloggers on your computer that non-experts tend to have. thats one reason"
    ]
  },
  {
    "question": "Can I earn transaction fees by running as a full node, verifying transactions, but not mining?As I understand it, by running a full node (i.e. Bitcoin-QT) , I am helping confirm transactions and contributing to the Bitcoin network. When transaction fees are offered, do I receive these, and if so, how? Or do I need to be a fully fledged miner?",
    "answers": [
      "Nope, transaction fees of a transaction can only be collected by including it into a valid block. And to be able to include a transaction in a valid block you have to mine a valid block.",
      "While running Bitcoin-qt it is true you are contributing to the Bitcoin network, but only in the sense that other peers can now download the blockchain using your bandwidth. There are no transaction fees sent to anyone that is not mining. Mining is the process which helps the network transact and thus sending balances from one account to another."
    ]
  },
  {
    "question": "Where can I get all historical trades BTC price data?Where can I get all historical trades BTC price data? (There are some similar questions, but I am looking for high-resolution data, while the previous questions asked for lower resolution data, such as daily prices.)",
    "answers": [
      "http://api.bitcoincharts.com/v1/csv/ Each of these files have every trade executed on the given exchange (except the last 15 minutes or so).",
      "You might want to try http://www.cryptodatasets.com/ It has free raw data and sampled data from Bitfinex and HitBtc (currently). P.S. it's my website"
    ]
  },
  {
    "question": "What are the minimal system requirements to run a full Bitcoin node?I want to build a low profile system running as a full Bitcoin node, i.e. just running Bitcoin Core 0.9+ and pretty much nothing else. What is the minimal system (in terms of power consumption) that would be suitable for this task? Just bitcoind will do, no interface or visual interaction needed. I'd really prefer something where I don't need to build all the software manually. A simple small netbook would do, I guess. But could I even use something like a Raspberry Pi? Or perhaps some other single board computer ? I assume it'll need at least 20-30 GB disk space (for OS + Bitcoin Core with entire blockchain). Is there a minimum amount of RAM I'd need for bitcoind? Curious to hear what kind of system and OS you guys would recommend for this! (P.S. to avoid confusion: I just mean running a full Bitcoin node , not mining)",
    "answers": [
      "Just some thoughts: As of the time of writing the main net's full blockchain size is 21,670,092,800 bytes, a bit more than 20 GB, that is. So you should have way more disk space that just 20-30 GB. A Raspberry Pi runs with an SD. SD is known for its limited rewriting capabilities (it's not a heavy duty storage solution, it will bite the dust after a while) and on top of that there's also the very important factor of the data transfer rate. SD's top model type (Class U3) maxs at 30 MB/s while a typical SATA-3 disk will max at 750 MB/s, which BTW can go as high as 2 GB/s with a SATA Express attached to a twin PCI Express 3.2 lane, but I guess this is not a low-spec computer any more. And yes, I know, you can mount an external USB HD to a R-Pi but even in this case you'll never get these speeds. Some of the top single board computers could perform well, and I think this is the best solution for a low power-consumption full node. For example if you attach a SATA hard drive to IGEPv5 Full Version you will most probably get quite good performance at a very low cost, both of acquisition but operational as well. A low-spec computer could deliver great results with some lightweight linux distributions, my personal favorite is Lubuntu that comes with an LX11DE UI and then bitcoin's installation would be as easy as: Menu > Accessories > LXTerminal > $ sudo add-apt-repository ppa:bitcoin/bitcoin sudo apt-get update sudo apt-get install bitcoind Edit 1: Pictures speak louder than words (as a response to Jannes 's comment, so I'm attaching a few performance screenshots from a full node running in Windows that just received a new block and a couple of minutes after that, as well as an analysis of the I/O index: Verifying incoming block: One of the I/O spikes of the block verification at level 3 (default for all clients): I/O analysis for the above graphs:",
      "You can run a Raspberry Pi with bitcoind no problem. I have several Pi's running bitcoind in various locations and some of them have over 100 connections. Use a 64GB flash card and make sure you have a 512MB swap file. The only limitation you will find is your broadband upload speed , the Pi or it's flashcard will not be the bottlekneck. Use a good quality flash card like Sandisk etc. Also tell your router to route incoming connections on port 8333 to your Pi's IP address. The reason the only limitation is your broadband upload speed is because of parasitic loads such as new users trying to upload the entire blockchain from your Pi. If you do this , try to set your Pi up with blockcahin already loaded onto flash or SSD otherwise it will take some time to synchronise."
    ]
  },
  {
    "question": "Looking for nonces of even numbersEach one of bitcoin and its derived crypto-currencies has a nonce value in the block, no matter what the algorithm is. Every miner tries to search for a luck nonce which can make the hash value smaller than the target under the required difficulty. However, recently I search scrypt based cryptocurrencies, like the dogecoin and vertcoin block chain for few blocks. I found most of the nonce are even numbers, except for (only manually browsed in block explorer) Block #184161 - nonce = 8dce5c01 Block #184143 - nonce = 2a674001 Block #184139 - nonce = 930aa899 many other blocks from the latest block (Block #184174) and blocks in between of them are even numbers. Moreover, many nonce value are in hex number of form XXXXXX00 (in an integer hex number form, it is stored as 00XXXXXX in block), or multiples of 256. The same outcome I observed in Vertcoin blocks. I manually traversed for few blocks and also found nonces of them are also even numbers. I'd like to ask a question. If I configure the scrypt or n-scrypt to search only even numbers, is it possible to have higher chance to find the nonce which can solve the current quickly? BTW, I won't expect the mining revenue of each miner in the pool (PPS or PPLNS) is going to be greater than that of normal nonce searching algorithm because the pool count for \"shares\" you found. When you skip odd numbers, you also lose the chance to get a share (solved by the odd nonce) which can meet the diff the pool gives to you. However, when a pool found a nonce that can solve the block, then the pool wins and gets the rewards. Edited: Apr 18 I wrote a small program to collect some statistical data. From recent Dogecoin block #186,299 to #145,000 (the last mandatory update) total 41,300 blocks number of odds = 3,891 (9.42%) number of evens = 37,409 (90.58%) ratio of odd to even is about 1:10 Among the evens, the number of multiples of 256 = 35,106 85% of total 93.866% of evens Update: 4/20 I recently also checked the nonces from block 552,780 to 253,898 of Litecoin. totally 298,883 blocks. number of odds = 42,963 (14.374521%) number of evens = 255,920 (85.625479%) Among the evens, the number of multiples of 256 = 225,746 75.529890% of total Update: 4/21 I use a small Perl script and call litecoind/dogecoind wallet to print out each block's nonce. It is very slow but quite simple. It would be very fast when you are using binary block database parser. #!/usr/bin/perl -w my $odd = 0; my $even = 0; my $m256 = 0; my $total = 0; for ($i = 186299; $i >= 145000; $i = $i-1) { $nonce = dogecoind getblockhash $i\\; chomp $nonce; $nonce =~ s/[^0-9]*//g; printf \"%d %d\\n\", $i, $nonce; if (($nonce %2)== 1) { $odd++; } else { $even = $even + 1; $m256++ if (($nonce % 256) == 0); } $total ++; } printf \"odds=%d (%f%%) evens=%d (%f%%) 256s=%d (%f%%)\\n\", $odd, (100.0*$odd/$total), $even, (100.0*$even/$total), $m256, 100.0*$m256/$total;",
    "answers": [
      "I think that Tim S. may have the answer with his comment about endian-ness. Your observations about the nonce having its lowest byte zero (being a multiple of 256), are with respect to the little-endian byte order of the block itself. From the perspective of a big-endian machine, these are statements about the high byte of the nonce. So consider a miner which is big-endian. The natural algorithm is \"start with nonce=0, compute scrypt, increment nonce, repeat\", so your \"even\" nonces will be tried first. However, when a new transaction (or a new block from another miner) arrives, a new block header has to be constructed, and it would be natural to restart the nonce at zero when this happens. In order to get a nonce that is \"not a multiple of 256\", it has to complete 2^24 hashes before being restarted. Of course, x86 is the most common desktop CPU, and it is little-endian, but most scrypt mining is done on GPUs. I hypothesize that a majority of these GPUs are big-endian, or at least that some common mining software causes them to increment their nonce in a big-endian manner. Does anyone know if this is the case? From this chart , it looks like modern GPUs can run scrypt at roughly 1 Mhash/sec. So 2^24 hashes would take 16 seconds. Litecoin is currently averaging roughly 10K transactions per day, which is an average of one every 8 seconds or so. So it would not be surprising that a miner would usually not get into their high byte (which for you is the low byte) before restarting. This hypothesis would also explain why we do not see such a pattern with Bitcoin. Current SHA-256 ASIC miners run at many Ghash/sec, and so are very likely to go through all 2^32 possible nonces before being restarted by new transaction data. (We might see patterns in the extraNonce , though.)",
      "I conducted the following tests using C# (using the block header from the Litecoin wiki ; Dogecoin is the same deal). Here's a test using scrypt: (I didn't preset the limit at 14857; it just took so long I stopped it there) var dict = new Dictionary { { 0, 0 }, { 1, 0 } }; byte[] blockHeader = new byte[] { 0x01, 0x00, 0x00, 0x00, 0xae, 0x17, 0x89, 0x34, 0x85, 0x1b, 0xfa, 0x0e, 0x83, 0xcc, 0xb6, 0xa3, 0xfc, 0x4b, 0xfd, 0xdf, 0xf3, 0x64, 0x1e, 0x10, 0x4b, 0x6c, 0x46, 0x80, 0xc3, 0x15, 0x09, 0x07, 0x4e, 0x69, 0x9b, 0xe2, 0xbd, 0x67, 0x2d, 0x8d, 0x21, 0x99, 0xef, 0x37, 0xa5, 0x96, 0x78, 0xf9, 0x24, 0x43, 0x08, 0x3e, 0x3b, 0x85, 0xed, 0xef, 0x8b, 0x45, 0xc7, 0x17, 0x59, 0x37, 0x1f, 0x82, 0x3b, 0xab, 0x59, 0xa9, 0x71, 0x26, 0x61, 0x4f, 0x44, 0xd5, 0x00, 0x1d, 0x45, 0x92, 0x01, 0x80, }; for (uint nonce = 0; nonce < 14857; nonce++) { var nonceBytes = BitConverter.GetBytes(nonce); Array.Copy(nonceBytes, 0, blockHeader, blockHeader.Length - 4, 4); var hash = SCrypt.ComputeDerivedKey(blockHeader, blockHeader, 1024, 1, 1, null, 32); if (hash[31] == 0) dict[nonce % 2] += 1; } Results: 0 32 1 29 And with SHA256 (using the block header from the Bitcoin wiki ) var sha = SHA256.Create(); var dict = new Dictionary { { 0, 0 }, { 1, 0 } }; byte[] blockHeader = new byte[] {0x01,0x00,0x00,0x00, 0x81,0xcd,0x02,0xab,0x7e,0x56,0x9e,0x8b,0xcd,0x93,0x17,0xe2,0xfe,0x99,0xf2,0xde,0x44,0xd4,0x9a,0xb2,0xb8,0x85,0x1b,0xa4,0xa3,0x08,0x00,0x00,0x00,0x00,0x00,0x00, 0xe3,0x20,0xb6,0xc2,0xff,0xfc,0x8d,0x75,0x04,0x23,0xdb,0x8b,0x1e,0xb9,0x42,0xae,0x71,0x0e,0x95,0x1e,0xd7,0x97,0xf7,0xaf,0xfc,0x88,0x92,0xb0,0xf1,0xfc,0x12,0x2b, 0xc7,0xf5,0xd7,0x4d, 0xf2,0xb9,0x44,0x1a, 0x42,0xa1,0x46,0x95,}; for (uint nonce = 0; nonce < 1000000; nonce++) { var nonceBytes = BitConverter.GetBytes(nonce); Array.Copy(nonceBytes, 0, blockHeader, blockHeader.Length - 4, 4); var hash = sha.ComputeHash(sha.ComputeHash(blockHeader)); if (hash[0] == 1) dict[nonce % 2] += 1; } The results: 0 1908 1 1951 This shows that, regardless of whether the nonce is even, coin algorithms produces roughly the same number of high-difficulty results. (I believe this is a good test of both SHA256 coins like Bitcoin and scrypt coins like Litecoin and Dogecoin; yes, I'm pretending the difficulty is much lower by only paying attention to one byte, but the point remains) So why are multiples of 256 and even numbers so common in the real world? My guess is that mining software most commonly chooses these nonces, though there's no benefit to it. For example, what you call a nonce divisible by 256 could be considered a number under 2^24 (with reversed endianness). Nonces don't need to be chosen with high entropy, so it's acceptable for them to be somewhat predictable - just as long as you're not wasting your time by using the same nonce twice on the same block header."
    ]
  },
  {
    "question": "Why can't they use super computers to mine all the bitcoins?I have very limited knowledge of bitcoin, but, I hope you don't mind my asking this question: As I understand it, \"mining bitcoin\" requires \"significant\" computational prowess. A lot of dedicated mining rigs have been built out of FPGAs, ASICs and GPUs. But, I have always wondered: would it not be possible to mine ALL the bitcoins if you had access to some of the most powerful computers? So, for argument sake, if the NSA decided to stop snooping upon people and instead decided to, you know, mine bitcoins… would they be able to mine all the bitcoins in just a few hours if they redirected all their super-computational-power towards this one problem: mining bitcoins? Other potential candidates for this game include, but are not limited to: NASA, DoE, etc. I realize that running a supercomputer to mine bitcoins may NOT be efficient (because a super computer consumes too much power, costs a lot of money, etc) but for a govt agency all that money comes from taxes so ... Now, hypothetically, could \"they\" mine all the bitcoins in a few hours, or even in a few minutes if they redirected all their super-computational-power towards this one problem: mining bitcoins?",
    "answers": [
      "A supercomputer is way slower than mining with ASICs. A supercomputer only has much CPU power, not even GPU power and ASICs are way more powerfull than GPUs. ASICs represent the hashing algorithm as hardware which means they can't do anything else, that's why they are so fast. At http://bitcoinwatch.com/ you can see the current network hashrate in PetaFLOPS, which is 1534782.24 at the moment. Currently the fastes Supercomputer Tianhe-2 has 33.86 petaFLOPS. but for a govt agency all that money comes from taxes so ... If they would use all the money to buy ASICs and start mining bitcoins, it still would not be enough because of the difficulty factor. But they would be able to get a lot of blocks because the difficulty only changes every 2016 blocks.",
      "There are two reasons why they can't flash mine all bitcoins: Difficulty and specialized hardware . First, the pace of Bitcoin creation is limited. The protocol defines how difficult it is to find more bitcoins. At normal pace, the difficulty is evaluated and readjusted about every 10-14 days. However, because the difficulty adjustment happens after a fixed number of blocks, the time until readjustment is shorter when blocks are found at a higher rate. When blocks are discovered quicker than the target 10 minute interval, the protocol requires a readjustment to a higher difficulty , which in turn causes the pace to slow down. For a more detailed explanation see: How does the network adjust the rate at which the coins are created? Mining in Bitcoin is done with application specific integrated circuits . ASIC s are chips that can only execute one algorithm because it is hardwired into the chip. As these Bitcoin ASICs are single-purpose designed to solve only the calculations required for mining, they are highly optimized to do so. This lack in flexibility allows to increase their efficiency over general purpose hardware immensely, and has caused the hashrate of the Bitcoin network (the total \"mining power\") to grow about 20,000x (twenty thousand fold) since the first Bitcoin ASICs have shipped. General purpose chips are many magnitudes less efficient at mining, and therefore don't stand a chance at competing."
    ]
  },
  {
    "question": "How do you create a planet-specific cryptocurrency that will ignore longer block chains from other planets?I'm sure that cryptocurrencies will play a huge part of the economy across the solar system, when we have colonized many different planets, moons, and asteroids. But there are problems with using a single coin for the entire solar system. Let's just start with the example of a Mars colony. Long distances mean long delays in communication so it would take a very long time to get confirmations of Bitcoin transactions that originate on Mars. That could be problematic. Additionally, people on Mars could never hope to mine bitcoins because the average communications delay between Earth and Mars is 20 minutes one way, which is twice as long as the ten-minute blocks of Bitcoin. So I believe that a different coin would be best for each planet. But here's the crazy part. Even if Mars had its own coin (let's call it Marscoin), Earth would most likely have more computer processing power, so miners on Earth could download Marscoin's block chain and extend it faster than the miners on Mars. Then the miners on Mars would no longer be able to mine Marscoin. Then we would be back to the same problem of using Bitcoin on Mars. So, I think someone would have to create a coin that can somehow be planet-specific, so that longer block chains from other planets will always be rejected.",
    "answers": [
      "Simply limit the block target (i.e. 10 minutes) to the speed of light (300,000 km/s). Unless there is some wormhole or other unknown to reduce this limit, Bitcoin is safe from honest mining from any planet outside of 180,000,000 kilometers away (300000km/s * 60 sec * 10 minutes) since any miner can't keep up with the blockchain and would get any block at about the time the next block comes out. Someone with more advanced technology / more hashing power could create a 51% attack and submit it to disrupt the Bitcoin economy even outside of this radius.",
      "TL;DR : Whatever block interval one employs, another planet with greater mining power will eventually overtake the local blockchain. It would only be possible to lock other miners out by adding low-depth checkpoints . Gedankenexperiment: MarsCoin starts a new blockchain with a 2 minute block interval, they have one Unit of Mining Power [UMP] at their disposal with a new MarsCoin specific mining algorithm. Some traders from Earth start using MarsCoin for their transactions with Mars colonists. They get blocks with a 20 minute delay (as proposed in the question). After a while they realize that the MarsCoin mining rewards are quite juicy and technology is much cheaper on Earth than in the underdeveloped colony: They create mining equipment with 2 UMP , allowing them to find blocks twice as fast than on Mars. -20 minutes : Mars is at Block X and broadcasts it to Earth. … 0 minutes : Earth receives Block X from Mars, and starts their own mining effort. The difficulty has not increased yet, so they can mine one block per minute for the time being. Mars is at Block X+10 . 2 minutes : Earth receives Block X+1 from Mars, but Earth is already on Block X+2 on their own chain. Earth subsequently outperforms Mars and continues mining on their own chain. Mars is at Block X+11 . … 21 minutes : Mars receives the first block Block X+1 from Earth and discards it, because Mars found Block X+20 at 20 minutes. Earth is at Block X+21 , and received Block X+10 last from Mars. … 61 minutes : Mars receives Block X+41 from Earth, Mars is at Block X+40 . Earth's chain's total proof of work is greater than Mars' chain's. Mars' chain is discarded in favor for Earth's. Mars' miners lose the mining reward of the last 40 blocks. Earth is at Block X+61 . Conclusion: Neither distance, nor block interval are sufficiently prohibitive. As long as the other planet has more mining power it will eventually overtake the local blockchain. Addendum: Short block interval with checkpoints at low depth When I just read this question again, I thought of another thing. If one was hellbent to keep non-martian mining efforts from bearing fruits, one could introduce a sliding checkpoint scheme. In my above example, where I was prescribing a block interval of two minutes and terrestrian mining was twice as fast as martian mining, it would take a reorganization of more than forty blocks for the terrestrian chain to replace the martian. If the community of Mars agreed upon forbidding chain reorganizations of more than 15 blocks (which at two minute intervals is less time than that of a radio wave roundtrip) by adding every block with 15 confirmations to the checkpoint list, terrestrian miners would be able to fork themselves from the Marscoin chain, but would never be able to take over the martian mining."
    ]
  },
  {
    "question": "What is the average size of a bitcoin transaction?I'm curious, since the inception of bitcoin, what is the average size (in bytes) of a bitcoin transaction? To be clear, the easiest way to find this is not to take the size of the block-chain and divide it by the total number of transactions. This is because there is a little overhead associated with block headers. Transactions need to be accounted for one at a time for this averaging operation. Has anyone taken the time to analyze this information and, if so, what were the results? To be clear, I am interested in this answer as the data is stored in uncompressed-bytes. I'm not interested in any textual (i.e. JSON) variation which might be used for network communication.",
    "answers": [
      "Just to give a few exact numbers, the current average transaction size (of all existing transactions until block height 498920) is 522.45 bytes. If we take into account just the first 100000 blocks, then the average transaction size was indeed 238.51 bytes. This is a plot of the average transaction size (aggregated monthly): The peak on mid 2015 is produced by this 999657-bytes transaction . These values can be computed using BlockSci .",
      "Quote from Gavin Andresen: the average Bitcoin transaction is about 250 bytes big https://bitcointalk.org/index.php?topic=813324.0 (2nd post, last sentence)"
    ]
  },
  {
    "question": "Is Ripple centralized or decentralized?Are people still fighting about this or have they come to a consensus? Also, as of today (Sep 2015), what is the main advantage of Ripple over Bitcoin?",
    "answers": [
      "According to Ripple: Ripple for Financial Institutions Financial institutions, network operators and regulators play critical roles scaling and providing stability to payment systems. Ripple enhances the existing payment stack, offering real-time settlement infrastructure at the foundation.\" https://ripple.com/integrate/ Given that financial institutions, network operators and especially \"regulators\" are part of this equation then in this instance of \"Financial Institutions\" when considering the totality of human involvement it perhaps could not be considered decentralized, which in the context described makes it centralized. Ripple also states \"Jurisdiction or network specific rules, governance, standards, and other critical functions are intended to be provided by existing systems and operators.\" With respect to your second question Ripple is a system for exchanging the Internet of Value (many different assets digital and physical) in which they also offer their own XRP digital \"currency\", whereas Bitcoin is simply another digital currency.",
      "I think this is pretty accurate about Ripple. They are more centralized because of all the regulations they are complying with in order to combat anti money laundering and other know your customer type of compliance. Also, if you look at their advisory board it is composed of many in previous government positions and this will contribute to their centralized aspect of work. Big companies that play by Wall Street rules and are in bed with government to some extent are also within some of the investors of this new institutional digital currency. But even with this Ripple will bring much benefit to average consumers as well and not just the big players."
    ]
  },
  {
    "question": "How to sign a transaction with multiple inputs?I have been able to program an application in python that sends valid transactions that spend 1 input, but I really can't get it to work with 2 or more inputs. So my question is, how exactly is the hash that has to be signed for each input calculated? What I have been doing so far, is, for example, if we have 2 inputs, we generate a transaction that spends only that first input, and thats the hash that has to be signed for the first input. And the same with the second input, we generate a transaction that only spends that second input. Both transactions need to have the same outputs. Is that correct? For example, we want to spend input aaaa:0 and input bbbb:1 and we want to send them to some address: To calculate the hash that the first input has to sign, we need to generate this transaction: 'version': 1, 'inputs': (1) 'output_tx_hash': 'aaaa', 'output_position': 0, 'script': the original script, like: '76a914' + hash + '88ac', 'sequence': ffffffff, 'outputs': (1) 'value' : 100000 'script' : '76a914' + hash of btc pub key + '88ac' 'locktime': 0 And to calculate the hash that the second input has to sign: 'version': 1, 'inputs': (1) 'output_tx_hash': 'bbbb', # this changes 'output_position': 1, # this changes 'script': the original script, like: '76a914' + hash + '88ac', 'sequence': ffffffff, 'outputs': (1) 'value' : 100000 'script' : '76a914' + hash of btc pub key + '88ac' 'locktime': 0 We serialize them, add them 01000000 (SIGHASH_ALL), double sha256 that, sign it, and add 01. That way we get the two signatures that we will use on each input respectively. My application does exactly that and doesn't work. What am I missing?",
    "answers": [
      "I found the way to do it, so, if anyone is interested, here is how to do it: When you have more than 1 input, you don't have to remove the inputs that you are not going to sign, you have to remove only their scripts . So, if you want to sign the transaction posted in the question, the first hash would be calculated like so: 'version': 1, 'inputs': (2) { 'output_tx_hash': 'aaaa', 'output_position': 0, 'script': the original script, like: '76a914' + hash + '88ac', 'sequence': ffffffff, }, { 'output_tx_hash': 'bbbb', 'output_position': 1, 'script': '', # Nothing 'sequence': ffffffff, } 'outputs': (1) 'value' : 100000 'script' : '76a914' + hash of btc pub key + '88ac' 'locktime': 0 And the second hash: 'version': 1, 'inputs': (2) { 'output_tx_hash': 'aaaa', 'output_position': 0, 'script': '', # Nothing 'sequence': ffffffff, }, { 'output_tx_hash': 'bbbb', 'output_position': 1, 'script': the original script, like: '76a914' + hash + '88ac', 'sequence': ffffffff, } 'outputs': (1) 'value' : 100000 'script' : '76a914' + hash of btc pub key + '88ac' 'locktime': 0 Hope it helps anyone.",
      "It worked for me too. You just have to 1) Compose signable for the first input, with zero length string as script for all inputs besides the one that is signed 2) Sign the first input with der encoding of signed signable from 1. 3) Have the same operation on every input"
    ]
  },
  {
    "question": "What is \"segregated witness\" and how can it improve network scalability?I've just heard about it, and it is claimed to be a \"turning point\" in the block-size debate. What is \" segregated witness ?\" how does it work? How can it be used for improving network scalability? Is this the answer to all of network's scalability concerns?",
    "answers": [
      "It's not a silver bullet solution, but it's a really good start. As Gavin Andresen has said, Segregated Witness is a poor name. The 'segregated' part of the name is there to denote that there is separation being done. The 'witness' portion of the name comes from the fact that digital signatures are often time called witnesses. Segregated witness splits up transactions into different parts that can be handled separately instead of the single chunk of data as they are now. Specifically, it takes the digital signatures out of transactions and puts them in a separate merkle tree that has the same structure as the transaction merkle tree. So, if fully implemented, to check that an input legally spends its previous output, you would get the signature from the signature tree, instead of the standard scriptSig field. These are a few of the benefits of this idea: Since signature data (witness data) is stored outside the transaction (and outside the standard block), it means that that data doesn't have to be counted towards the block size. Pieter Wuille is proposing a 75% discount on space taken up by signature data, meaning that you can fit 4x as much signature data into blocks. This effectively results in a soft fork increase to the block size. Completely solves malleability issues. Using transactions with the signature data outside the transaction means that TXIDs don't hash the signature data, which means that they're not malleable (assuming you're using the standard SIGHASH flag). Technically, the signatures are still malleable, it's just that modifying them doesn't invalidate chains of transactions because the signatures don't sign the modifiable parts. Allows for a slow upgrade. Software has to opt in to using Segregated Witness after it has been fully deployed to the network, but in the meantime (and afterward) transactions can still be made as usual without segregated witness. All future Script updates become soft forks. When segregated witness gets fully implemented, it will have a version byte in outputs for what version of Script it is using. And the behaviour for clients that see a script with a non recognized version number is that they treat it as an 'anyone can spend' output. Signatures only prove that a transaction is authorized, it doesn't describe where funds are going or where they came from. So, after they're checked they can be discarded. Putting the signatures in a separate data structure makes it much easier to prune that data, which results in much less blockchain data needing to be stored on your hard drive. However, this doesn't completely increase the block size, it just increases the amount of signature data that a block can store. Since transactions are roughly 60% made up of signature data, this is still a pretty big gain. The downside is that it's a non-trivial upgrade for the network to start using segregated witness. The transaction serialization format is different, and code everywhere that makes bitcoin transactions needs to be updated. Since it's an opt-in process, though, upgrading can be done slowly over time. You can watch Pieter Wuille's great talk on Segregated Witness at: https://www.youtube.com/watch?v=fst1IK_mrng&feature=youtu.be&t=37m12s ."
    ]
  },
  {
    "question": "What security weaknesses result from using off chain solutions?What type of security weaknesses are potentially created by using off chain solutions (such as the lightning network) for a portion of Bitcoin network traffic?",
    "answers": [
      "TL;DR: The security assumptions of using a LN channel for payments: The blockchain is functioning well (confirming transactions quickly) Channel nodes can keep secret data safe There aren't any significant bugs in the software With the Lightning network specifically, the security of the off-chain payment always depends on being able to take the transaction onto the real blockchain \"if needed\". When both parties cooperate, the number of on-chain transactions is minimized, but both parties rely on being able to cash out, using the real blockchain, if the other party stops cooperating or goes offline for an extended period of time. In addition, if the other party acts maliciously, you rely on being able to use the blockchain to punish their malicious actions. One security risk lies here: if you cannot get transactions confirmed into the blockchain, you won't be able to get your money out of the channel, or to take counter measures when the other party tries to cheat you! So a well-functioning blockchain (confirming transactions quickly) is a definitely one security assumption of using the lightning network. So block crowding is one risk, since there won't be enough room for your transactions. Miners could also be bribed to not mine your transactions, although this is not a severe risk since it is likely that a different miner would confirm your transaction. To understand some of the other security assumptions used in the lightning network, consider the following example. Suppose Alice has a payment channel open with Bob. First the channel balances read: Channel Balance 1: Alice: 0.5 BTC Bob: 0.5 BTC Then Alice makes a payment to Bob for 0.1 BTC, and the updated channel balances read: Channel Balance 2: Alice: 0.4 BTC Bob: 0.6 BTC But Alice decides she wants to try to cheat Bob! She tries to broadcast the transaction for Channel Balance 1 , in which she gets 0.5 BTC, which is more favorable to her than her balance in Channel Balance 2 , just 0.4 BTC. What's to stop her from doing this? First, there is a waiting period before she can actually spend the funds from her 0.5 BTC output in Channel Balance 1 (technically the wait period applies to Channel Balance 2 as well). This wait period exists to give Bob sufficient time to notice that Alice has closed out the channel, and possibly take action if Alice has broadcasted an old version of the channel. In this case, since Alice closed out the channel with an older version of the channel state, Bob can actually take all of the funds in Alice's 0.5 BTC output! Hence, Alice is disincentivized from broadcasting old versions of the channel state. The problem is that if Bob can't get his transaction that took the 0.5 BTC from Alice into the blockchain, then the wait period will end and Alice will have the opportunity to take the 0.5 BTC, successfully stealing 0.1 BTC (because she should only be allowed to take 0.4). So Bob depends on being able to take counter measures against Alice in the real blockchain before a wait period ends if Alice tries to broadcast an older version of the channel state. (Note that this wait period also applies to Bob if he needs to get funds out of the channel without the help of Alice. Even if he broadcasts the most recent state of the channel, he has to wait. While this wait period may be inconvenient for Bob, Alice also has to abide by the wait period, which is what gives Bob a chance to take all of the funds in the channel if Alice tries to broadcast an old version of the channel. If things go as planned, though, and no one goes offline, then Alice and Bob can agree to make a new transaction to close the channel, where neither one has to wait to spend their funds.) There is also a data security risk. Proving to the other channel party that you will not try to broadcast previous versions of the channel balance state involves giving the other channel party a bit of secret information, typically the preimage of a hash. Usually you only reveal this data to your channel counter-party when you update the state of the channel and receive a new guarantee of payment (just with a different balance). After you receive the new payment, you can reveal the secret information that invalidates the previous payment by giving them the ability to steal the funds from that old channel state if you try to broadcast it. But if the secret data associated with the current state of the channel is revealed or stolen before you get a separate payment guarantee transaction, then effectively all of your transactions have been revoked and your channel counter-party can steal all the funds from any channel transaction you broadcast! So, the security of a LN payment channel depends on being able to keep data safe. Another risk is simply bugs in software. If your software doesn't automatically handle all the edge cases of broadcasting the right transaction at the right time, and your counter party discovers that, they can take advantage of it and steal funds from the channel.",
      "I think one of the biggest risks is that there could exist an issue with the two way pegging mechanism. Such a failure could introduce issues where perhaps coins are unable to be retrieved from the sidechain and returned to the bitcoin blockchain. There is also the risk of an unknown network attack on the lightning network, perhaps a ddos attack against validator nodes that would render transactions unable to be processed on the off chain network. There could be others as well."
    ]
  },
  {
    "question": "Check status of daemon?I have started bitcoind on my linux box. How can I ask it what its status is? I assume it is downloading the blockchain and will continue to do so for hours or days. How can I find out where it is in this process?",
    "answers": [
      "I found the easiest way to do this (version 0.12) is to issue the command (not case sensitive): bitcoin-cli getblockchaininfo Then, compare the blocks received field, to the headers field. The blocks received should increase steadily until it matches the headers field, at which point the client is synced. Once the client is synced you can check if the client is accepting inbound transactions by issuing the command: bitcoin-cli getconnectioncount If you have 0 connections, something is wrong. If you have 8 connections, then it means you are only doing outbound connections (which might be the case if you just want to use your client to execute your own personal transactions, not verify everyone else's). If you have more than 8 connections, then it means you are accepting inbound connections and are acting as a full node (good for you). Two additional ways to get information about your node is to use GetNetTotals which returns information about network traffic, including bytes in, bytes out, and the current time, and GetNetworkInfo which provides information about your connections to other nodes.",
      "You can also just tail the debug.log file in a new terminal window while bitcoind is running. It shows current block height i.e. height=181888 and percentage of download complete i.e. progress=68.189662 and keeps running in the window, so you see the progress. On Linux: tail -f ~/.bitcoin/debug.log On Mac: tail -f $HOME/Library/Application\\ Support/Bitcoin/debug.log"
    ]
  },
  {
    "question": "How to change the data directory with bitcoin-cli?I am trying to change the data directory used by bitcoind and I am uder the impression that the command -datadir was removed as I can't find it with bitcoin-cli help , when I try to use it I get Too few parameters and bitcoin-cli help datadir says datadir doesn't exist. I need to specify a directory that is not on the root partition, how to do it ? Also why bitcoin core is so user unfriendly, it's quite surprising I thought it was the main bitcoin program. It started downloading the blockchain on my root partition without me even being aware of it (just start bitcoind and it starts silently downloading).",
    "answers": [
      "you should use it like this bitcoin bitcoind -datadir=/your/external/path Hope this helps!",
      "If you would like to do this permanently create a ~/.bitcoin/bitcoin.conf file and include: datadir=/your/path"
    ]
  },
  {
    "question": "Why does each block store a Merkle root?I understand how a Merkle root is calculated and stored in the block. But how do miners verify a transaction using the Merkle root? Here are 18 conditions that verify a transaction. None of them uses Merkle root.",
    "answers": [
      "Merkle roots do not verify transactions, they verify a set of transactions. Transaction ID's are hashes of the transaction, and the Merkle tree is constructed from these hashes. It means that if a single detail in any of the transactions changes, so does the Merkle root. It also means that if the exact same transactions are listed in a different order, the Merkle root will also change. So the Merkle root is cryptographic proof of which transactions are in the block, and which order they are in. It provides a convenient piece of information to be included in the block header which is then hashed and included in the next block header. Without the Merkle root in the block header, we would have no cryptographic proof of which transactions are included in a block, nor proof that their contents haven't been tampered with. Using a Merkle tree is preferable over a hash chain or a hash of concatenated transactions because it allows for a much quicker and simpler test of whether a particular transaction is included in the set. For more details, see the section on Merkle trees in the Developer's Guide .",
      "Merkle roots are stored in Bitcoin block headers so as to enable efficient membership proofs for transactions in a block, which are necessary for Simple Verified Payment verification (SPV) nodes that only store block headers and not block contents. It is misleading to say that \"Without the Merkle root in the block header, we would have no cryptographic proof of which transactions are included in a block, nor proof that their contents haven't been tampered with.\" We can always just hash-chain transactions together and store a hash-chain root in the block header, for example. (Or, we can just concatenate all TXIDs together and store that hash in the header.) However, that would not be as efficient: membership proofs with respect to a hash chain are O(n) when there are n transactions in the chain, versus O(\\log{n}) proofs w.r.t. a Merkle tree. Much later edit: I suppose no one actually answered your question: \"But how do miners verify a transaction using the Merkle root?\" . As I understand your question, the answer is they don't use the Merkle tree. Miners, just like full nodes on the P2P network, receive new transactions from other full nodes and verify them by checking their digital signature and that they spend valid coins (pretty much as described in your link). Merkle trees are not involved at this point. Later on, the miner takes all the verified transactions and creates a Merkle tree on top of them. As more transactions come to the miner, the miner verifies them and adds them to the Merkle tree. Why are things added to the Merkle tree by the miner? Again, as I describe above, the only reason we have Merkle trees is so SPV nodes can efficiently verify that miners verified the transactions in the block. There is one scenario one might describe as \"miners verify a transaction using the Merkle root\" though I wouldn't use that phrasing: When a miner hears about a new block, it will want to verify its validity (recall that miners don't want to extend an invalid chain). As part of the verification, the miner needs to make sure that the Merkle tree was correctly computed over the TXIDs. However, this does not imply transactions were verified: the miner still has to verify transactions individually as described in your link. One consequence of this verification is SPV security for free : When an SPV node sees a Merkle membership proof for a transaction, they can assume it's valid (because SPV nodes assume miners verify blocks)."
    ]
  },
  {
    "question": "Anyone know of an API I can get historical price time series for multiple coinsI'd like to build some historical price charts, to use in my cryptocoin portfolio tracking app , using time series data (with HighCharts js). Anyone know of an API that provides this price data, preferably for multiple coins (btc, ltc, eth, etc)?",
    "answers": [
      "I am developing the ccxt cryptocurrency trading library, check it out on GitHub: https://github.com/kroitor/ccxt It is a library for cryptocurrency trading and e-commerce with support for many bitcoin/ether/altcoin exchange markets and merchant APIs. With it you can access market data and trade bitcoin, ether and altcoins with more than 70 (!!!) cryptocurrency exchanges. It is used to connect and trade with crypto markets and payment processing services worldwide. It provides quick access to market data for storage, analysis, visualization, indicator development, trading strategy backtesting, bot programming, building trading algorithms on top of it, webshop integration and related software engineering. The codebase is in JavaScript / Python (2 and 3) / PHP. You can deploy it from PyPI, with npm (for Node.js) or by cloning the GitHub repository. The ccxt library is under heavy development right now, but already offers a quick-start for trading and technical analysis with many crypto exchange markets out of the box. It is intended to be used by coders, developers and financial analysts to build algotrading strategies on top of it.",
      "Found the data on crypto compare const endpoint = 'https://min-api.cryptocompare.com/data/histoday?aggregate=1&e=CCCAGG&extraParams=CryptoCompare&fsym='+ ticker.toUpperCase() +'&limit=365&tryConversion=false&tsym=' + currency.toUpperCase();"
    ]
  },
  {
    "question": "Which wallets support Bitcoin Cash?I'm looking for a big list of wallets that support Bitcoin Cash. What are the wallets that have Bitcoin Cash support?",
    "answers": [
      "If you don't want to read the whole list, and just want to choose a Bitcoin Cash wallet... (SPV = Simplified Payment Verification, does not depend on a server so it's a more decentralized.) Sorted by various things For PC/MAC Electron Cash (a.k.a Electrum for Bitcoin Cash) For Android CoPay (SPV) BTC.com UnitWallet (SPV) For iOS CoPay (SPV) Bitcoin.com (SPV) (updated rarely) BTC.com * CoPay uses a different address format. Not to be confused, please read this Major Full Nodes Bitcoin Unlimited Cash Edition One of the most used cash full node wallet softwares. It has XThin support that saves bandwith while downloading new blocks and uses Parallel Validation to validate blocks faster and safer. Website: www.bitcoinunlimited.info Download Cash Release: www.bitcoinunlimited.info/download Bitcoin ABC First Bitcoin Cash full node wallet software. The most popular Bitcoin Cash node as it's the first. Website: bitcoinabc.org Download: download.bitcoinabc.org Bitcoin XT First Bitcoin scaling software - first version released in 8/2015. It supports XThin, and it supports XThin's alternative Compact Blocks too - making it (theoretically) faster and bandwidth-cheaper while downloading new blocks than other clients. It's the least used Bitcoin Cash full node, for no reason. Website: bitcoinxt.software Download: https://github.com/bitcoinxt/bitcoinxt/releases/latest If you want to run one of the full-nodes but don't want to store the blockchain (140 GB) You can use pruning , by pruning you can choose how much space allocate to these full node softwares. It supports both Bitcoin and Bitcoin Cash. Other Major/Semi Major Wallets Electron Cash (lightweight wallet) The only major talented lightweight wallet - doesn't store the entire blockchain on your computer. It's a changed version of Electrum, one of the most used Bitcoin wallets. Website & Download: electroncash.org WARNING: There are fake Electron Cash wallets that steal your money. It is safe if and only if you're downloading it from www.electroncash.org ! BTC.com Wallet (online wallet - mobile) The most used online wallet Bitcoin Cash & one of the best mobile Bitcoin Cash wallets Use it here: bcc-wallet.btc.com Google Play: https://play.google.com/store/apps/details?id=com.blocktrail.mywallet App Store: https://itunes.apple.com/us/app/btc-com-bitcoin-wallet/id1019614423 Blockchain.info (online - mobile) One of the major online wallets (most used?) that completely supports Bitcoin Cash. https://cointelegraph.com/news/blockchaininfo-releases-full-bitcoin-cash-support-users-receive-coins Note : that for anyone opening a new wallet or for anyone who didn't have BTC before 1st August in their wallet, you cannot use it for storing BCH. https://support.blockchain.com/hc/en-us/articles/115005180866-Can-I-use-bitcoin-cash-BCH-in-a-new-or-existing-wallet- Coinbase (online - mobile)* One of the major online wallets. They are going to add option to withdraw all of your Bitcoin Cash on 1 January 2018. Announcement: https://support.coinbase.com/customer/portal/articles/2853600-bitcoin-cash---frequently-asked-questions Bread [former name: Breadwallet] (mobile) Breadwallet is the safest iOS Bitcoin wallet with Bitcoin Cash one-time-withdrawal support. It doesn't use a server, instead it connects to three peers, making it more decentralized. There is a rumour that they are going to add an option to switch to Bitcoin Cash and use it like the normal Bitcoin wallet. [noref] Announcement: https://breadwallet.com/blog/breadwallet-plan-bitcoin-cash-bch/ CoPay - BitPay (mobile - lightweight - Chrome extension - desktop) Bitcoin Cash full support has been released, but it uses a new address format . Announcement: https://blog.bitpay.com/bitcoin-cash-wallet/ Coinomi (mobile) Coinomi is one of the most known Bitcoin Cash wallets (actually it supports over 70 cryptocurrencies), however it may not be a good idea to have more than 50$, as it went closed source last year . Their developers say on its website that the private keys don't leave your device. Android: https://play.google.com/store/apps/details?id=com.coinomi.wallet iOS: Coming in future Armory One of the good Bitcoin software. Allows you to withdraw BCC (BCH, Bcash on Armory). You should read instructions below. If further hard forks happen on BCC, its developers won't update Armory to be compatible with it. ( Source ) Instructions: https://bitcointalk.org/index.php?topic=2070058.0 Mycelium Actually Mycelium can't do anything about your Bitcoin Cash, but you can use BTC.com's tool to claim it https://blog.btc.com/how-to-recover-your-trapped-bitcoin-cash-from-other-wallets-24b929543f26 Or you can claim it using Coinomi https://steemit.com/btc/@libert/step-by-step-guide-on-claiming-bitcoincash-from-mycellium-wallet-201783t112141477z Bitcoin.com wallet (mobile - desktop - Chrome extension) A good option as a wallet. It's changed version of CoPay that fully supports Bitcoin Cash and runs on Windows, Mac, Linux, iOS, Android. Download: www.bitcoin.com/choose-your-wallet/bitcoin-com-wallet Jaxx (mobile, Chrome extension) Jaxx has full Bitcoin Cash support (Android and Chrome extension). Announcement: https://www.reddit.com/r/btc/comments/7bu6yo/jaxxio_now_supports_bitcoin_cash/ TSBW (online) It's an open source wallet that can be used without opening an account. The easiest software to use with paper wallets. WARNING: Developer accused of stealing funds. More info 1 More info 2 Bitcoin Cash: https://tsbw.io/bcc/ BitcoinCashTribe (online) Works similar to TSBW. Website: https://bitcoincashtribe.com/index.php BitPie & Bither They have full Bitcoin Cash support. BitPie announcement: http://docs.bitpie.com/en/latest/bitpiebcc/index.html Bither announcement: http://docs.bitpie.com/en/latest/bitherbcc/index.html Exodus (lightweight) One of the popular wallets that support Bitcoin Cash 100%. Announcement: https://redd.it/766ojz Download: https://www.exodus.io/releases/ Xapo (mobile) You can withdraw all of your BCH at once before December 14th, or convert your BCH to BTC by one-click. Announcement: https://blog.xapo.com/time-to-convert-your-bitcoin-cash-bch/ BitGo (online - Chrome extension) BitGo supports Bitcoin Cash. Announcement: https://blog.bitgo.com/bch-availability-c252727ea1be StrongCoin (online) StrongCoin supports Bitcoin Cash. Announcement: https://strongcoin.com/blog/bitcoin_cash_is_now_supported_in_strongcoin_wallet Parity Bitcoin (full node + lightweight) Parity Bitcoin is a high performance wallet that can be run as a full node or a lightweight client. (Warning: Don't be confused with Parity! Parity Bitcoin is the Bitcoin/Bitcoin Cash version of Parity Ethereum client.) Announcement: https://blog.parity.io/parity-bitcoin-is-now-supporting-segwit-segwit2x-and-bitcoin-cash/ Bitcore (full node)* The 5.0 version which is coming soon, supports Bitcoin Cash if pointed to a Bitcoin Cash node. Doesn't have a user interface, not the best choice for a user. Useful APIs. (This is not a wallet for users! This is for developers!) Announcement: https://news.bitcoin.com/now-bitcore-nodes-can-switch-to-any-bitcoin-implementation-even-forks/ Bitcoin Cash wallet (by Chris Pacia) Changed version of OpenBazaar's SPVWallet for Bitcoin Cash. It has both GUI and command line support. Downloads (Windows & Linux): https://github.com/cpacia/BitcoinCash-Wallet/releases/latest Bitcoin Cash wallet (by HashEngineering) (Android) Changed version of Andreas Schildbach's Bitcoin Wallet for Bitcoin Cash. Announcement: https://www.reddit.com/r/btc/comments/72xost/beta_for_bitcoin_cash_wallet_for_android_recover/ StashWallet A new HD Android wallet that fully supports Bitcoin Cash. Website: https://stashcrypto.com Freewallet (mobile) A Bitcoin Cash Android wallet. WARNING: READ THIS Website: https://freewallet.org Google Play: https://play.google.com/store/apps/details?id=bcc.org.freewallet.app UnitWallet (mobile) One of the Bitcoin-Cash-only wallets, fork of bread[wallet]. Website: https://www.unitwallet.co Google Play: https://play.google.com/store/apps/details?id=com.unitwallet Hardware Wallets bitWallet (iOS) A new Bitcoin wallet with Bitcoin Cash and a few altcoins support. It's good to keep in mind that it's not open source. Website: http://www.sollico.com/bitwallet/ Download: https://itunes.apple.com/us/app/bitwallet/id777634714 Trezor One of the major hardware wallets. Allows you to claim your Bitcoin Cash (They call it Bcash) if it's updated to latest firmware (1.5.1+). Fully supports Bitcoin Cash. Trezor Guide: https://blog.trezor.io/claim-bcash-bitcoin-cash-bch-bcc-trezor-wallet-f0a810d5864a KeepKey One of the major hardware wallets + fully functioning Bitcoin Cash wallet. https://coingeek.com/keepkey-wallets-now-support-bitcoin-cash/ Ledger One of the major hardware wallets. Supports Bitcoin Cash if you update your firmware to latest version. Guide: http://support.ledgerwallet.com/knowledge_base/topics/bitcoin-cash Digital Bitbox Its firmware supports Bitcoin Cash, but the desktop client doesn't. You can claim your Bitcoin Cash by sending all of them to your Bitcoin Cash wallet. Cannot be used as a Bitcoin Cash hardware wallet. Guide: https://digitalbitbox.com/bitcoincash Paper Wallet The safest Bitcoin/Bitcoin Cash hardware wallet. You can claim your Bitcoin Cash by importing to a Bitcoin Cash software. You can create a paper wallet on cashaddress.org or bitaddress.org or bitcoin.com All Bitcoin paper wallets are compatible to Bitcoin Cash as they both use the same private keys/addresses. TODO: Add description: https://mobi.me https://www.wmtransfer.com/ https://bitcoin-india.org/ https://www.melis.io/ https://www.coin.space/ The wallets that don't support Bitcoin Cash aren't on the list. List is sorted by various things. *: Description will be updated."
    ]
  },
  {
    "question": "What is transaction replay and replay protection?With everyone and their dog making new blockchains forked from the bitcoin blockchain, there is a lot of talk about replay protection. What is a transaction replay? What does replay protection do?",
    "answers": [
      "What is a transaction replay In the context of forks, transaction replay is when a transaction is valid on both sides of the fork. So a transaction can be played (i.e. broadcast) on both chains after the fork and be a valid transaction and confirm. This means that if you intend on sending coins on one fork, you could accidentally end up sending your coins on the other fork as well since someone else could take your transaction and replay it (i.e. broadcast it) on the other chain's network. What does replay protection do? Replay protection is something that makes it so that transactions on one chain are invalid on the other chain thus preventing transaction replay. This can be anything from having a blacklisted address or output type (e.g. if an output to address X is in the transaction, consider it invalid) to changing the signature scheme to changing the transaction format entirely. All this does it makes replaying some or all transactions impossible."
    ]
  },
  {
    "question": "How can government \"seize\" bitcoins?Last year the U.S. Department of Justice posted this press release claiming U.S. \"law enforcement seized several thousand Bitcoins on November 3, 2020.\" How is it possible for anyone to \"seize\" BTC? My understanding is that it is technically impossible to transfer BTC without the private key for the wallet holding BTC. And likewise that anyone with the private key can transfer the BTC if they can transmit the transaction. I.e., short of coercing whoever has the private key to disclose it, is it true that no amount of force or authority can cause or prevent the transfer of any particular BTC? Or am I missing something?",
    "answers": [
      "It is not necessarily true that no amount of force or authority can cause or prevent any transfer of Bitcoin. The protocol does not allow arbitrary seizures or blocking, but there are still human factors involved. Bitcoin is decentralized, so there is no central authority that governments can go to (or coerce) to force or disallow transactions. However Bitcoin is still owned by people, and people can be forced to perform certain actions that they do not necessarily want to do. While a government cannot command the Bitcoin network to make a transaction to happen, they can go to a particular individual who owns Bitcoin and coerce them to make a transaction Furthermore, governments often have the power to arbitrarily seize assets owned by people. They can do this by force and physically taking things away. This is often how Bitcoin is seized - the hardware that contains the private keys is physically taken by the government. Once they have access to the private keys, the government can perform any transactions that they wish. There is nothing that Bitcoin can do to prevent this; it is up to the individual to ensure the security of their private keys. For disallowing transactions, this is much harder. However, as before, there is still a human factor involved. In this case, it's miners who produce blocks. A government could mandate that miners operating in their jurisdiction are not allowed to create blocks containing certain transactions. If all miners were to follow such mandates, then a transaction could remain unconfirmed indefinitely and thus be effectively disallowed. However this is much harder to do. The decentralized nature of mining means that miners who are in other jurisdictions that do not require censoring certain transactions can mine those transactions. Furthermore, miners who can protect their anonymity and are willing to break some laws can mine those censored transactions too. Even if no current miner is willing to mine a censored transaction because their governments threaten them, more people could simply begin to mine who do not necessarily follow the same censorship requirements. Mining being decentralized allows anyone to be a miner, albeit at a high initial cost currently. Governments could also try to snuff out the non-censoring miners through force, possibly through seizure or destruction of mining hardware. But even so, people will still be able to mine, and there will inevitably be some miner out there who is willing to make a block that includes a transaction censored by every other miner. So in the end, it really is not possible to disallow a transaction.",
      "A lot of bitcoins reside in a trading platforms or online wallets. These bitcoins are (in the particular bitcoin sense) controlled by the platform. The government (provided the platform/wallet is in a favorable jurisdiction) may simply issue an order that requests the funds to be blocked or transferred to a government-controlled account. The ordinary bank accounts are seized in the same manner. In a lot of other cases there is a hardware / storage / printed paper containing the key that the government puts its hands on. The funds are quickly moved to a government-controlled wallet in order to prevent the previous owner transferring them elsewhere using another copy of the key. p.s. I know of at least one government that obtained the keys and failed to move the funds in a timely manner. The funds disappeared."
    ]
  },
  {
    "question": "Can I use Bitcoin to permanently prove that \"there exists a file with content at this point of time\"?I have some files (e.g. of 10MB in size, think of it as a paper, an article, a photo, etc), and want to permanently prove that \"at 2022.05.24, I already come up with such a file with such content\". So, is it possible to be done via bitcoin? My very naive thought is that, transferring some bitcoin with \"attachment\" being the hash of my file. Then, since this money transfer record is permanently unmodifiable and visible to everyone, I prove that I have it at this time. In addition, can this be evidence in, for example, courts? I am new to blockchain/bitcoin so I am not sure whether this thought is reasonable or not. Thanks for any suggestions!",
    "answers": [
      "Embedding arbitrary data in the Bitcoin blockchain is possible with the use of an OP_RETURN output. If you embed a hash of your file this way, it will prove its existence at that point in time, for as long as Bitcoin exists and its timestamps can be trusted. Note that block timestamps in Bitcoin can theoretically be up to 2 hours different from real time. However, embedding a hash of a single file in a transaction is wasteful. Using a merkle tree, you can timestamp thousands or millions of files at the same time, and still use only one transaction. The OpenTimestamps project creates an open standard for exactly that and lists several so-called \"calendar servers\" that allow you to create a trusted timestamp for free (they rely on donations to cover transaction fees and other expenses). Example OpenTimestamps transaction: f1127bd52c1fe4894134379403f4dc7287018fc4f1361c3ce01a554ae6995f9c",
      "Yes, it is possible today. Have a look to https://originstamp.com/ - this service already performs it. I do not recommend you to upload your files to this site, but you will find more information there, rather in my answer"
    ]
  },
  {
    "question": "How can P2Pool charge a fee?P2Pool is an open source peer to peer mining pool. It currently charges a fee of 0.5%. Is it possible to just fork P2Pool protocol and eliminate the fee? Has this been done? If so, how can P2Pool still retain users when a cheaper alternative remains? If this hasn't been done yet, why not?",
    "answers": [
      "Since November 17, 2011 no fee is charged. Instead an optional donation of 0.5% is sent to the author of P2Pool to support future development. If you don't want to donate to the author you can run P2Pool like this: python2 run_p2pool.py --give-author 0.0 [USERNAME] [PASSWORD] The 0.0 is a percentage of your earnings and can be set to whatever percentage you like.",
      "You may split the project and create your own distributed pool, but you choose to reap no rewards from doing so (the first 0.5% fee), and without a bonus to the block finder (the other 0.5% fee). The pool combines both fair share rewards and a finder's bonus to compete against other pools. The initiator has so far earned 0.75 BTC for his development and promotion efforts. If you feel this is too much for a system that eliminates centralized downtime (connectivity and stale issues) and centralized trust (delayed payments, locked funds) you should not use this pool. An added benefit of p2pool is that all addresses receive funds from the generation transaction directly to their public key. This means until you spend those funds your funds are completely anonymous and untraceable."
    ]
  },
  {
    "question": "IPv6 support statusWhat is the current status of IPv6 support? From what I gathered reading the Wiki , protocol specifications support IPv6, but the original client does not. However, I also came across the description of Bitcoins.lc, who claim \"full IPv6 support\".",
    "answers": [
      "The standard Bitcoin client does not at this time support IPv6. Bitcoins.lc is a mining pool, and mining pools work by having an interface (such as PushPool) visible to the public which handles all the getwork stuff and various internals, miner tracking etc. This interface operates as a proxy to the actual bitcoin client and so the client itself can bind to an IPv4 address which is local relative to the mining interface which can have full IPv6 support. In short, it is not the bitcoin client which bitcoins.lc is claiming IPv6 support for, but the proxy to which pooled miners connect. Edit: It looks like sipa has submitted the necessary code . According to TheBlueMatt , there is \"some alternate connection logic and anti-DDoS stuff wrt filling addr.dat on IRC\" that needs to be done first. In any case the code is out there so it shouldn't be long now until it finds its way into the official client. Update: IPv6 support was merged into the mainstream client and should be available in the 0.7.0 build."
    ]
  },
  {
    "question": "What are the risks of exchanging Bitcoins via Near Field Communication?What are the risks of exchanging Bitcoins via Near Field Communication? The transaction Parameters might be negotiated via NFC and the actual transaction via Internet.",
    "answers": [
      "The risks could be, someone else with a good NFC communicator could intercept your request and make you send some BTC to them, having another persons phone next to yours with the app can do the same, and possibly NFC jammers can really cause a lot of problems with the transfer."
    ]
  },
  {
    "question": "Will the amount of electricity used for mining be huge if Bitcoin is widely adopted?A quick and very rough estimation: If the USD/BTC exchange rate grows to $1000/BTC (not that far-fetched if Bitcoin is actually widely adopted) bitcoins for a value of $300000 would be produced every hour, given the current rate of 50BTC each 10 minutes. This should mean that the amount of money spent on mining is roughly the same, $300000/hour. Given an electricy price of $0.01/kWh that means that 3GW, i.e. a rather large power plant, would be used solely for mining. Is there anything fundamentally wrong about the above calculation? Is it a problem?",
    "answers": [
      "This is a very difficult prediction to make, but there is one factor often left out of mining cost estimations: cost of hardware. When amortized over their expected lifespans, the costs of various pieces of equipment can become a meaningfully large factor in Bitcoin mining costs. In the days to come, it seems likely that FPGA or ASIC miners will become more common since they offer tremendous power efficiency gains over GPUs. The \"downside\" to FPGA and ASIC mining is that it is also extremely expensive to obtain the initial equipment, which means that the cost of equipment amortized over its expected lifespan is higher than with GPU mining. We're now seeing the first commercially available FPGA mining rigs become available, costing about $440 for a 100 MH/s rig consuming 6.8 watts of electricity. Here at my home in Las Vegas, NV it would cost about 55 cents per month to run one of these FPGA boards, and even if the device survived 10 years of operation before its death, amortized hardware cost would be $3.67 per month, absolutely dwarfing energy costs. The ATI Radeon HD 5830 based rigs I currently run cost about $6.58 per 100 MH/s in electricity alone, but a 10-year amortization only adds $0.96 per month per 100 MH/s to that cost. This means the buy-in for GPU mining is low but so is the profit and sustainability. This puts my cost per coin for FPGAs at $2.45 and for GPUs at $7.54, though there is certainly room for improvement in those numbers and your mileage WILL vary. The important bit, however, is that FPGA mining is far more profitable regardless of hardware cost and is likely to be the next big thing, which does a lot for Bitcoin's overall energy footprint since FPGA mining consumes about 8% of the electricity GPU mining currently consumes. If FPGA mining took over right now, the Bitcoin network could grow to 12 times its current hash rate without seeing a net increase in energy consumption. In short, Bitcoin is in its infancy still and so is mining. Just as most technologies begin at low efficiency and high cost and grow towards high efficiency and low costs, so too is Bitcoin mining. You are correct in your assumption that electricity use will likely grow with Bitcoin adoption, but the missing factor in that equation is the increasing energy efficiency of mining hardware.",
      "Electricity is not the only cost associated with mining. But basically, that's about what we expect. Likely mining will always be just barely profitable with the most cost-effective hardware and the lowest prices for electricity. If it's much more profitable than that, more people will mine, raising the difficulty, and thus reducing the profitability. On the bright side, the block payout will start dropping in 2013 or so. Every time the block payout drops, we would expect to see a decrease in mining."
    ]
  },
  {
    "question": "What can xxxCoin do to stop the impending 51% attack?Within the coming weeks both Namecoin and SolidCoin have been threatened with the same attack. What can be done by the users, pool operators and developers of these forks to either; A. Minimise damage. B. Stop it altogether.",
    "answers": [
      "There are two basic fronts on which they can defend, and they really do have to do both. First, they need to increase their total hashing power. 51% of a very large number is much harder for an attacker to muster than 51% of a small number. Merged mining is probably the most realistic way for these currencies to accomplish this. Second, they need to fix specific vulnerabilities in their difficulty adjusting algorithms. Some of these attacks requires less than 51% of the hashing power or do more damage than they should because of specific weaknesses in the difficulty-adjusting algorithm. Alternative currencies are vulnerable to hash rate decrease attacks. To resist them, they've adjusted their difficulty algorithms so that difficulty can drop rapidly. Unfortunately, these algorithms have been found to have unexpected defects. Because strict timestamp accuracy can't be enforced , an attacker can maliciously inject false timestamps into mined blocks to cause the difficulty to drop very, very quickly. This allows a malicious group of coordinated miners to extract a very large number of coins in a very small period of time with relatively little hashing power. Effort will be needed to fix these algorithms so that they still provide protection against a hash rate decrease attack but don't create even more serious new vulnerabilities. It may well be a rocky road these next few weeks. The 51% attack is fundamental to the decentralized nature of these currencies -- the only solution is more hashing power. But the difficulty algorithm attack issues will likely be solved by fixing the algorithms.",
      "The Bitcoin network is currently the worlds fastest distributed computing network. It gains security through size. The large pool issue is real however it can be overcome without flawed centrally controled digital currencies. One example is p2pool. It is a pool where miners share rewards but each miner independently generates their own block header including only valid transactions. https://en.bitcoin.it/wiki/P2Pool The only risk that large pools represent is the fact that currently miners are \"dumb\". The pool generates header and submit the merkle tree hash to the miner which \"blindly\" hashes it. If the pool has nefarious goals it can use the miner's hashing power against the network. Now it is unlikely this would happen because large pools have a vested interest in keeping the network and thus coins valuable and continuing their existance. Still the network would be improved if the miner generates the header rather than the pool. Now p2pool is a completely decentralized mining pool. They don't even have a website. Miners simply join the peer to peer network and are compensated for their work. Still many miners may like the advantages of a more traditional pool. This doesn't mean the header generation can't be distributed. Using algorithms implemented in p2pool a traditional pool could decentralize the header generation. With decentralized header generation each miner is working indendepdently. The purpose of the pool is merely to reduce volatility. This would complete eliminate the small risk of a pool operator using miner's to work against the network. Bitcoin users who are concerned about the influence of large pools and the risk that centralized header generation represent should either use p2pool or push for other pools to adopt a distributed block generation mechanism similar to p2pool. If blocker header generation is decentralized then there is no risk of subversion even if a single pool has 100% of hashing power."
    ]
  },
  {
    "question": "How to code the Simplest BitCoin CPU Miner?How would I go about making the simplest form of a CPU bitcoin miner? I have not been able to find documentation on the whole process...",
    "answers": [
      "If you're fluent in Python, there is a reference RPC miner, written by one of bitcoin's developers: https://github.com/jgarzik/pyminer",
      "Here, a nice explanation (even if the post is old) http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html"
    ]
  },
  {
    "question": "Is there a way to initiate a payment request in bitcoin?I'm writing a recurring billing system and I want to be able to contact a customer and request a certain amount of money. Is this possible via bitcoin? If not, could a URL be provided the customer so he can simply click it and it opens the bitcoin app and initiates a payment process?",
    "answers": [
      "You can now use the Bitcoin payment protocol to do this. Here is an easy to use implementation from Bitpay . There are already a few wallets that support this (including the reference client). More will be released soon. See: BIP 70 BIP 71 BIP 72 BIP 73",
      "There is no way to send messages within the Bitcoin system, and there is no URL link in the Bitcoin client yet. Generally, what you do is provide the customer a Bitcoin payment address and an amount either in the web page, by email, or by some other method."
    ]
  },
  {
    "question": "Is there a way to automatically send bitcoins from one wallet to another?Say I have 2 wallets, an older non-encrypted one and a fresh new encrypted wallet with all new addresses. If I have an address in the older wallet that may receive some bitcoins in the future is there away to set it up so that these bitcoins will automatically be sent to an address in the new encrypted wallet. Or do I have to keep my old wallet for ever in case an address in it receives some bitcoins and then manually send them on to the new wallet.",
    "answers": [
      "You may use /etc/crontab on your Ubuntu: * * * * * root /usr/local/bin/bitcoin_resender And script shall looks like: $ cat /usr/local/bin/bitcoin_resender #!/bin/bash if [ $(echo \"$(bitcoind getbalance) > 0\" | bc) -eq 1 ];then bitcoind sendtoaddress YOUR_NEW_ADDRESS $(bitcoind getbalance) \"Comment for resender\" fi It will check every minutes your bitcoind balance and resend each bitcoins to YOUR_NEW_ADDRESS.",
      "Short answer, no you can not make it automatically forward. You'd have to setup a script that checked the old wallet (bitcoind loaded with that wallet) for a balance and have it transfer to the new one after that."
    ]
  },
  {
    "question": "What are the advantages/disadvantages of a continuously decreasing block reward compared to the current method?The current method to control the bitcoin supply to a maximum of 21 million BTC is to reduce the block reward (currently 50 BTC/block) by 50% every 210000 blocks. In this forum post there is a discussion about \"why doesn't the block reward decrease continuously?\". The OP writes: So I personally wish that Satoshi had instead implemented a continuous block reward decrease. With that approach, the reward will decrease ever-so-slightly with each successive block but still converge to 21 million. That would avoid potentially disruptive discontinuities. It's too late to change that now but, still, does anyone know why he chose a block reward function that looks like a staircase rather than a smooth curve? This gets rid of the discontinuity (block reward going from 50 to 25 BTC) at the 210000 block mark and at each subsequent block reward readjustment. Would this be better than the current method? Are there other advantages to this method? Are there any disadvantages to a continuously decreasing block reward? One disadvantage I can possibly think of is that this would favor \"early adopters\" even more than the current bitcoin implementation.",
    "answers": [
      "The main advantage of the staircase rewards is simplicity. It's easier to implement; easier to describe; easier to plan with. The main disadvantage is that it is less mathematically elegant. It will not be very disruptive in practice because it is known in advance and can be planned for. The early adopter advantage is not a consideration, as it can trivially be controlled with the timescale parameter.",
      "One severe disadvantage is that the hashrate will plunge dramatically right after the last 50BTC block instead of decaying slowly. In the long run (i.e. over multi-month horizons) people will mine if the reward per share exceeds their cost of electricity per share. Most miners know their electricity cost, and a lot of them will see in advance that the 50BTC->25BTC drop will put them \"in the red\", where it costs them more in electric bills to mine 1BTC than it would cost them to buy 1BTC on an exchange. These miners will be ready in advance and will switch off within a day of the 50BTC->25BTC block. I'm not convinced that the community, the network, or the developers are prepared for this, and having it happen over the course of a few days is going to make dealing with it harder rather than easier. One advantage is that it probably helped bootstrap the network hashrate more quickly. It's easier to say \"oh, I'll investigate this mining thing next week\" if you know that each week's reward is only slightly less than next week's. On the other hand, if you know the rate will be cut in half at some point, waiting a week to get started means you're sacrificing (approximately) a \"50BTC/block week\" of which there are a limited supply. I know it certainly got me to prioritize starting my mining experiments above other stuff that could wait a few weeks/months."
    ]
  },
  {
    "question": "Speed of operations in the Bitcoin networkDid anyone measure how fast transactions spread through the Bitcoin network? For example, how long does it take for a newly generated block to be propagated to most active clients? Mainly asking this question to get some general idea whether an alternative protocol that would aim to have faster transactions is really feasible, or is 10 minutes a good buffer.",
    "answers": [
      "The alternative currency Geist Geld is experimental and is trying to approach a maximum block rate (that's currently achievable), and has apparently settled upon a target block rate of 1 block per 15 seconds . However, the block rate doesn't necessarily make a substantial difference to how you would use a currency as you could still consider a small transaction accepted even before it's been included in a transaction block, whereas with a faster block rate you may need to wait just as long. There has been lots of discussion on how a faster block rate would affect things (eg here , here , here , and here ) but I think that ribuck summarises it well in that last link: \"If you make the blocks too frequent, you get more cases where two blocks are generated at nearly the same time. Due to network propagation delays, this can cause temporary splits in the block chain. On the other hand, if you make blocks too infrequent, it takes too long for a transaction to become essentially irrevocable.\" That same link mentions a calculated latency of 2.11 seconds. With a block rate that's too fast, you may end up with miners consolidating within a part of the network with low latency, creating an unfair distribution of mining returns."
    ]
  },
  {
    "question": "Is there any way the Bitcoin network could resist a viral tainted-coin tagging system implemented by regulators?Already it's possible for MtGox etc. to detect spends of coins that have certain well-known thefts in their history. If regulators forced audits on exchanges and key popular merchants, as well as keeping track of coins they deemed to have been involved in illegal activities, they could make these exchanges and merchants pay a small tax on these 'tainted' transactions and pass this cost on to the consumer. As the regulators 'tainted' coin list would be public, it would become in more and more peoples interest to use wallet software which subscribes to the 'taint' list in order to reject coins they know will incur a penalty upon spending. The more the regulator raises the tax at the exchanges and audited merchants, the more people must join. Audited exchanges and merchants would have to submit batches of all bitcoin addresses involved in their transactions to the regulator. Agents could perform random transactions with exchanges and merchants to make sure 100% of transaction IDs are reported. Is this scenario realistic, and wouldn't this make Bitcoin ultimately a very controlled environment indeed? ('tainted' coins would still have value on black markets, creating a split system where bitcoins are no longer completely fungible)",
    "answers": [
      "I don't think the scenario is realistic because it would only punish innocent people. By the time coins could be marked as tainted, they would already be in the hands of innocent people. Governments don't do similar things with other currencies. For example, if you deposit dollar bills in a bank that turn out to have been stolen, the government could charge the bank a \"fee\" to clean the bills which the bank could pass on to you. But governments don't do that because they recognize that by the time the bills could get on a \"hot list\", they're already in the hands of innocent people. There are also specific features of Bitcoin that make this difficult. Transactions put all the input Bitcoins into a big pile which they dole out as outputs. There's no concept of particular output Bitcoins corresponding to particular inputs. Bitcoins don't have a serial number that can be traced through the block chain. So any such tracking rules would be basically arbitrary. It's just not something realistic. It's more realistic with physical currencies which have serial numbers and are widely used to facilitate crimes and buy contraband. And governments don't do it with physical currencies -- largely because they know it would only punish the innocent.",
      "As all transactions are transparent and can be seen by anyone, there is no way of resisting it other than by the unwillingness of the community. Only problem I can see with the discrimination against certain coins, are transactions that have multiple inputs and outputs, which would either \"wash\" the dirty coins, thus making the point moot, or \"taint\" new coins, thus being able to \"infect\" many more addresses. Say I had 100 infected coins and sent each known address a Satoshi. At the moment the main client would accept that transaction and add the infected coin to your wallet. If you went with the tainting scenario, this would effectively taint the whole system. Of course, by then the clients would become more discriminatory about the coins they accept."
    ]
  },
  {
    "question": "Knowing a single transaction can you track down a Bitcoin user?I have used this transaction to donate to Wikileaks. I have applied no special techniques to obsure my identity. How much information can find out about me on the blockchain. What tools would you use? Can you guess the following information? Can you prove it? How did I get the bitcoins I was donating? What else did I use my bitcoins for? What was my total bitcoin balance at a given time? What wallet am I using? Please try not to violate other people's right to privacy.",
    "answers": [
      "Knowing the Wikileaks donation address , one knows every address that contributed to them. Knowing a given address we are interested in, we can try tracing the coins back to when they were created (which can be harder if they were mined by a large pool, in that case you'd probably get a lot of origin blocks). Given an address we know when it received coins and from what address. If the particular wallet contained more than one receiving address, sometimes the addresses would be used together. If you have more than one address in the \"From address\", you know the person had to have them together in on wallet. And now a bit of knowledge one can gain from outside the Block Chain: A lot of people put notes like \"My Bitcoin Address is: 1HWbVLhxj7bhewhyapMZpyhqWAeAhJd51E\" in places like the forum. Then you can link the addresses to particular nicknames, and in some cases emails, names, facebook pages and so forth. If you use one address for everything, one can know if you contributed to Wikileaks, or other known addresses. If one would have a big node in the Bitcoin Network that by chance would be connected to your Client when it sends transactions using the known addresses, one could potentially trace the IP of your computer. If you have a static IP, this can identify you. So all in all, with enough resources, time and determination, one can know quite a lot about a given Bitcoin address. A lot of it can be mitigated with enough diligence, but some of methods might be quite hard.",
      "You can use the 'Address balance sheet' tool at http://blockchain.info/address-balance-sheet and add the addresses associated with the transaction whose owner you are trying to identify. For example for the transaction you mentioned most common ip is 109.201.253.77 from Dnepropetrovsk, Ukrane. It is not always accurate but if you have enough addresses patterns can emerge, is this correct?"
    ]
  },
  {
    "question": "What are the risks of using Strongcoin.com as an online wallet?Strongcoin claims it is \"The Safest way to store your Bitcoins. The only Bitcoin e-wallet service that's not vulnerable to security breaches. Your Bitcoin keys are encrypted in the browser.\" As I understand it, with their system your private keys are essentially encrypted by your browser before they are sent to the website. They also appear to have a method of creating an encrypted paper copy of your wallet so you can restore your wallet if the website disappears. Even so, it seems you're still potentially vulnerable if you access your wallet from an infected computer (i.e. through keystroke loggers and more advanced logging techniques). What other risks are there in using such a service? Note: I have not used Strongcoin, and have no affiliation with them in any way.",
    "answers": [
      "I am the operator of My Wallet which is a similar javascript based wallet service. I will try and keep this answer as impartial as possible. The Website Owner is Malicious The website operator is free to change the javascript code at any time so if they are so inclined can change the code to uploaded your unencrypted keys or intercept your password. If you do not trust the site owner it is therefore not recommended you use such a service. The website database is leaked Assuming the site has been programmed correctly in the event of a database leak only your encrypted keys will be leaked. The attacker maybe able to brute force your password if it is not secure enough, but as long as users are made aware of the leak they will have enough time to move their coins to new addresses. The website server is compromised In the event of a full server breach the attacker may be able to alter the javascript code or website code to send him an unencrypted copy of the keys next time you login. This type of attack is generally less common than database leaks and to have any significant effect would need to go unnoticed by the site operator. You forget your password As your password is never sent to the server the site owner cannot offer a password recovery procedure. In the event of a lost password your key(s) will be unusable. Paper wallet backups can help with this. Key logger or virus If you have a key logger or virus on your computer it is possible to that it could intercept your password which the attacker can then use to login to your wallet and spend your coins. Traditional desktop wallets are also vulnerable to this. My Wallet is less vulnerable to this as the site supports yubikey two factor authentication. One final note: Using My Wallet you can add your Bitcoin address only without the associated private key. If you then keep a paper wallet backup of your private key even in the event your account is compromised there is nothing to steal.",
      "I'm the owner of StrongCoin. Ben has detailed just about every possible risk with StrongCoin. You can read about how we handle server security in our FAQ . It's not in my interests to defraud my customers, I'm pretty easy to trace and I don't fancy having angry users knocking on my door So with Bitcoin like cash there are risks with storage, I lost a wallet.dat which spurred me to build StrongCoin. StrongCoin is a convenient way to store and spend Bitcoins. I recommend you hold your spending Bitcoins in StrongCoin and use an offline mechanism for your savings or high value holdings."
    ]
  },
  {
    "question": "What is the safest medium on which to store my wallet/private keys?What is the safest medium on which to store my wallet/private keys? I avoid eWallets like the plague. I have my wallet on my computer at the moment with the Bitcoin passphrase encryption and I have a few backups on different harddrives/USB drives. But USB drives don't seem to be the most reliable thing to store wallets on, and I want to move my wallet off my computer for improved safety, so I was looking at paper wallets and they seem good apart from if they deteriorate over time, or from things like water damage etc. CDs seem okay to use but they can also get scratched and can't be updated once burnt. I'd also rather avoid cloud file services. A plastic card that I could print my public/private keys on seemed like a good idea, but this would have to be printed by a third party as card printers are expensive, unless there's somewhere I can go to do it myself. Any recommendations on the safest medium to store Bitcoins on?",
    "answers": [
      "Print out your private keys to a Paper Wallet and print the keys on Archival Quality Paper . Those should last until the year 2211. They are however un-encrypted so you should store them in a bank safety-deposit-box or somewhere just as safe.",
      "You probably should ask this question on other Stack Exchanges, like Super User, as the question is not specific to Bitcoins really. Safest place to store your wallet key would be in your memory, if you are a type that can recall a long string of digits many years later. You could try using some mnemonic tricks, like encoding the numbers in a poem with number of letters in each word corresponding to a given number. If you want something tangible, you should look into putting the key on some medium that does not deteriorate over a long period of time. You can try scratching it into a sheet of plastic, or using some soldering iron to melt it in. You could also go for carving it in stone or cement block, but that would start to get a bit excessive. You can always get a laminating device, print your wallet as a QR code and laminate it, should work well enough while not being too expensive. It all boils down to how much time and money you want to spend securing your wallet and what hazards you want to protect it from."
    ]
  },
  {
    "question": "Got the Bitcoin Wallet. How do I transfer money into it?I've got active connections & there are blocks downloaded but I don't know what to do next. Presumably I need to transfer some money in there so I can buy bitcoins. But how? Any suggestions gratefully relieved. Thanks.",
    "answers": [
      "It is not possible to buy bitcoins from inside the client. What you need to do is this: Find someone that you can buy bitcoins from. One way is to use an exchange, such as Mt.Gox , that let's you deposit USD (or some other currency) and then buy bitcoins. In the Bitcoin client (assuming you use the original client from bitcoin.org), get a Bitcoin address from the \"Receive coins\" tab (\"New address...\"). Using a new address for each transfer will increase your anonymity. Transfer the bitcoins you bought to your new Bitcoin address. If you use Mt.Gox you would use the \"withdraw\" option. The bitcoins will then show up in your client."
    ]
  },
  {
    "question": "How was the magic network ID value chosen?Messages on the Bitcoin network are identified by the magic value 0xD9B4BEF9, and on the testnet by 0xDAB5BFFA. Why were these values chosen?",
    "answers": [
      "main.cpp carries this comment: // The message start string is designed to be unlikely to occur in normal data. // The characters are rarely used upper ascii, not valid as UTF-8, and produce // a large 4-byte int at any alignment. unsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };",
      "It was chosen because it is a prime number, and also because 4190024921 is the hypotenuse of a primitive Pythagorean triple: 4190024921^2 = 2924728880^2 + 3000378279^2 Edit: Note that you must consider byte order. The TCP protocol requires the number to be encoded in big-endian. 0xf9beb4d9 (little) = 0xd9b4bef9 (big) See https://stackoverflow.com/a/13514942 for more info about that. Update: It is also a sum of squares."
    ]
  },
  {
    "question": "How to validate a Bitcoin address is a real one?Is there a code snippet that validates a bitcoin address? I'm looking for both javascript and java snippets. The code should support both testnet and real addresses.",
    "answers": [
      "also, the official client bitcoind has a 'validateaddress' command. see https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_Calls_list you could call that from your code if you happen to have bitcoind running already.",
      "part of https://github.com/mikegogulski/bitcoin-php/blob/master/src/bitcoin.inc private static $hexchars = \"0123456789ABCDEF\"; private static $base58chars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"; public static function checkAddress($addr, $addressversion = \"00\") // hex byte { $addr = self::decodeBase58($addr); if (strlen($addr) != 50) { return false; } $version = substr($addr, 0, 2); if (hexdec($version) > hexdec($addressversion)) { return false; } $check = substr($addr, 0, strlen($addr) - 8); $check = pack(\"H*\", $check); $check = strtoupper(hash(\"sha256\", hash(\"sha256\", $check, true))); $check = substr($check, 0, 8); return $check == substr($addr, strlen($addr) - 8); } private function decodeBase58($base58) { $origbase58 = $base58; //only valid chars allowed if (preg_match('/[^1-9A-HJ-NP-Za-km-z]/', $base58)) { return \"\"; } $return = \"0\"; for ($i = 0; $i < strlen($base58); $i++) { $current = (string)strpos(self::$base58chars, $base58[$i]); $return = (string)bcmul($return, \"58\", 0); $return = (string)bcadd($return, $current, 0); } $return = self::encodeHex($return); //leading zeros for ($i = 0; $i < strlen($origbase58) && $origbase58[$i] == \"1\"; $i++) { $return = \"00\" . $return; } if (strlen($return) % 2 != 0) { $return = \"0\" . $return; } return $return; } private function encodeHex($dec) { $return = \"\"; while (bccomp($dec, 0) == 1) { $dv = (string)bcdiv($dec, \"16\", 0); $rem = (integer)bcmod($dec, \"16\"); $dec = $dv; $return = $return . self::$hexchars[$rem]; } return strrev($return); }"
    ]
  },
  {
    "question": "Is \"Reclaiming Disk Space\" already implemented? How effective will it be?Some people are concerned about the scalability of Bitcoin. The blockchain already has reached nearly 1 GB to download and store, which is not exactly in the spirit of a modern thin client, especially in regards to mobile devices. Now when consulting the Satoshi Paper , it seems they already came up with a solution: 7. Reclaiming Disk Space Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree [...], with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory. Is this already implemented for the current version? \"4.2 MB per year\" suggests that no. Is it already on the roadmap? Have the developers met any unforeseen obstacles? Will the solution be as effective as promised?",
    "answers": [
      "The blockchain already has reached nearly 1 GB to download and store, The proposal in Satoshi's paper does not reduce the download requirements , only the storage requirements (see this post to the bitcoin-dev mailing list). Unless you are able to rely on some trusted third party, you still need to download at least all of the block headers. If you download only the headers and not the full blocks and treat \"buried X blocks deep\" as proof that a transaction is valid you are open to a new class of attacks that would not affect a normal full-chain client. The normal client treats \"buried X blocks deep\" as proof that a transaction will not be reversed later on -- the check to ensure that the transaction's inputs are unspent is completely separate from this. A thin client cannot check that a transaction's inputs are unspent because it has only the block headers -- it does not have a copy of the transactions themselves. The most worrisome of these new attacks have to come from your ISP, but in this day of wi-fi cafes that isn't such a far-fetched scenario. So, use at your own risk. I've been picking away at a wiki page dealing with all these issues.",
      "Currently there are no official lighweight clients like that available, nor are they in the making as far as I know. There are, however, a couple unofficial clients, like StrongCoin or Electrum, that hold even less data. Those are, however, working in a server-client mode, not peer-to-peer as the client described by Satoshi. It is quite possible that such a client will never be created, as storing just the block headers is a bit pointless in itself. You have to rely on the network providing you a valid block chain anyway, you don't get much out of storing the headers, and if lightweight Bitcoin clients relying on servers would become widely available and accepted, you could do with even less data."
    ]
  },
  {
    "question": "What information does a wallet contain?What information does the Bitcoin wallet file used by the Bitcoin.org client contain? Is the owner's Bitcoin balance written in the wallet.dat file, or does it contain a list of transactions that have been made since the beginning of wallet creation? Does the wallet's filesize grow bigger as more transactions are made?",
    "answers": [
      "From looking at the code, the wallet.dat can contain entries of the following types: name - an address book name tx - a transaction acentry - an accounting entry key - a pair of public and private keys mkey - a master key ckey - an encrypted key defaultkey - the default receiving address' key pool - a keypool entry version - the version of the software that wrote this wallet minversion - the earliest version of the software that can read this wallet cscript - a script bestblock - a pointer to the end of the best blockchain seen wkey - a private key (no longer used) setting - used to store user interface settings (no longer used, except to hold an invalid setting to stop pre-0.4.0 versions of the client which don't understand minversion from loading wallets that are too new for them) See also this answer .",
      "A default bitcoin wallet contains a list of private and pub key pairs. A number of keys are created on generation this is to allow for \"swap\" as you send money from it, these are not visible directly. This does not affect your balance which you use. Your transactions are stored within the blockchain. If you generate new address to receive to then your wallet size will grow. If your wallet is moved to a new computer, with no blockchain, it will appear empty until you download blocks up until your transactions are known by the client."
    ]
  },
  {
    "question": "Is Bitcoin a currency?This question seems to be asked every now and then when legal status of Bitcoin is discussed - Is Bitcoin a currency? What are the characteristics that would make it a currency, and what makes it different from the standard definition?",
    "answers": [
      "TL;DR Bitcoin already is a currency because it's a generally accepted medium of exchange among certain communities. As those communities grow and usage spreads to other communities, its strength as a currency solidifies. This requires a little bit of history. I am not a numismatist, but I have studied this a little even before the advent of Bitcoin. Currency is a set of things that are a generally accepted medium of exchange . Throughout history, an accepted medium of exchange has been anything of value to both people involved in the transaction. Typically, these are physical goods that have some semblance of inherent usefulness and a degree of rarity . Also, there is typically a perceived finite supply of the thing. Lastly, the importance of portability is generally high: if it is cumbersome to carry enough of the thing to make daily purchases, it is less likely to be an acceptable medium of exchange because no one will want to carry it around with them! So, I've set the stage for most world currencies: small, portable coins comprised of precious metals. The metals can be used in products and are rare in that it takes work to extract them from the earth. The supply is thus finite, until another deposit of the metal is discovered. That's when the overall value of the coin may drop compared to other things, but at its simplest explanation, it means that the coin metal has become less rare. This kind of coinage started organically. People could give each other a weight of metal and know what its value was to them. Eventually, as governments were established, governments would gather up all the metals they wanted by whatever means necessary, and then melt the metals in order to mint coins with an intended, consistent value because of their weight. As the price of goods increased steadily, it was impractical for a person to carry a sack of coins, so someone contrived the bright idea of paper money, and later, a bank note. These are simply a promise that a person can exchange that note for the coins related to it. Thus, this paper money or bank note used to be simply a proxy to more valuable coins or other forms of metal. However, this is prone to interference by those who print the notes and the governments that oversee it all. Eventually, paper notes became backed by promises for coins and metals that didn't exist. So, the value of the notes in relation to the coins and metals decreased. Then banks stopped accepting notes in exchange for coins. What resulted is called fiat currency , which has a value simply because some government declares it to have value. It is actually more closely related to debt, but that's a complex subject for another question. A chief problem of fiat currency is that a bank or a government can simply print more bank notes in order to create more money. This works in the short term, but any savvy person will realize the similarity of this to someone finding a new deposit of a metal. When there is suddenly more of something, what existed of that something is suddenly less valuable because it is less rare. This does not matter a whole lot when there is only one thing of value. When there are many things of value, e.g. silver, gold, platinum, diamonds, oil, other fiat currencies, the value of our something compared to those will be affected. All of these things are usable as currency but some are more practical than others. Bitcoin is similar, but more abstract. Bitcoin has no inherent usefulness : it's just data. It does have rarity : the supply is finite because only 21M coins can exist. The available supply is growing by the minute, but there will be a day when no more will be \"found\", thereby halting its inflation in value. Instead, at that time, its value will begin to deflate as coins are permanently lost for one reason or another. Bitcoin's inherent uselessness as a physical good -- data -- contributes to another factor: its portability . It's just data and we can surely store a lot of data in a small physical space. This property makes it almost infinitely portable. A billionaire could carry their life savings in their pocket on a Flash drive and no one else could have control of the physical thing that is their life savings. Creating a currency when the physical thing has no inherent usefulness requires that initial participants assign a value to it. It's a fiat currency, but the value isn't controlled by any central authority. No central authority can create more of it. No central authority can destroy it. This is not to say that an authority cannot destroy it , because a government surely could pass laws to prohibit its exchange/possession/production. In its infancy, Bitcoin has limited intra-economy value, that is, it has limited value as something that can be exchanged for payment for work or goods simply because not a lot of people have boldly decided to accept it with the hopes that they can spend it on something they need. This value grows daily as more businesses start and more people believe that they can spend what they accept in it. Bitcoin at this stage is no different from arcade tokens, in-game currency, or Monopoly money used in schools to teach children how money works: it has a limited value to a limited audience. It is currency to those who participate in this limited audience, and its inherent value (not necessarily its value relative to other traditional currencies) grows as the audience grows. To add another question to the original: How can the strength of Bitcoin as a currency grow? The answer is quite simple: use it! Find something to buy with it, find something to sell and accept it as payment. Keep this cycle going and get others involved.",
      "A currency should fullfill two economic needs: A mean of exchange and a possibility of storing value. For storing value in an appropriate way price stability is crucial, but as prices for goods and services available in exchange for BTC are flexible price stability can only be reached by relatively stable rates of exchange (assuming price stability in the supplying economies). With respect to historical price volatility it fairly can be said that BTC are not yet a \"regular\" currency in an economic sense."
    ]
  },
  {
    "question": "Transaction with slightly changed script is never relayedI am playing with bitcoin transaction a bit now. I have a question. Normally, the output script looks like OP_DUP OP_HASH160 (hash) OP_EQUALVERIFY OP_CHECKSIG Now that is understandable. However, when I slightly change the script with an outgoing translation to OP_DUP OP_DROP OP_DUP OP_HASH160 (hash) OP_EQUALVERIFY OP_CHECKSIG this transaction is never relayed (as far as I can say) and never reaches any miner, even when it's 100% legal. What is going on? Why is it not relayed? I even added quite large fee on it. And a second question - if my suspicion is correct and it is actually never relayed - what would happen if some miner actually accepted it and this transaction ended in the blockchain? Would it be a valid transaction? Would the client be able to \"see it\" when he is not able to relay it?",
    "answers": [
      "The standard client will not relay non-standard transactions. However, if you get them directly to a miner that accepts them, clients will process them correctly and the transaction will work. You can send your transactions to 173.242.112.53 . This is a server run by Eligius that will relay all valid transactions and they will include even non-standard transactions in the blocks they mine. Others who are willing to relay or include free and non-standard transactions also tend to link to this node, so it can get your transaction included in blocks mined by other pools as well.",
      "This is for sending transactions directly to Eligius: http://eligius.st/~wizkid057/newstats/pushtxn.php"
    ]
  },
  {
    "question": "What is rpcuser?Can I just make up a value for rpcuser/rpcpassword in bitcoin.conf? Or do I have to set one up somewhere?",
    "answers": [
      "You can set any values you want for rpcuser and rpcpassword in bitcoin.conf . Those values will be your username and password when you will be connecting to your bitcoind through HTTP JSON RPC. Also be sure to set other important values in .conf file, like server , rpcallowip and a few others to ensure your server is running correctly and securely.",
      "No you can define the rpcuser and rpcpassword in the bitcoin.conf file itself. Usually it is commented, you can uncomment the line rpcuser and rpcpassword and input your username and password which will be used when you will be connecting to your bitcoind through HTTP JSON RPC."
    ]
  },
  {
    "question": "What happens when a gateway on the Ripple network defaults or simply vanishes?What happens when a gateway on the Ripple network defaults or simply vanishes? Do people that got their money from it lose that money, do other gateways honour the IOUs issued by that gateway still, or does something else happen?",
    "answers": [
      "Any of those things can happen. Likely, there will be some \"hot potato\" going on as people rush to offload any IOUs they hold to people who haven't yet gotten the news. It's unlikely other gateways would honor the IOUs unless they were contractually obligated to. This would likely harm their customers as they'd have to make up the losses somehow -- likely with higher fees. Gateways are in the business of being trusted. So they have a huge incentive to find ways to induce people to trust them. We don't yet know what will happen, but some possibilities include: Gateways could cross-insure each other. (But this might make you less likely to trust a gateway for fear that it will collapse due to the collapse of another gateway.) Gateways could be insured by governments or private insurance companies. (They hold other people's fiat currency, so the legal framework for doing this exists in many countries.) Gateways could post bonds or liens on physical assets that could be seized or sold if the gateway defaults and used to cover their obligations. Note that this is only a significant issue for people who wish to use the Ripple system to hold fiat currencies as a store of value. It's not a major issue for a merchant who just wants to get paid in dollars as they can use a gateway that electronically deposits the currency in their regular bank account on a daily basis. If that gateway goes out of business, they'd only lose a day or two's revenue and could switch gateways on the Ripple system with no disruption. (You might think losing two days revenue is a big deal, but remember, businesses already pay 2% to take credit cards. That's like losing seven days revenue every year.)",
      "This question actually gets at the fundamental nature of Ripple. Ripple is essentially an online P2P implementation of free banking. Free banking is somewhat similar to how banking worked in the United States for much of the 19th Century (with a few major caveats) prior to the Federal Reserve and FDIC systems, and indeed back then banks would sometimes just vanish overnight. Because of this, banks went to great lengths to emphasize their trustworthiness; for example in my neighborhood in Brooklyn the Williamsburgh Savings bank built a colossal structure ( exterior , interior ), basically as a way of signaling they were in it for the long haul. Interestingly, bills of exchange (that is, IOUs) were also broadly traded at the time, and of course are a major feature of Ripple (more explanation here ). In a fundamental way, free banking (and Ripple) seek to build a banking system on trust among parties without relying on promises from a centralized authority such as a government or central bank. Free banking is a popular idea among Austrian economists because it would be a way of removing government intervention from the currency and banking sectors. You can read more about it on Wikipedia ."
    ]
  }
]